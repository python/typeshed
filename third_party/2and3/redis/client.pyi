# Stubs for redis.client (Python 3.6)
#
# NOTE: This dynamically typed stub was automatically generated by stubgen.
from datetime import datetime
from typing import Any, Optional, Text, Dict, Union, Callable, Type, TypeVar, List, Tuple, Set, \
    Iterator

from redis import ConnectionPool
from redis.lock import Lock, LuaLock

_TLock = TypeVar('_TLock', Type[LuaLock], Type[Lock])


class StrictRedis:
    @classmethod
    def from_url(cls, url: Text, db: Optional[int] = ..., **kwargs): ...
    def __init__(self, host: str = ..., port: int = ..., db: int = ..., password: Optional[str] = ...,
                 socket_timeout: Optional[float] = ..., socket_connect_timeout: Optional[float] = ..., socket_keepalive: Optional[bool] = ..., socket_keepalive_options: Optional[Dict[str, Union[int, bytes]]] = ...,
                 connection_pool: Optional[ConnectionPool] = ..., unix_socket_path: Optional[str] = ..., encoding: str = ..., encoding_errors: str = ..., charset: Optional[str] = ..., errors: Optional[str] = ...,
                 decode_responses: bool = ..., retry_on_timeout: bool = ...,
                 ssl: bool = ..., ssl_keyfile: Optional[str] = ..., ssl_certfile: Optional[str] = ..., ssl_cert_reqs: Optional[int] = ..., ssl_ca_certs: Optional[str] = ...,
                 max_connections: Optional[int] = ...) -> None: ...
    def set_response_callback(self, command: str, callback: Callable[..., Any]): ...
    def pipeline(self, transaction: bool = ..., shard_hint: Optional[Any] = ...): ...
    def transaction(self, func, *watches, **kwargs): ...
    def lock(self, name: str, timeout: Optional[float] = ..., sleep: float = ..., blocking_timeout: Optional[float] = ..., lock_class: Optional[_TLock] = ..., thread_local: bool = ...) -> _TLock: ...
    def pubsub(self, **kwargs): ...
    def execute_command(self, *args, **options): ...
    def parse_response(self, connection, command_name: str, **options): ...
    def bgrewriteaof(self) -> bool: ...
    def bgsave(self) -> bool: ...
    def client_kill(self, address) -> bool: ...
    def client_list(self) -> List[Dict[str, str]]: ...
    def client_getname(self) -> Union[bool, str]: ...
    def client_setname(self, name: str) -> bool: ...
    def config_get(self, pattern: str = ...) -> Dict[str, str]: ...
    def config_set(self, name: str, value) -> bool: ...
    def config_resetstat(self) -> bool: ...
    def config_rewrite(self): ...
    def dbsize(self): ...
    def debug_object(self, key) -> Dict[str, Union[int, str]]: ...
    def echo(self, value): ...
    def flushall(self) -> bool: ...
    def flushdb(self) -> bool: ...
    def info(self, section: Optional[Any] = ...) -> Dict[str, str]: ...
    def lastsave(self) -> Optional[datetime]: ...
    def object(self, infotype, key) -> Any: ...
    def ping(self) -> bool: ...
    def save(self) -> bool: ...
    def sentinel(self, *args): ...
    def sentinel_get_master_addr_by_name(self, service_name) -> Optional[Tuple[Any, int]]: ...
    def sentinel_master(self, service_name) -> Dict[str, Any]: ...
    def sentinel_masters(self) -> Dict[str, Dict[str, Any]]: ...
    def sentinel_monitor(self, name: str, ip, port, quorum) -> bool: ...
    def sentinel_remove(self, name: str) -> bool: ...
    def sentinel_sentinels(self, service_name) -> List[Dict[str, Any]]: ...
    def sentinel_set(self, name: str, option, value) -> bool: ...
    def sentinel_slaves(self, service_name) -> List[Dict[str, Any]]: ...
    def shutdown(self) -> bool: ...
    def slaveof(self, host: Optional[Any] = ..., port: Optional[Any] = ...) -> bool: ...
    def slowlog_get(self, num: Optional[Any] = ...) -> List[Dict[str, Any]]: ...
    def slowlog_len(self) -> int: ...
    def slowlog_reset(self) -> bool: ...
    def time(self) -> Tuple[int, int]: ...
    def wait(self, num_replicas, timeout): ...
    def append(self, key, value): ...
    def bitcount(self, key, start: Optional[Any] = ..., end: Optional[Any] = ...) -> int: ...
    def bitop(self, operation, dest, *keys): ...
    def bitpos(self, key, bit, start: Optional[Any] = ..., end: Optional[Any] = ...) -> int: ...
    def decr(self, name: str, amount: int = ...) -> int: ...
    def delete(self, *names) -> int: ...
    def __delitem__(self, name: str): ...
    def dump(self, name: str): ...
    def exists(self, name: str) -> bool: ...
    __contains__ = ...  # type: Any
    def expire(self, name: str, time) -> bool: ...
    def expireat(self, name: str, when) -> bool: ...
    def get(self, name: str) -> Optional[Any]: ...
    def __getitem__(self, name: str): ...
    def getbit(self, name: str, offset) -> int: ...
    def getrange(self, key, start, end): ...
    def getset(self, name: str, value): ...
    def incr(self, name: str, amount: int = ...) -> int: ...
    def incrby(self, name: str, amount: int = ...) -> int: ...
    def incrbyfloat(self, name: str, amount: float = ...): ...
    def keys(self, pattern: str = ...): ...
    def mget(self, keys, *args): ...
    def mset(self, *args, **kwargs) -> bool: ...
    def msetnx(self, *args, **kwargs) -> bool: ...
    def move(self, name: str, db) -> bool: ...
    def persist(self, name: str) -> bool: ...
    def pexpire(self, name: str, time): ...
    def pexpireat(self, name: str, when): ...
    def psetex(self, name: str, time_ms, value) -> bool: ...
    def pttl(self, name: str): ...
    def randomkey(self) -> Optional[Any]: ...
    def rename(self, src, dst) -> bool: ...
    def renamenx(self, src, dst) -> bool: ...
    def restore(self, name: str, ttl, value): ...
    def set(self, name: str, value, ex: Optional[Any] = ..., px: Optional[Any] = ..., nx: bool = ..., xx: bool = ...) -> bool: ...
    def __setitem__(self, name: str, value): ...
    def setbit(self, name: str, offset, value) -> int: ...
    def setex(self, name: str, time, value) -> bool: ...
    def setnx(self, name: str, value) -> bool: ...
    def setrange(self, name: str, offset, value) -> int: ...
    def strlen(self, name: str) -> int: ...
    def substr(self, name: str, start, end: int = ...): ...
    def ttl(self, name: str): ...
    def type(self, name: str): ...
    def watch(self, *names) -> bool: ...
    def unwatch(self) -> bool: ...
    def blpop(self, keys, timeout: int = ...) -> Optional[Tuple]: ...
    def brpop(self, keys, timeout: int = ...) -> Optional[Tuple]: ...
    def brpoplpush(self, src, dst, timeout: int = ...): ...
    def lindex(self, name: str, index): ...
    def linsert(self, name: str, where, refvalue, value) -> int: ...
    def llen(self, name: str) -> int: ...
    def lpop(self, name: str): ...
    def lpush(self, name: str, *values) -> bool: ...
    def lpushx(self, name: str, value) -> int: ...
    def lrange(self, name: str, start, end): ...
    def lrem(self, name: str, count, value): ...
    def lset(self, name: str, index, value) -> bool: ...
    def ltrim(self, name: str, start, end) -> bool: ...
    def rpop(self, name: str): ...
    def rpoplpush(self, src, dst): ...
    def rpush(self, name: str, *values) -> bool: ...
    def rpushx(self, name: str, value) -> int: ...
    def sort(self, name: str, start: Optional[Any] = ..., num: Optional[Any] = ..., by: Optional[Any] = ..., get: Optional[Any] = ..., desc: bool = ..., alpha: bool = ..., store: Optional[Any] = ..., groups: bool = ...): ...
    def scan(self, cursor: int = ..., match: Optional[Any] = ..., count: Optional[Any] = ...) -> Tuple[int, Any]: ...
    def scan_iter(self, match: Optional[Any] = ..., count: Optional[Any] = ...) -> Iterator[Any]: ...
    def sscan(self, name: str, cursor: int = ..., match: Optional[Any] = ..., count: Optional[Any] = ...) -> Tuple[int, Any]: ...
    def sscan_iter(self, name: str, match: Optional[Any] = ..., count: Optional[Any] = ...) -> Iterator[Any]: ...
    def hscan(self, name: str, cursor: int = ..., match: Optional[Any] = ..., count: Optional[Any] = ...) -> Tuple[int, Dict]: ...
    def hscan_iter(self, name: str, match: Optional[Any] = ..., count: Optional[Any] = ...) -> Iterator[Dict]: ...
    def zscan(self, name: str, cursor: int = ..., match: Optional[Any] = ..., count: Optional[Any] = ..., score_cast_func: Any = ...) -> Tuple[int, List[Tuple[Any, Any]]]: ...
    def zscan_iter(self, name: str, match: Optional[Any] = ..., count: Optional[Any] = ..., score_cast_func: Any = ...) -> Iterator[List[Tuple[Any, Any]]]: ...
    def sadd(self, name: str, *values) -> int: ...
    def scard(self, name: str) -> int: ...
    def sdiff(self, keys, *args) -> Set: ...
    def sdiffstore(self, dest, keys, *args) -> int: ...
    def sinter(self, keys, *args) -> Set: ...
    def sinterstore(self, dest, keys, *args) -> int: ...
    def sismember(self, name: str, value) -> bool: ...
    def smembers(self, name: str) -> Set: ...
    def smove(self, src, dst, value) -> bool: ...
    def spop(self, name: str) -> Any: ...
    def srandmember(self, name: str, number: Optional[int] = ...) -> Any: ...
    def srem(self, name: str, *values) -> int: ...
    def sunion(self, keys, *args) -> Set: ...
    def sunionstore(self, dest, keys, *args) -> int: ...
    def zadd(self, name: str, *args, **kwargs) -> int: ...
    def zcard(self, name: str) -> int: ...
    def zcount(self, name: str, min, max) -> int: ...
    def zincrby(self, name: str, value, amount: int = ...) -> Optional[float]: ...
    def zinterstore(self, dest, keys, aggregate: Optional[Any] = ...) -> Any: ...
    def zlexcount(self, name: str, min, max) -> int: ...
    def zrange(self, name: str, start, end, desc: bool = ..., withscores: bool = ..., score_cast_func: Callable[..., Any] = ...): ...
    def zrangebylex(self, name: str, min, max, start: Optional[Any] = ..., num: Optional[Any] = ...): ...
    def zrevrangebylex(self, name: str, max, min, start: Optional[Any] = ..., num: Optional[Any] = ...): ...
    def zrangebyscore(self, name: str, min, max, start: Optional[Any] = ..., num: Optional[Any] = ..., withscores: bool = ..., score_cast_func: Any = ...): ...
    def zrank(self, name: str, value) -> Optional[int]: ...
    def zrem(self, name: str, *values) -> int: ...
    def zremrangebylex(self, name: str, min, max) -> int: ...
    def zremrangebyrank(self, name: str, min, max) -> int: ...
    def zremrangebyscore(self, name: str, min, max) -> int: ...
    def zrevrange(self, name: str, start, end, withscores: bool = ..., score_cast_func: Any = ...): ...
    def zrevrangebyscore(self, name: str, max, min, start: Optional[Any] = ..., num: Optional[Any] = ..., withscores: bool = ..., score_cast_func: Any = ...): ...
    def zrevrank(self, name: str, value) -> Optional[int]: ...
    def zscore(self, name: str, value) -> Optional[float]: ...
    def zunionstore(self, dest, keys, aggregate: Optional[Any] = ...): ...
    def pfadd(self, name: str, *values) -> int: ...
    def pfcount(self, *sources) -> int: ...
    def pfmerge(self, dest, *sources) -> bool: ...
    def hdel(self, name: str, *keys: str) -> int: ...
    def hexists(self, name: str, key: str) -> bool: ...
    def hget(self, name: str, key: str) -> Any: ...
    def hgetall(self, name: str) -> Dict: ...
    def hincrby(self, name: str, key: str, amount: int = ...): ...
    def hincrbyfloat(self, name: str, key: str, amount: float = ...) -> float: ...
    def hkeys(self, name: str): ...
    def hlen(self, name: str) -> int: ...
    def hset(self, name: str, key: str, value): ...
    def hsetnx(self, name: str, key: str, value): ...
    def hmset(self, name: str, mapping) -> bool: ...
    def hmget(self, name: str, keys: Any, *args: Any): ...
    def hvals(self, name: str): ...
    def publish(self, channel: str, message): ...
    def eval(self, script, numkeys, *keys_and_args): ...
    def evalsha(self, sha: str, numkeys, *keys_and_args): ...
    def script_exists(self, *args) -> List[bool]: ...
    def script_flush(self) -> bool: ...
    def script_kill(self) -> bool: ...
    def script_load(self, script) -> str: ...
    def register_script(self, script): ...
