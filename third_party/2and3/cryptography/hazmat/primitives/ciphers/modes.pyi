from abc import ABCMeta, abstractmethod
from typing import Optional

from cryptography.hazmat.primitives.ciphers import CipherAlgorithm

class Mode(metaclass=ABCMeta):
    name: str
    @abstractmethod
    def validate_for_algorithm(self, algorithm: CipherAlgorithm) -> None: ...

class ModeWithAuthenticationTag(metaclass=ABCMeta):
    tag: bytes

class ModeWithInitializationVector(metaclass=ABCMeta):
    initialization_vector: bytes

class ModeWithNonce(metaclass=ABCMeta):
    nonce: bytes

class ModeWithTweak(metaclass=ABCMeta):
    tweak: bytes

class CBC(Mode, ModeWithInitializationVector):
    def __init__(self, initialization_vector: bytes) -> None: ...
    def validate_for_algorithm(self, algorithm: CipherAlgorithm) -> None: ...

class CTR(Mode, ModeWithNonce):
    def __init__(self, nonce: bytes) -> None: ...
    def validate_for_algorithm(self, algorithm: CipherAlgorithm) -> None: ...

class CFB(Mode, ModeWithInitializationVector):
    def __init__(self, initialization_vector: bytes) -> None: ...
    def validate_for_algorithm(self, algorithm: CipherAlgorithm) -> None: ...

class CFB8(Mode, ModeWithInitializationVector):
    def __init__(self, initialization_vector: bytes) -> None: ...
    def validate_for_algorithm(self, algorithm: CipherAlgorithm) -> None: ...

class ECB(Mode):
    def validate_for_algorithm(self, algorithm: CipherAlgorithm) -> None: ...

class GCM(Mode, ModeWithInitializationVector, ModeWithAuthenticationTag):
    def __init__(self, initialization_vector: bytes, tag: Optional[bytes], min_tag_length: Optional[int]) -> None: ...
    def validate_for_algorithm(self, algorithm: CipherAlgorithm) -> None: ...

class OFB(Mode, ModeWithInitializationVector):
    def __init__(self, initialization_vector: bytes) -> None: ...
    def validate_for_algorithm(self, algorithm: CipherAlgorithm) -> None: ...

class XTS(Mode, ModeWithTweak):
    def __init__(self, tweak: bytes) -> None: ...
    def validate_for_algorithm(self, algorithm: CipherAlgorithm) -> None: ...
