# Stubs for sqlalchemy.util._collections (Python 3.6)
#
# NOTE: This dynamically typed stub was automatically generated by stubgen.

from typing import Any, Optional
from .compat import threading as threading, itertools_filterfalse as itertools_filterfalse, string_types as string_types, binary_types as binary_types

EMPTY_SET = ...  # type: Any

class AbstractKeyedTuple(tuple):
    def keys(self): ...

class KeyedTuple(AbstractKeyedTuple):
    def __new__(cls, vals, labels: Optional[Any] = ...): ...
    def __setattr__(self, key, value): ...

class _LW(AbstractKeyedTuple):
    def __new__(cls, vals): ...
    def __reduce__(self): ...

class ImmutableContainer:
    __delitem__ = ...  # type: Any
    __setitem__ = ...  # type: Any
    __setattr__ = ...  # type: Any

class immutabledict(ImmutableContainer, dict):
    clear = ...  # type: Any
    pop = ...  # type: Any
    popitem = ...  # type: Any
    setdefault = ...  # type: Any
    update = ...  # type: Any
    def __new__(cls, *args): ...
    def __init__(self, *args) -> None: ...
    def __reduce__(self): ...
    def union(self, d): ...

class Properties:
    def __init__(self, data) -> None: ...
    def __len__(self): ...
    def __iter__(self): ...
    def __add__(self, other): ...
    def __setitem__(self, key, object): ...
    def __getitem__(self, key): ...
    def __delitem__(self, key): ...
    def __setattr__(self, key, obj): ...
    def __getattr__(self, key): ...
    def __contains__(self, key): ...
    def as_immutable(self): ...
    def update(self, value): ...
    def get(self, key, default: Optional[Any] = ...): ...
    def keys(self): ...
    def values(self): ...
    def items(self): ...
    def has_key(self, key): ...
    def clear(self): ...

class OrderedProperties(Properties):
    def __init__(self) -> None: ...

class ImmutableProperties(ImmutableContainer, Properties): ...

class OrderedDict(dict):
    def __reduce__(self): ...
    def __init__(self, ____sequence: Optional[Any] = ..., **kwargs) -> None: ...
    def clear(self): ...
    def copy(self): ...
    def __copy__(self): ...
    def sort(self, *arg, **kw): ...
    def update(self, ____sequence: Optional[Any] = ..., **kwargs): ...
    def setdefault(self, key, value): ...
    def __iter__(self): ...
    def keys(self): ...
    def values(self): ...
    def items(self): ...
    def itervalues(self): ...
    def iterkeys(self): ...
    def iteritems(self): ...
    def __setitem__(self, key, object): ...
    def __delitem__(self, key): ...
    def pop(self, key, *default): ...
    def popitem(self): ...

class OrderedSet(set):
    def __init__(self, d: Optional[Any] = ...) -> None: ...
    def add(self, element): ...
    def remove(self, element): ...
    def insert(self, pos, element): ...
    def discard(self, element): ...
    def clear(self): ...
    def __getitem__(self, key): ...
    def __iter__(self): ...
    def __add__(self, other): ...
    def update(self, iterable): ...
    __ior__ = ...  # type: Any
    def union(self, other): ...
    __or__ = ...  # type: Any
    def intersection(self, other): ...
    __and__ = ...  # type: Any
    def symmetric_difference(self, other): ...
    __xor__ = ...  # type: Any
    def difference(self, other): ...
    __sub__ = ...  # type: Any
    def intersection_update(self, other): ...
    __iand__ = ...  # type: Any
    def symmetric_difference_update(self, other): ...
    __ixor__ = ...  # type: Any
    def difference_update(self, other): ...
    __isub__ = ...  # type: Any

class IdentitySet:
    def __init__(self, iterable: Optional[Any] = ...) -> None: ...
    def add(self, value): ...
    def __contains__(self, value): ...
    def remove(self, value): ...
    def discard(self, value): ...
    def pop(self): ...
    def clear(self): ...
    def __cmp__(self, other): ...
    def __eq__(self, other): ...
    def __ne__(self, other): ...
    def issubset(self, iterable): ...
    def __le__(self, other): ...
    def __lt__(self, other): ...
    def issuperset(self, iterable): ...
    def __ge__(self, other): ...
    def __gt__(self, other): ...
    def union(self, iterable): ...
    def __or__(self, other): ...
    def update(self, iterable): ...
    def __ior__(self, other): ...
    def difference(self, iterable): ...
    def __sub__(self, other): ...
    def difference_update(self, iterable): ...
    def __isub__(self, other): ...
    def intersection(self, iterable): ...
    def __and__(self, other): ...
    def intersection_update(self, iterable): ...
    def __iand__(self, other): ...
    def symmetric_difference(self, iterable): ...
    def __xor__(self, other): ...
    def symmetric_difference_update(self, iterable): ...
    def __ixor__(self, other): ...
    def copy(self): ...
    __copy__ = ...  # type: Any
    def __len__(self): ...
    def __iter__(self): ...
    def __hash__(self): ...

class WeakSequence:
    def __init__(self, __elements: Any = ...) -> None: ...
    def append(self, item): ...
    def __len__(self): ...
    def __iter__(self): ...
    def __getitem__(self, index): ...

class OrderedIdentitySet(IdentitySet):
    class _working_set(OrderedSet):
        __sa_hash_exempt__ = ...  # type: bool
    def __init__(self, iterable: Optional[Any] = ...) -> None: ...

class PopulateDict(dict):
    creator = ...  # type: Any
    def __init__(self, creator) -> None: ...
    def __missing__(self, key): ...

column_set = set
column_dict = dict
ordered_column_set = OrderedSet
populate_column_dict = PopulateDict

def unique_list(seq, hashfunc: Optional[Any] = ...): ...

class UniqueAppender:
    data = ...  # type: Any
    def __init__(self, data, via: Optional[Any] = ...) -> None: ...
    def append(self, item): ...
    def __iter__(self): ...

def coerce_generator_arg(arg): ...
def to_list(x, default: Optional[Any] = ...): ...
def has_intersection(set_, iterable): ...
def to_set(x): ...
def to_column_set(x): ...
def update_copy(d, _new: Optional[Any] = ..., **kw): ...
def flatten_iterator(x): ...

class LRUCache(dict):
    capacity = ...  # type: Any
    threshold = ...  # type: Any
    def __init__(self, capacity: int = ..., threshold: float = ...) -> None: ...
    def get(self, key, default: Optional[Any] = ...): ...
    def __getitem__(self, key): ...
    def values(self): ...
    def setdefault(self, key, value): ...
    def __setitem__(self, key, value): ...

def lightweight_named_tuple(name, fields): ...

class ScopedRegistry:
    createfunc = ...  # type: Any
    scopefunc = ...  # type: Any
    registry = ...  # type: Any
    def __init__(self, createfunc, scopefunc) -> None: ...
    def __call__(self): ...
    def has(self): ...
    def set(self, obj): ...
    def clear(self): ...

class ThreadLocalRegistry(ScopedRegistry):
    createfunc = ...  # type: Any
    registry = ...  # type: Any
    def __init__(self, createfunc) -> None: ...
    def __call__(self): ...
    def has(self): ...
    def set(self, obj): ...
    def clear(self): ...
