# Stubs for sqlalchemy.engine.base (Python 3.6)
#
# NOTE: This dynamically typed stub was automatically generated by stubgen.

from typing import Any, Optional
from sqlalchemy import log
from ..sql import util as sql_util
from ..sql import schema as schema
from .interfaces import Connectable as Connectable, ExceptionContext as ExceptionContext

class Connection(Connectable):
    schema_for_object = ...  # type: Any
    engine = ...  # type: Any
    dialect = ...  # type: Any
    should_close_with_result = ...  # type: bool
    dispatch = ...  # type: Any
    def __init__(self, engine, connection: Optional[Any] = ..., close_with_result: bool = ..., _branch_from: Optional[Any] = ..., _execution_options: Optional[Any] = ..., _dispatch: Optional[Any] = ..., _has_events: Optional[Any] = ...) -> None: ...
    def __enter__(self): ...
    def __exit__(self, type, value, traceback): ...
    def execution_options(self, **opt): ...
    @property
    def closed(self): ...
    @property
    def invalidated(self): ...
    @property
    def connection(self): ...
    def get_isolation_level(self): ...
    @property
    def default_isolation_level(self): ...
    @property
    def info(self): ...
    def connect(self): ...
    def contextual_connect(self, **kwargs): ...
    def invalidate(self, exception: Optional[Any] = ...): ...
    def detach(self): ...
    def begin(self): ...
    def begin_nested(self): ...
    def begin_twophase(self, xid: Optional[Any] = ...): ...
    def recover_twophase(self): ...
    def rollback_prepared(self, xid, recover: bool = ...): ...
    def commit_prepared(self, xid, recover: bool = ...): ...
    def in_transaction(self): ...
    def close(self): ...
    def scalar(self, object, *multiparams, **params): ...
    def execute(self, object, *multiparams, **params): ...
    def transaction(self, callable_, *args, **kwargs): ...
    def run_callable(self, callable_, *args, **kwargs): ...

class ExceptionContextImpl(ExceptionContext):
    engine = ...  # type: Any
    connection = ...  # type: Any
    sqlalchemy_exception = ...  # type: Any
    original_exception = ...  # type: Any
    execution_context = ...  # type: Any
    statement = ...  # type: Any
    parameters = ...  # type: Any
    is_disconnect = ...  # type: Any
    invalidate_pool_on_disconnect = ...  # type: Any
    def __init__(self, exception, sqlalchemy_exception, engine, connection, cursor, statement, parameters, context, is_disconnect, invalidate_pool_on_disconnect) -> None: ...

class Transaction:
    connection = ...  # type: Any
    is_active = ...  # type: bool
    def __init__(self, connection, parent) -> None: ...
    def close(self): ...
    def rollback(self): ...
    def commit(self): ...
    def __enter__(self): ...
    def __exit__(self, type, value, traceback): ...

class RootTransaction(Transaction):
    def __init__(self, connection) -> None: ...

class NestedTransaction(Transaction):
    def __init__(self, connection, parent) -> None: ...

class TwoPhaseTransaction(Transaction):
    xid = ...  # type: Any
    def __init__(self, connection, xid) -> None: ...
    def prepare(self): ...

class Engine(Connectable, log.Identified):
    schema_for_object = ...  # type: Any
    pool = ...  # type: Any
    url = ...  # type: Any
    dialect = ...  # type: Any
    logging_name = ...  # type: Any
    echo = ...  # type: Any
    engine = ...  # type: Any
    def __init__(self, pool, dialect, url, logging_name: Optional[Any] = ..., echo: Optional[Any] = ..., proxy: Optional[Any] = ..., execution_options: Optional[Any] = ...) -> None: ...
    def update_execution_options(self, **opt): ...
    def execution_options(self, **opt): ...
    @property
    def name(self): ...
    @property
    def driver(self): ...
    def dispose(self): ...
    class _trans_ctx:
        conn = ...  # type: Any
        transaction = ...  # type: Any
        close_with_result = ...  # type: Any
        def __init__(self, conn, transaction, close_with_result) -> None: ...
        def __enter__(self): ...
        def __exit__(self, type, value, traceback): ...
    def begin(self, close_with_result: bool = ...): ...
    def transaction(self, callable_, *args, **kwargs): ...
    def run_callable(self, callable_, *args, **kwargs): ...
    def execute(self, statement, *multiparams, **params): ...
    def scalar(self, statement, *multiparams, **params): ...
    def connect(self, **kwargs): ...
    def contextual_connect(self, close_with_result: bool = ..., **kwargs): ...
    def table_names(self, schema: Optional[Any] = ..., connection: Optional[Any] = ...): ...
    def has_table(self, table_name, schema: Optional[Any] = ...): ...
    def raw_connection(self, _connection: Optional[Any] = ...): ...

class OptionEngine(Engine):
    url = ...  # type: Any
    dialect = ...  # type: Any
    logging_name = ...  # type: Any
    echo = ...  # type: Any
    dispatch = ...  # type: Any
    def __init__(self, proxied, execution_options) -> None: ...
    pool = ...  # type: Any
