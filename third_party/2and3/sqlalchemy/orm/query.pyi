# Stubs for sqlalchemy.orm.query (Python 3.6)
#
# NOTE: This dynamically typed stub was automatically generated by stubgen.

from typing import Any, Optional
import interfaces
from . import exc as orm_exc
from .base import InspectionAttr
from .util import aliased as aliased
from .util import join as orm_join
from .. import exc as sa_exc
from ..sql import util as sql_util
from ..sql.selectable import ForUpdateArg

class Query:
    session = ...  # type: Any
    def __init__(self, entities, session: Optional[Any] = ...) -> None: ...
    @property
    def statement(self): ...
    def subquery(self, name: Optional[Any] = ..., with_labels: bool = ..., reduce_columns: bool = ...): ...
    def cte(self, name: Optional[Any] = ..., recursive: bool = ...): ...
    def label(self, name): ...
    def as_scalar(self): ...
    @property
    def selectable(self): ...
    def __clause_element__(self): ...
    def enable_eagerloads(self, value): ...
    def with_labels(self): ...
    def enable_assertions(self, value): ...
    @property
    def whereclause(self): ...
    def with_polymorphic(self, cls_or_mappers, selectable: Optional[Any] = ..., polymorphic_on: Optional[Any] = ...): ...
    def yield_per(self, count): ...
    def get(self, ident): ...
    def correlate(self, *args): ...
    def autoflush(self, setting): ...
    def populate_existing(self): ...
    def with_parent(self, instance, property: Optional[Any] = ...): ...
    def add_entity(self, entity, alias: Optional[Any] = ...): ...
    def with_session(self, session): ...
    def from_self(self, *entities): ...
    def values(self, *columns): ...
    def value(self, column): ...
    def with_entities(self, *entities): ...
    def add_columns(self, *column): ...
    def add_column(self, column): ...
    def options(self, *args): ...
    def with_transformation(self, fn): ...
    def with_hint(self, selectable, text, dialect_name: str = ...): ...
    def with_statement_hint(self, text, dialect_name: str = ...): ...
    def execution_options(self, **kwargs): ...
    def with_lockmode(self, mode): ...
    def with_for_update(self, read: bool = ..., nowait: bool = ..., of: Optional[Any] = ..., skip_locked: bool = ..., key_share: bool = ...): ...
    def params(self, *args, **kwargs): ...
    def filter(self, *criterion): ...
    def filter_by(self, **kwargs): ...
    def order_by(self, *criterion): ...
    def group_by(self, *criterion): ...
    def having(self, criterion): ...
    def union(self, *q): ...
    def union_all(self, *q): ...
    def intersect(self, *q): ...
    def intersect_all(self, *q): ...
    def except_(self, *q): ...
    def except_all(self, *q): ...
    def join(self, *props, **kwargs): ...
    def outerjoin(self, *props, **kwargs): ...
    def reset_joinpoint(self): ...
    def select_from(self, *from_obj): ...
    def select_entity_from(self, from_obj): ...
    def __getitem__(self, item): ...
    def slice(self, start, stop): ...
    def limit(self, limit): ...
    def offset(self, offset): ...
    def distinct(self, *criterion): ...
    def prefix_with(self, *prefixes): ...
    def suffix_with(self, *suffixes): ...
    def all(self): ...
    def from_statement(self, statement): ...
    def first(self): ...
    def one_or_none(self): ...
    def one(self): ...
    def scalar(self): ...
    def __iter__(self): ...
    @property
    def column_descriptions(self): ...
    def instances(self, cursor, __context: Optional[Any] = ...): ...
    def merge_result(self, iterator, load: bool = ...): ...
    def exists(self): ...
    def count(self): ...
    def delete(self, synchronize_session: str = ...): ...
    def update(self, values, synchronize_session: str = ..., update_args: Optional[Any] = ...): ...

class LockmodeArg(ForUpdateArg):
    @classmethod
    def parse_legacy_query(self, mode): ...

class _QueryEntity:
    def __new__(cls, *args, **kwargs): ...

class _MapperEntity(_QueryEntity):
    entities = ...  # type: Any
    expr = ...  # type: Any
    def __init__(self, query, entity) -> None: ...
    supports_single_entity = ...  # type: bool
    use_id_for_hash = ...  # type: bool
    mapper = ...  # type: Any
    aliased_adapter = ...  # type: Any
    selectable = ...  # type: Any
    is_aliased_class = ...  # type: Any
    entity_zero = ...  # type: Any
    path = ...  # type: Any
    def setup_entity(self, ext_info, aliased_adapter): ...
    def set_with_polymorphic(self, query, cls_or_mappers, selectable, polymorphic_on): ...
    @property
    def type(self): ...
    @property
    def entity_zero_or_selectable(self): ...
    def corresponds_to(self, entity): ...
    def adapt_to_selectable(self, query, sel): ...
    def row_processor(self, query, context, result): ...
    def setup_context(self, query, context): ...

class Bundle(InspectionAttr):
    single_entity = ...  # type: bool
    is_clause_element = ...  # type: bool
    is_mapper = ...  # type: bool
    is_aliased_class = ...  # type: bool
    name = ...  # type: Any
    exprs = ...  # type: Any
    c = ...  # type: Any
    def __init__(self, name, *exprs, **kw) -> None: ...
    columns = ...  # type: Any
    def __clause_element__(self): ...
    @property
    def clauses(self): ...
    def label(self, name): ...
    def create_row_processor(self, query, procs, labels): ...

class _BundleEntity(_QueryEntity):
    use_id_for_hash = ...  # type: bool
    bundle = ...  # type: Any
    type = ...  # type: Any
    supports_single_entity = ...  # type: Any
    def __init__(self, query, bundle, setup_entities: bool = ...) -> None: ...
    @property
    def entities(self): ...
    @property
    def entity_zero(self): ...
    def corresponds_to(self, entity): ...
    @property
    def entity_zero_or_selectable(self): ...
    def adapt_to_selectable(self, query, sel): ...
    def setup_entity(self, ext_info, aliased_adapter): ...
    def setup_context(self, query, context): ...
    def row_processor(self, query, context, result): ...

class _ColumnEntity(_QueryEntity):
    expr = ...  # type: Any
    namespace = ...  # type: Any
    type = ...  # type: Any
    use_id_for_hash = ...  # type: Any
    column = ...  # type: Any
    froms = ...  # type: Any
    actual_froms = ...  # type: Any
    entity_zero = ...  # type: Any
    entities = ...  # type: Any
    mapper = ...  # type: Any
    def __init__(self, query, column, namespace: Optional[Any] = ...) -> None: ...
    supports_single_entity = ...  # type: bool
    @property
    def entity_zero_or_selectable(self): ...
    def adapt_to_selectable(self, query, sel): ...
    selectable = ...  # type: Any
    def setup_entity(self, ext_info, aliased_adapter): ...
    def corresponds_to(self, entity): ...
    def row_processor(self, query, context, result): ...
    def setup_context(self, query, context): ...

class QueryContext:
    statement = ...  # type: Any
    from_clause = ...  # type: Any
    whereclause = ...  # type: Any
    order_by = ...  # type: Any
    multi_row_eager_loaders = ...  # type: bool
    adapter = ...  # type: Any
    froms = ...  # type: Any
    for_update = ...  # type: Any
    query = ...  # type: Any
    session = ...  # type: Any
    autoflush = ...  # type: Any
    populate_existing = ...  # type: Any
    invoke_all_eagers = ...  # type: Any
    version_check = ...  # type: Any
    refresh_state = ...  # type: Any
    primary_columns = ...  # type: Any
    secondary_columns = ...  # type: Any
    eager_order_by = ...  # type: Any
    eager_joins = ...  # type: Any
    create_eager_joins = ...  # type: Any
    propagate_options = ...  # type: Any
    attributes = ...  # type: Any
    def __init__(self, query) -> None: ...

class AliasOption(interfaces.MapperOption):
    alias = ...  # type: Any
    def __init__(self, alias) -> None: ...
    def process_query(self, query): ...
