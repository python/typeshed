# Stubs for sqlalchemy.dialects.postgresql.pg8000 (Python 3.6)
#
# NOTE: This dynamically typed stub was automatically generated by stubgen.

from typing import Any, Optional
from ... import types as sqltypes
from .base import PGDialect as PGDialect, PGCompiler as PGCompiler, PGIdentifierPreparer as PGIdentifierPreparer, PGExecutionContext as PGExecutionContext
from sqlalchemy.dialects.postgresql.json import JSON

class _PGNumeric(sqltypes.Numeric):
    def result_processor(self, dialect, coltype): ...

class _PGNumericNoBind(_PGNumeric):
    def bind_processor(self, dialect): ...

class _PGJSON(JSON):
    def result_processor(self, dialect, coltype): ...

class PGExecutionContext_pg8000(PGExecutionContext): ...

class PGCompiler_pg8000(PGCompiler):
    def visit_mod_binary(self, binary, operator, **kw): ...
    def post_process_text(self, text): ...

class PGIdentifierPreparer_pg8000(PGIdentifierPreparer): ...

class PGDialect_pg8000(PGDialect):
    driver = ...  # type: str
    supports_unicode_statements = ...  # type: bool
    supports_unicode_binds = ...  # type: bool
    default_paramstyle = ...  # type: str
    supports_sane_multi_rowcount = ...  # type: bool
    execution_ctx_cls = ...  # type: Any
    statement_compiler = ...  # type: Any
    preparer = ...  # type: Any
    description_encoding = ...  # type: str
    colspecs = ...  # type: Any
    client_encoding = ...  # type: Any
    def __init__(self, client_encoding: Optional[Any] = ..., **kwargs) -> None: ...
    def initialize(self, connection): ...
    @classmethod
    def dbapi(cls): ...
    def create_connect_args(self, url): ...
    def is_disconnect(self, e, connection, cursor): ...
    def set_isolation_level(self, connection, level): ...
    def set_client_encoding(self, connection, client_encoding): ...
    def do_begin_twophase(self, connection, xid): ...
    def do_prepare_twophase(self, connection, xid): ...
    def do_rollback_twophase(self, connection, xid, is_prepared: bool = ..., recover: bool = ...): ...
    def do_commit_twophase(self, connection, xid, is_prepared: bool = ..., recover: bool = ...): ...
    def do_recover_twophase(self, connection): ...
    def on_connect(self): ...

dialect = ...  # type: Any
