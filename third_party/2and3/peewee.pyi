import datetime
import decimal
import enum
import re
import threading
import uuid
from typing import (
    Any,
    AnyStr,
    Callable,
    ClassVar,
    Container,
    ContextManager,
    Dict,
    Generic,
    Hashable,
    Iterable,
    Iterator,
    List,
    Mapping,
    MutableMapping,
    MutableSet,
    NamedTuple,
    NoReturn,
    Optional,
    Sequence,
    Set,
    Text,
    Tuple,
    Type,
    TypeVar,
    Union,
    overload,
)
from typing_extensions import Literal, Protocol

T = TypeVar("T")
_TModel = TypeVar("_TModel", bound="Model")
_TConvFunc = Callable[[Any], Any]
_TFunc = TypeVar("_TFunc", bound=Callable)
_TClass = TypeVar("_TClass", bound=type)
_TContextClass = TypeVar("_TContextClass", bound="Context")
_TField = TypeVar("_TField", bound="Field")
_TNode = TypeVar("_TNode", bound="Node")

__version__: str
__all__: List[str]

class __ICursor(Protocol):
    description: Tuple[str, Any, Any, Any, Any, Any, Any]
    rowcount: int
    def fetchone(self) -> Optional[tuple]: ...
    def fetchmany(self, size: int = ...) -> Iterable[tuple]: ...
    def fetchall(self) -> Iterable[tuple]: ...

class __IConnection(Protocol):
    def cursor(self) -> __ICursor: ...
    def execute(self, sql: str, *args: object) -> __ICursor: ...
    def commit(self) -> Any: ...
    def rollback(self) -> Any: ...

class __IAggregate(Protocol):
    def step(self, *value: object) -> None: ...
    def finalize(self) -> Any: ...

class __ITableFunction(Protocol):
    columns: Sequence[str]
    params: Sequence[str]
    name: str
    print_tracebacks: bool
    def initialize(self, **parameters: object) -> None: ...
    def iterate(self, idx: int) -> tuple: ...
    @classmethod
    def register(cls, conn: __IConnection) -> None: ...

def _sqlite_date_part(lookup_type: str, datetime_string: str) -> Optional[str]: ...
def _sqlite_date_trunc(lookup_type: str, datetime_string: str) -> Optional[str]: ...

class attrdict(dict):
    def __getattr__(self, attr: str) -> Any: ...
    def __setattr__(self, attr: str, value: object) -> None: ...
    def __iadd__(self, rhs: Mapping[str, object]) -> attrdict: ...
    def __add__(self, rhs: Mapping[str, object]) -> Mapping[str, object]: ...

class _TSentinel(enum.Enum): ...

# HACK (dargueta): This is a regular object but we need it to annotate the sentinel in
# type arguments.
SENTINEL: _TSentinel

OP: attrdict

DJANGO_MAP: attrdict

FIELD: attrdict

JOIN: attrdict

ROW: attrdict

SCOPE_NORMAL: int
SCOPE_SOURCE: int
SCOPE_VALUES: int
SCOPE_CTE: int
SCOPE_COLUMN: int

CSQ_PARENTHESES_NEVER: int
CSQ_PARENTHESES_ALWAYS: int
CSQ_PARENTHESES_UNNESTED: int

SNAKE_CASE_STEP1: re.Pattern
SNAKE_CASE_STEP2: re.Pattern

MODEL_BASE: str

# TODO (dargueta)
class _callable_context_manager:
    def __call__(self, fn: _TFunc) -> _TFunc: ...

class Proxy:
    obj: Any
    def initialize(self, obj: object) -> None: ...
    def attach_callback(self, callback: _TConvFunc) -> _TConvFunc: ...
    @staticmethod  # This is technically inaccurate but that's how it's used
    def passthrough(method: _TFunc) -> _TFunc: ...
    def __enter__(self) -> Any: ...
    def __exit__(self, exc_type, exc_val, exc_tb) -> Any: ...
    def __getattr__(self, attr: str) -> Any: ...
    def __setattr__(self, attr: str, value: object) -> None: ...

class DatabaseProxy(Proxy):
    def connection_context(self) -> ConnectionContext: ...
    def atomic(self, *args: object, **kwargs: object) -> _atomic: ...
    def manual_commit(self) -> _manual: ...
    def transaction(self, *args: object, **kwargs: object) -> _transaction: ...
    def savepoint(self) -> _savepoint: ...

class ModelDescriptor: ...

# SQL Generation.

class AliasManager:
    @property
    def mapping(self) -> MutableMapping[Source, str]: ...
    def add(self, source: Source) -> str: ...
    def get(self, source: Source, any_depth: bool = ...) -> str: ...
    def __getitem__(self, source: Source) -> str: ...
    def __setitem__(self, source: Source, alias: str) -> None: ...
    def push(self) -> None: ...
    def pop(self) -> None: ...

class __State(NamedTuple):
    scope: int
    parentheses: bool
    # From the source code we know this to be a Dict and not just a MutableMapping.
    settings: Dict[str, Any]

class State(__State):
    subquery: object  # TODO (dargueta)
    def __new__(cls, scope: int = ..., parentheses: bool = ..., **kwargs: object) -> State: ...
    def __call__(self, scope: Optional[int] = ..., parentheses: Optional[int] = ..., **kwargs: object) -> State: ...
    def __getattr__(self, attr_name: str) -> Any: ...

class Context:
    stack: List[State]
    alias_manager: AliasManager
    state: State
    def __init__(self, **settings: object) -> None: ...
    def as_new(self) -> Context: ...
    def column_sort_key(self, item: Sequence[Union[ColumnBase, Source]]) -> Tuple[str, ...]: ...
    @property
    def scope(self) -> int: ...
    @property
    def parentheses(self) -> bool: ...
    @property
    def subquery(self) -> Any: ...  # TODO (dargueta): Figure out type of "self.state.subquery"
    def __call__(self, **overrides: object) -> Context: ...
    def scope_normal(self) -> ContextManager[Context]: ...
    def scope_source(self) -> ContextManager[Context]: ...
    def scope_values(self) -> ContextManager[Context]: ...
    def scope_cte(self) -> ContextManager[Context]: ...
    def scope_column(self) -> ContextManager[Context]: ...
    def __enter__(self) -> Context: ...
    def __exit__(self, exc_type: Type[Exception], exc_val: Exception, exc_tb: object) -> None: ...
    # @contextmanager
    def push_alias(self) -> Iterator[None]: ...
    # TODO (dargueta): Is this right?
    def sql(self, obj: object) -> Context: ...
    def literal(self, keyword: str) -> Context: ...
    def value(self, value: object, converter: Optional[_TConvFunc] = ..., add_param: bool = ...) -> Context: ...
    def __sql__(self, ctx: Context) -> Context: ...
    def parse(self, node: Node) -> Tuple[str, Optional[tuple]]: ...
    def query(self) -> Tuple[str, Optional[tuple]]: ...

def query_to_string(query: Node) -> str: ...

class Node:
    def clone(self) -> Node: ...
    def __sql__(self, ctx: Context) -> Context: ...
    # FIXME (dargueta): Is there a way to make this a proper decorator?
    @staticmethod
    def copy(method: _TFunc) -> _TFunc: ...
    def coerce(self, _coerce: bool = ...) -> Node: ...
    def is_alias(self) -> bool: ...
    def unwrap(self) -> Node: ...

class ColumnFactory:
    node: Node
    def __init__(self, node: Node): ...
    def __getattr__(self, attr: str) -> Column: ...

class _DynamicColumn:
    @overload
    def __get__(self, instance: None, instance_type: type) -> _DynamicColumn: ...
    @overload
    def __get__(self, instance: T, instance_type: Type[T]) -> ColumnFactory: ...

class _ExplicitColumn:
    @overload
    def __get__(self, instance: None, instance_type: type) -> _ExplicitColumn: ...
    @overload
    def __get__(self, instance: T, instance_type: Type[T]) -> NoReturn: ...

class _SupportsAlias(Protocol):
    def alias(self: T, name: str) -> T: ...

class Source(_SupportsAlias, Node):
    c: ClassVar[_DynamicColumn]
    def __init__(self, alias: Optional[str] = ...): ...
    def select(self, *columns: Field) -> Select: ...
    def join(self, dest, join_type: int = ..., on: Optional[Expression] = ...) -> Join: ...
    def left_outer_join(self, dest, on: Optional[Expression] = ...) -> Join: ...
    def cte(self, name: str, recursive: bool = ..., columns=..., materialized=...) -> CTE: ...  # incomplete
    def get_sort_key(self, ctx) -> Tuple[str, ...]: ...
    def apply_alias(self, ctx: Context) -> Context: ...
    def apply_column(self, ctx: Context) -> Context: ...

class _HashableSource(_SupportsAlias):
    def __init__(self, *args: object, **kwargs: object): ...
    def __hash__(self) -> int: ...
    # The overrides here are unfortunately a necessary evil. The __eq__/__ne__ methods
    # return different types depending on the type of the argument, and both differ
    # from `object`'s signature.
    @overload  # type: ignore
    def __eq__(self, other: _HashableSource) -> bool: ...  # type: ignore
    @overload
    def __eq__(self, other: object) -> Expression: ...  # type: ignore
    @overload  # type: ignore
    def __ne__(self, other: _HashableSource) -> bool: ...  # type: ignore
    @overload
    def __ne__(self, other: object) -> Expression: ...  # type: ignore
    def __lt__(self, other: object) -> Expression: ...
    def __le__(self, other: object) -> Expression: ...
    def __gt__(self, other: object) -> Expression: ...
    def __ge__(self, other: object) -> Expression: ...

def __join__(join_type: int = ..., inverted: bool = ...) -> Callable[[Any, Any], Join]: ...

class BaseTable(Source):
    def __and__(self, other: object) -> Join: ...
    def __add__(self, other: object) -> Join: ...
    def __sub__(self, other: object) -> Join: ...
    def __or__(self, other: object) -> Join: ...
    def __mul__(self, other: object) -> Join: ...
    def __rand__(self, other: object) -> Join: ...
    def __radd__(self, other: object) -> Join: ...
    def __rsub__(self, other: object) -> Join: ...
    def __ror__(self, other: object) -> Join: ...
    def __rmul__(self, other: object) -> Join: ...

class _BoundTableContext(_callable_context_manager):
    table: Table
    database: Database
    def __init__(self, table: Table, database: Database): ...
    def __enter__(self) -> Table: ...
    def __exit__(self, exc_type: Type[Exception], exc_val: Exception, exc_tb: object) -> None: ...

class Table(_HashableSource, BaseTable):
    __name__: str
    c: _ExplicitColumn
    primary_key: Optional[Union[Field, CompositeKey]]
    def __init__(
        self,
        name: str,
        columns: Optional[Iterable[str]] = ...,
        primary_key: Optional[Union[Field, CompositeKey]] = ...,
        schema: Optional[str] = ...,
        alias: Optional[str] = ...,
        _model: Optional[Type[Model]] = ...,
        _database: Optional[Database] = ...,
    ): ...
    def clone(self) -> Table: ...
    def bind(self, database: Optional[Database] = ...) -> Table: ...
    def bind_ctx(self, database: Optional[Database] = ...) -> _BoundTableContext: ...
    def select(self, *columns: Column) -> Select: ...
    @overload
    def insert(self, insert: Optional[Select], columns: Sequence[Union[str, Field, Column]]) -> Insert: ...
    @overload
    def insert(self, insert: Union[Mapping[str, object], Iterable[Mapping[str, object]]], **kwargs: object): ...
    @overload
    def replace(self, insert: Optional[Select], columns: Sequence[Union[str, Field, Column]]) -> Insert: ...
    @overload
    def replace(self, insert: Union[Mapping[str, object], Iterable[Mapping[str, object]]], **kwargs: object): ...
    def update(self, update: Optional[Mapping[str, object]] = ..., **kwargs: object) -> Update: ...
    def delete(self) -> Delete: ...
    def __sql__(self, ctx: Context) -> Context: ...

class Join(BaseTable):
    lhs: Any  # TODO (dargueta)
    rhs: Any  # TODO (dargueta)
    join_type: int
    def __init__(self, lhs, rhs, join_type: int = ..., on: Optional[Expression] = ..., alias: Optional[str] = ...): ...
    def on(self, predicate: Expression) -> Join: ...
    def __sql__(self, ctx: Context) -> Context: ...

class ValuesList(_HashableSource, BaseTable):
    def __init__(self, values, columns=..., alias: Optional[str] = ...): ...  # incomplete
    # FIXME (dargueta) `names` might be wrong
    def columns(self, *names: str) -> ValuesList: ...
    def __sql__(self, ctx: Context) -> Context: ...

class CTE(_HashableSource, Source):
    def __init__(
        self,
        name: str,
        query: Select,
        recursive: bool = ...,
        columns: Optional[Iterable[Union[Column, Field, str]]] = ...,
        materialized: bool = ...,
    ): ...
    # TODO (dargueta): Is `columns` just for column names?
    def select_from(self, *columns: Union[Column, Field]) -> Select: ...
    def _get_hash(self) -> int: ...
    def union_all(self, rhs) -> CTE: ...
    __add__ = union_all
    def union(self, rhs: SelectQuery) -> CTE: ...
    __or__ = union
    def __sql__(self, ctx: Context) -> Context: ...

class ColumnBase(Node):
    _converter: Optional[_TConvFunc]
    def converter(self, converter: Optional[_TConvFunc] = ...) -> ColumnBase: ...
    @overload
    def alias(self, alias: None) -> ColumnBase: ...
    @overload
    def alias(self, alias: str) -> Alias: ...
    def unalias(self) -> ColumnBase: ...
    def cast(self, as_type: str) -> Cast: ...
    def asc(self, collation: Optional[str] = ..., nulls: Optional[str] = ...) -> _SupportsSQLOrdering: ...
    __pos__ = asc
    def desc(self, collation: Optional[str] = ..., nulls: Optional[str] = ...) -> _SupportsSQLOrdering: ...
    __neg__ = desc
    # TODO (dargueta): This always returns Negated but subclasses can return something else
    def __invert__(self) -> WrappedNode: ...
    def __and__(self, other: object) -> Expression: ...
    def __or__(self, other: object) -> Expression: ...
    def __add__(self, other: object) -> Expression: ...
    def __sub__(self, other: object) -> Expression: ...
    def __mul__(self, other: object) -> Expression: ...
    def __div__(self, other: object) -> Expression: ...
    def __truediv__(self, other: object) -> Expression: ...
    def __xor__(self, other: object) -> Expression: ...
    def __radd__(self, other: object) -> Expression: ...
    def __rsub__(self, other: object) -> Expression: ...
    def __rmul__(self, other: object) -> Expression: ...
    def __rdiv__(self, other: object) -> Expression: ...
    def __rtruediv__(self, other: object) -> Expression: ...
    def __rand__(self, other: object) -> Expression: ...
    def __ror__(self, other: object) -> Expression: ...
    def __rxor__(self, other: object) -> Expression: ...
    def __eq__(self, rhs: object) -> Expression: ...
    def __ne__(self, rhs: object) -> Expression: ...
    def __lt__(self, other: object) -> Expression: ...
    def __le__(self, other: object) -> Expression: ...
    def __gt__(self, other: object) -> Expression: ...
    def __ge__(self, other: object) -> Expression: ...
    def __lshift__(self, other: object) -> Expression: ...
    def __rshift__(self, other: object) -> Expression: ...
    def __mod__(self, other: object) -> Expression: ...
    def __pow__(self, other: object) -> Expression: ...
    def bin_and(self, other: object) -> Expression: ...
    def bin_or(self, other: object) -> Expression: ...
    def in_(self, other: object) -> Expression: ...
    def not_in(self, other: object) -> Expression: ...
    def regexp(self, other: object) -> Expression: ...
    def is_null(self, is_null: bool = ...) -> Expression: ...
    def contains(self, rhs: Union[Node, str]) -> Expression: ...
    def startswith(self, rhs: Union[Node, str]) -> Expression: ...
    def endswith(self, rhs: Union[Node, str]) -> Expression: ...
    def between(self, lo: object, hi: object) -> Expression: ...
    def concat(self, rhs: object) -> StringExpression: ...
    def iregexp(self, rhs: object) -> Expression: ...
    def __getitem__(self, item: object) -> Expression: ...
    def distinct(self) -> NodeList: ...
    def collate(self, collation: str) -> NodeList: ...
    def get_sort_key(self, ctx: Context) -> Tuple[str, ...]: ...

class Column(ColumnBase):
    source: Source
    name: str
    def __init__(self, source: Source, name: str): ...
    def get_sort_key(self, ctx: Context) -> Tuple[str, ...]: ...
    def __hash__(self) -> int: ...
    def __sql__(self, ctx: Context) -> Context: ...

class WrappedNode(ColumnBase, Generic[_TNode]):
    node: _TNode
    _coerce: bool
    _converter: Optional[_TConvFunc]
    def __init__(self, node: _TNode): ...
    def is_alias(self) -> bool: ...
    def unwrap(self) -> _TNode: ...

class EntityFactory:
    node: Node
    def __init__(self, node: Node): ...
    def __getattr__(self, attr: str) -> Entity: ...

class _DynamicEntity:
    @overload
    def __get__(self, instance: None, instance_type: type) -> _DynamicEntity: ...
    @overload
    def __get__(self, instance: T, instance_type: Type[T]) -> EntityFactory: ...

class Alias(WrappedNode):
    c: ClassVar[_DynamicEntity]
    def __init__(self, node: Node, alias: str): ...
    def __hash__(self) -> int: ...
    @overload
    def alias(self, alias: None) -> Node: ...
    @overload
    def alias(self, alias: str) -> Alias: ...
    def unalias(self) -> Node: ...
    def is_alias(self) -> bool: ...
    def __sql__(self, ctx: Context) -> Context: ...

class Negated(WrappedNode):
    def __invert__(self) -> Node: ...
    def __sql__(self, ctx: Context) -> Context: ...

class BitwiseMixin:
    def __and__(self, other: object) -> Expression: ...
    def __or__(self, other: object) -> Expression: ...
    def __sub__(self, other: object) -> Expression: ...
    def __invert__(self) -> BitwiseNegated: ...

class BitwiseNegated(BitwiseMixin, WrappedNode):
    def __invert__(self) -> Node: ...
    def __sql__(self, ctx: Context) -> Context: ...

class Value(ColumnBase):
    value: object
    converter: Optional[_TConvFunc]
    multi: bool
    def __init__(self, value: object, converter: Optional[_TConvFunc] = ..., unpack: bool = ...): ...
    def __sql__(self, ctx: Context) -> Context: ...

def AsIs(value: object) -> Value: ...

class Cast(WrappedNode):
    def __init__(self, node: Node, cast: str): ...
    def __sql__(self, ctx: Context) -> Context: ...

class Ordering(WrappedNode):
    direction: str
    collation: Optional[str]
    nulls: Optional[str]
    def __init__(self, node: Node, direction: str, collation: Optional[str] = ..., nulls: Optional[str] = ...): ...
    def collate(self, collation: Optional[str] = ...) -> Ordering: ...
    def __sql__(self, ctx: Context) -> Context: ...

class _SupportsSQLOrdering(Protocol):
    def __call__(node: Node, collation: Optional[str] = ..., nulls: Optional[str] = ...) -> Ordering: ...

def Asc(node: Node, collation: Optional[str] = ..., nulls: Optional[str] = ...) -> Ordering: ...
def Desc(node: Node, collation: Optional[str] = ..., nulls: Optional[str] = ...) -> Ordering: ...

class Expression(ColumnBase):
    lhs: Optional[Union[Node, str]]
    op: int
    rhs: Optional[Union[Node, str]]
    flat: bool
    def __init__(self, lhs: Optional[Union[Node, str]], op: int, rhs: Optional[Union[Node, str]], flat: bool = ...): ...
    def __sql__(self, ctx: Context) -> Context: ...

class StringExpression(Expression):
    def __add__(self, rhs: object) -> StringExpression: ...
    def __radd__(self, lhs: object) -> StringExpression: ...

class Entity(ColumnBase):
    def __init__(self, *path: str): ...
    def __getattr__(self, attr: str) -> Entity: ...
    def get_sort_key(self, ctx: Context) -> Tuple[str, ...]: ...
    def __hash__(self) -> int: ...
    def __sql__(self, ctx: Context) -> Context: ...

class SQL(ColumnBase):
    sql: str
    params: Optional[Mapping[str, object]]
    def __init__(self, sql: str, params: Mapping[str, object] = ...): ...
    def __sql__(self, ctx: Context) -> Context: ...

def Check(constraint: str) -> SQL: ...

class Function(ColumnBase):
    name: str
    arguments: tuple
    def __init__(self, name: str, arguments: tuple, coerce: bool = ..., python_value: Optional[_TConvFunc] = ...): ...
    def __getattr__(self, attr: str) -> Callable[..., Function]: ...
    # TODO (dargueta): `where` is an educated guess
    def filter(self, where: Optional[Expression] = ...) -> Function: ...
    def order_by(self, *ordering: Union[Field, Expression]) -> Function: ...
    def python_value(self, func: Optional[_TConvFunc] = ...) -> Function: ...
    def over(
        self,
        partition_by: Optional[Union[Sequence[Field], Window]] = ...,
        order_by: Optional[Sequence[Union[Field, Expression]]] = ...,
        start: Optional[Union[str, SQL]] = ...,
        end: Optional[Union[str, SQL]] = ...,
        frame_type: Optional[str] = ...,
        window: Optional[Window] = ...,
        exclude: Optional[SQL] = ...,
    ) -> NodeList: ...
    def __sql__(self, ctx: Context) -> Context: ...

fn: Function

class Window(Node):
    CURRENT_ROW: ClassVar[SQL]
    GROUP: ClassVar[SQL]
    TIES: ClassVar[SQL]
    NO_OTHERS: ClassVar[SQL]
    GROUPS: ClassVar[str]
    RANGE: ClassVar[str]
    ROWS: ClassVar[str]
    # Instance variables
    partition_by: Tuple[Union[Field, Expression], ...]
    order_by: Tuple[Union[Field, Expression], ...]
    start: Optional[Union[str, SQL]]
    end: Optional[Union[str, SQL]]
    frame_type: Optional[Any]  # incomplete
    @overload
    def __init__(
        self,
        partition_by: Optional[Union[Sequence[Field], Window]] = ...,
        order_by: Optional[Sequence[Union[Field, Expression]]] = ...,
        start: Optional[Union[str, SQL]] = ...,
        end: None = ...,
        frame_type: Optional[str] = ...,
        extends: Optional[Union[Window, WindowAlias, str]] = ...,
        exclude: Optional[SQL] = ...,
        alias: Optional[str] = ...,
        _inline: bool = ...,
    ): ...
    @overload
    def __init__(
        self,
        partition_by: Optional[Union[Sequence[Field], Window]] = ...,
        order_by: Optional[Sequence[Union[Field, Expression]]] = ...,
        start: Union[str, SQL] = ...,
        end: Union[str, SQL] = ...,
        frame_type: Optional[str] = ...,
        extends: Optional[Union[Window, WindowAlias, str]] = ...,
        exclude: Optional[SQL] = ...,
        alias: Optional[str] = ...,
        _inline: bool = ...,
    ): ...
    def alias(self, alias: Optional[str] = ...) -> Window: ...
    def as_range(self) -> Window: ...
    def as_rows(self) -> Window: ...
    def as_groups(self) -> Window: ...
    def extends(self, window: Optional[Union[Window, WindowAlias, str]] = ...) -> Window: ...
    def exclude(self, frame_exclusion: Optional[Union[str, SQL]] = ...) -> Window: ...
    @staticmethod
    def following(value: Optional[int] = ...) -> SQL: ...
    @staticmethod
    def preceding(value: Optional[int] = ...) -> SQL: ...
    def __sql__(self, ctx: Context) -> Context: ...

class WindowAlias(Node):
    window: Window
    def __init__(self, window: Window): ...
    def alias(self, window_alias: str) -> WindowAlias: ...
    def __sql__(self, ctx: Context) -> Context: ...

class ForUpdate(Node):
    def __init__(
        self,
        expr: Union[Literal[True], str],
        of: Optional[Union[_TModelOrTable, List[_TModelOrTable], Set[_TModelOrTable], Tuple[_TModelOrTable, ...],]] = ...,
        nowait: Optional[bool] = ...,
    ): ...
    def __sql__(self, ctx: Context) -> Context: ...

def Case(predicate: Optional[Node], expression_tuples: Iterable[Tuple[Expression, Any]], default: object = ...) -> NodeList: ...

class NodeList(ColumnBase):
    # TODO (dargueta): Narrow this type
    nodes: Sequence[Any]  # incomplete
    glue: str
    parens: bool
    def __init__(self, nodes: Sequence[Any], glue: str = ..., parens: bool = ...): ...  # incomplete
    def __sql__(self, ctx: Context) -> Context: ...

def CommaNodeList(nodes: Sequence[Any]) -> NodeList: ...  # incomplete
def EnclosedNodeList(nodes: Sequence[Any]) -> NodeList: ...  # incomplete

class _Namespace(Node):
    def __init__(self, name: str): ...
    def __getattr__(self, attr: str) -> NamespaceAttribute: ...
    def __getitem__(self, attr: str) -> NamespaceAttribute: ...

class NamespaceAttribute(ColumnBase):
    def __init__(self, namespace: _Namespace, attribute: str): ...
    def __sql__(self, ctx: Context) -> Context: ...

EXCLUDED: _Namespace

class DQ(ColumnBase):
    query: Dict[str, Any]

    # TODO (dargueta): Narrow this down?
    def __init__(self, **query: object): ...
    def __invert__(self) -> DQ: ...
    def clone(self) -> DQ: ...

class QualifiedNames(WrappedNode):
    def __sql__(self, ctx: Context) -> Context: ...

@overload
def qualify_names(node: Expression) -> Expression: ...
@overload
def qualify_names(node: ColumnBase) -> QualifiedNames: ...
@overload
def qualify_names(node: T) -> T: ...

class OnConflict(Node):
    @overload
    def __init__(
        self,
        action: Optional[str] = ...,
        update: Optional[Mapping[str, object]] = ...,
        preserve: Optional[Union[Field, Iterable[Field]]] = ...,
        where: Optional[Expression] = ...,
        conflict_target: Optional[Union[Field, Sequence[Field]]] = ...,
        conflict_where: None = ...,
        conflict_constraint: Optional[str] = ...,
    ): ...
    @overload
    def __init__(
        self,
        action: Optional[str] = ...,
        update: Optional[Mapping[str, object]] = ...,
        preserve: Optional[Union[Field, Iterable[Field]]] = ...,
        where: Optional[Expression] = ...,
        conflict_target: None = ...,
        conflict_where: Optional[Expression] = ...,
        conflict_constraint: Optional[str] = ...,
    ): ...
    # undocumented
    def get_conflict_statement(self, ctx: Context, query: Query) -> Optional[SQL]: ...
    def get_conflict_update(self, ctx: Context, query: Query) -> NodeList: ...
    def preserve(self, *columns: Column) -> OnConflict: ...
    # Despite the argument name `_data` is documented
    def update(self, _data: Optional[Mapping[str, object]] = ..., **kwargs: object) -> OnConflict: ...
    def where(self, *expressions: Expression) -> OnConflict: ...
    def conflict_target(self, *constraints: Column) -> OnConflict: ...
    def conflict_where(self, *expressions: Expression) -> OnConflict: ...
    def conflict_constraint(self, constraint: str) -> OnConflict: ...

class BaseQuery(Node):
    default_row_type: ClassVar[int]
    def __init__(self, _database: Optional[Database] = ..., **kwargs: object): ...
    def bind(self, database: Optional[Database] = ...) -> BaseQuery: ...
    def clone(self) -> BaseQuery: ...
    def dicts(self, as_dict: bool = ...) -> BaseQuery: ...
    def tuples(self, as_tuple: bool = ...) -> BaseQuery: ...
    def namedtuples(self, as_namedtuple: bool = ...) -> BaseQuery: ...
    def objects(self, constructor: Optional[_TConvFunc] = ...) -> BaseQuery: ...
    def __sql__(self, ctx: Context) -> Context: ...
    def sql(self) -> Tuple[str, Optional[tuple]]: ...
    def execute(self, database: Optional[Database] = ...) -> CursorWrapper: ...
    # TODO (dargueta): `Any` is too loose; list types of the cursor wrappers
    def iterator(self, database: Optional[Database] = ...) -> Iterator[Any]: ...
    def __iter__(self) -> Iterator[Any]: ...
    @overload
    def __getitem__(self, value: int) -> Any: ...
    @overload
    def __getitem__(self, value: slice) -> Sequence[Any]: ...
    def __len__(self) -> int: ...
    def __str__(self) -> str: ...

class RawQuery(BaseQuery):
    # TODO (dargueta): `tuple` may not be 100% accurate, maybe Sequence[object]?
    def __init__(self, sql: Optional[str] = ..., params: Optional[tuple] = ..., **kwargs: object): ...
    def __sql__(self, ctx: Context) -> Context: ...

class Query(BaseQuery):
    # TODO (dargueta): Verify type of order_by
    def __init__(
        self,
        where: Optional[Expression] = ...,
        order_by: Optional[Sequence[Node]] = ...,
        limit: Optional[int] = ...,
        offset: Optional[int] = ...,
        **kwargs: object,
    ): ...
    def with_cte(self, *cte_list: CTE) -> Query: ...
    def where(self, *expressions: Expression) -> Query: ...
    def orwhere(self, *expressions: Expression) -> Query: ...
    def order_by(self, *values: Node) -> Query: ...
    def order_by_extend(self, *values: Node) -> Query: ...
    def limit(self, value: Optional[int] = ...) -> Query: ...
    def offset(self, value: Optional[int] = ...) -> Query: ...
    def paginate(self, page: int, paginate_by: int = ...) -> Query: ...
    def _apply_ordering(self, ctx: Context) -> Context: ...
    def __sql__(self, ctx: Context) -> Context: ...

def __compound_select__(operation: str, inverted: bool = ...) -> Callable[[Any, Any], CompoundSelectQuery]: ...

class SelectQuery(Query):
    def union_all(self, other: object) -> CompoundSelectQuery: ...
    def union(self, other: object) -> CompoundSelectQuery: ...
    def intersect(self, other: object) -> CompoundSelectQuery: ...
    def except_(self, other: object) -> CompoundSelectQuery: ...
    def __add__(self, other: object) -> CompoundSelectQuery: ...
    def __or__(self, other: object) -> CompoundSelectQuery: ...
    def __and__(self, other: object) -> CompoundSelectQuery: ...
    def __sub__(self, other: object) -> CompoundSelectQuery: ...
    def __radd__(self, other: object) -> CompoundSelectQuery: ...
    def __ror__(self, other: object) -> CompoundSelectQuery: ...
    def __rand__(self, other: object) -> CompoundSelectQuery: ...
    def __rsub__(self, other: object) -> CompoundSelectQuery: ...
    def select_from(self, *columns: Field) -> Select: ...

class SelectBase(_HashableSource, Source, SelectQuery):
    @overload
    def peek(self, database: Optional[Database] = ..., n: Literal[1] = ...) -> object: ...
    @overload
    def peek(self, database: Optional[Database] = ..., n: int = ...) -> List[object]: ...
    @overload
    def first(self, database: Optional[Database] = ..., n: Literal[1] = ...) -> object: ...
    @overload
    def first(self, database: Optional[Database] = ..., n: int = ...) -> List[object]: ...
    @overload
    def scalar(self, database: Optional[Database] = ..., as_tuple: Literal[False] = ...) -> object: ...
    @overload
    def scalar(self, database: Optional[Database] = ..., as_tuple: Literal[True] = ...) -> tuple: ...
    def count(self, database: Optional[Database] = ..., clear_limit: bool = ...) -> int: ...
    def exists(self, database: Optional[Database] = ...) -> bool: ...
    def get(self, database: Optional[Database] = ...) -> object: ...

# QUERY IMPLEMENTATIONS.

class CompoundSelectQuery(SelectBase):
    lhs: Any  # TODO (dargueta)
    op: str
    rhs: Any  # TODO (dargueta)
    def __init__(self, lhs: object, op: str, rhs: object): ...
    def exists(self, database: Optional[Database] = ...) -> bool: ...
    def __sql__(self, ctx: Context) -> Context: ...

class Select(SelectBase):
    def __init__(
        self,
        from_list: Optional[Sequence[Union[Column, Field]]] = ...,  # TODO (dargueta): `Field` might be wrong
        columns: Optional[Iterable[Union[Column, Field]]] = ...,  # TODO (dargueta): `Field` might be wrong
        # Docs say this is a "[l]ist of columns or values to group by" so we don't have
        # a whole lot to restrict this to thanks to "or values"
        group_by: Sequence[object] = ...,
        having: Optional[Expression] = ...,
        distinct: Optional[Union[bool, Sequence[Column]]] = ...,
        windows: Optional[Container[Window]] = ...,
        for_update: Optional[Union[bool, str]] = ...,
        for_update_of: Optional[Union[Table, Iterable[Table]]] = ...,
        nowait: Optional[bool] = ...,
        lateral: Optional[bool] = ...,  # undocumented
        **kwargs: object,
    ): ...
    def clone(self) -> Select: ...
    # TODO (dargueta) `Field` might be wrong in this union
    def columns(self, *columns: Union[Column, Field], **kwargs: object) -> Select: ...
    def select(self, *columns: Union[Column, Field], **kwargs: object) -> Select: ...
    def select_extend(self, *columns) -> Select: ...
    # TODO (dargueta): Is `sources` right?
    def from_(self, *sources: Union[Source, Type[Model]]) -> Select: ...
    def join(self, dest: Type[Model], join_type: int = ..., on: Optional[Expression] = ...) -> Select: ...
    def group_by(self, *columns: Union[Table, Field]) -> Select: ...
    def group_by_extend(self, *values: Union[Table, Field]) -> Select: ...
    def having(self, *expressions: Expression) -> Select: ...
    @overload
    def distinct(self, _: bool) -> Select: ...
    @overload
    def distinct(self, *columns: Field) -> Select: ...
    def window(self, *windows: Window) -> Select: ...
    def for_update(
        self, for_update: bool = ..., of: Optional[Union[Table, Iterable[Table]]] = ..., nowait: Optional[bool] = ...
    ) -> Select: ...
    def lateral(self, lateral: bool = ...) -> Select: ...

class _WriteQuery(Query):
    table: Table
    def __init__(self, table: Table, returning: Optional[Iterable[Union[Type[Model], Field]]] = ..., **kwargs: object): ...
    def returning(self, *returning: Union[Type[Model], Field]) -> _WriteQuery: ...
    def apply_returning(self, ctx: Context) -> Context: ...
    def execute_returning(self, database: Database) -> CursorWrapper: ...
    def handle_result(self, database: Database, cursor: __ICursor) -> Union[int, __ICursor]: ...
    def __sql__(self, ctx: Context) -> Context: ...

class Update(_WriteQuery):
    # TODO (dargueta): `update`
    def __init__(self, table: Table, update: Optional[Any] = ..., **kwargs: object): ...
    def from_(self, *sources) -> Update: ...
    def __sql__(self, ctx: Context) -> Context: ...

class Insert(_WriteQuery):
    SIMPLE: ClassVar[int]
    QUERY: ClassVar[int]
    MULTI: ClassVar[int]
    DefaultValuesException: Type[Exception]
    def __init__(
        self,
        table: Table,
        insert: Optional[Union[Mapping[str, object], Iterable[Mapping[str, object]], SelectQuery, SQL]] = ...,
        columns: Optional[Iterable[Union[str, Field]]] = ...,  # FIXME: Might be `Column` not `Field`
        on_conflict: Optional[OnConflict] = ...,
        **kwargs: object,
    ): ...
    def where(self, *expressions: Expression) -> NoReturn: ...
    def on_conflict_ignore(self, ignore: bool = ...) -> Insert: ...
    def on_conflict_replace(self, replace: bool = ...) -> Insert: ...
    def on_conflict(self, *args, **kwargs) -> Insert: ...
    def get_default_data(self) -> Mapping[str, object]: ...
    def get_default_columns(self) -> Optional[List[Field]]: ...
    def __sql__(self, ctx: Context) -> Context: ...
    def handle_result(self, database: Database, cursor: __ICursor) -> Union[__ICursor, int]: ...

class Delete(_WriteQuery):
    def __sql__(self, ctx: Context) -> Context: ...

class Index(Node):
    def __init__(
        self,
        name: str,
        table,
        expressions,
        unique: bool = ...,
        safe: bool = ...,
        where: Optional[Expression] = ...,
        using: Optional[str] = ...,
    ): ...
    def safe(self, _safe: bool = ...) -> Index: ...
    def where(self, *expressions: Expression) -> Index: ...
    def using(self, _using: Optional[str] = ...) -> Index: ...
    def __sql__(self, ctx: Context) -> Context: ...

class ModelIndex(Index):
    def __init__(
        self,
        model: Type[_TModel],
        fields: Iterable[Union[Field, Node, str]],
        unique: bool = ...,
        safe: bool = ...,
        where: Optional[Expression] = ...,
        using: Optional[str] = ...,
        name: Optional[str] = ...,
    ): ...

class PeeweeException(Exception):
    # This attribute only exists if an exception was passed into the constructor.
    # Attempting to access it otherwise will result in an AttributeError.
    orig: Exception
    def __init__(self, *args: object): ...

class ImproperlyConfigured(PeeweeException): ...
class DatabaseError(PeeweeException): ...
class DataError(DatabaseError): ...
class IntegrityError(DatabaseError): ...
class InterfaceError(PeeweeException): ...
class InternalError(DatabaseError): ...
class NotSupportedError(DatabaseError): ...
class OperationalError(DatabaseError): ...
class ProgrammingError(DatabaseError): ...

class ExceptionWrapper:
    exceptions: Mapping[str, Type[Exception]]
    def __init__(self, exceptions: Mapping[str, Type[Exception]]): ...
    def __enter__(self) -> None: ...
    def __exit__(self, exc_type: Type[Exception], exc_value: Exception, traceback: object) -> None: ...

EXCEPTIONS: Mapping[str, Type[Exception]]

class IndexMetadata(NamedTuple):
    name: str
    sql: str
    columns: List[str]
    unique: bool
    table: str

class ColumnMetadata(NamedTuple):
    name: str
    data_type: str
    null: bool
    primary_key: bool
    table: str
    default: object

class ForeignKeyMetadata(NamedTuple):
    column: str
    dest_table: str
    dest_column: str
    table: str

class ViewMetadata(NamedTuple):
    name: str
    sql: str

class _ConnectionState:
    closed: bool
    conn: Optional[__IConnection]
    ctx: List[ConnectionContext]
    transactions: List[Union[_manual, _transaction]]
    def reset(self) -> None: ...
    def set_connection(self, conn: __IConnection) -> None: ...

class _ConnectionLocal(_ConnectionState, threading.local): ...

class ConnectionContext(_callable_context_manager):
    db: Database
    def __enter__(self) -> None: ...
    def __exit__(self, exc_type: Type[Exception], exc_val: Exception, exc_tb: object) -> None: ...

class Database(_callable_context_manager):
    context_class: ClassVar[Type[_TContextClass]]
    field_types: ClassVar[Mapping[str, str]]
    operations: ClassVar[Mapping[str, Any]]  # TODO (dargueta) Verify k/v types
    param: ClassVar[str]
    quote: ClassVar[str]
    server_version: ClassVar[Optional[Union[int, Tuple[int, ...]]]]
    commit_select: ClassVar[bool]
    compound_select_parentheses: ClassVar[int]
    for_update: ClassVar[bool]
    index_schema_prefix: ClassVar[bool]
    index_using_precedes_table: ClassVar[bool]
    limit_max: ClassVar[Optional[int]]
    nulls_ordering: ClassVar[bool]
    returning_clause: ClassVar[bool]
    safe_create_index: ClassVar[bool]
    safe_drop_index: ClassVar[bool]
    sequences: ClassVar[bool]
    truncate_table: ClassVar[bool]
    # Instance variables
    database: __IConnection
    deferred: bool
    autoconnect: bool
    autorollback: bool
    thread_safe: bool
    connect_params: Mapping[str, Any]
    def __init__(
        self,
        database: __IConnection,
        thread_safe: bool = ...,
        autorollback: bool = ...,
        field_types: Optional[Mapping[str, str]] = ...,
        operations: Optional[Mapping[str, str]] = ...,
        autocommit: bool = ...,
        autoconnect: bool = ...,
        **kwargs: object,
    ): ...
    def init(self, database: __IConnection, **kwargs: object) -> None: ...
    def __enter__(self) -> Database: ...
    def __exit__(self, exc_type: Type[Exception], exc_val: Exception, exc_tb: object) -> None: ...
    def connection_context(self) -> ConnectionContext: ...
    def connect(self, reuse_if_open: bool = ...) -> bool: ...
    def close(self) -> bool: ...
    def is_closed(self) -> bool: ...
    def is_connection_usable(self) -> bool: ...
    def connection(self) -> __IConnection: ...
    def cursor(self, commit: Optional[bool] = ...) -> __ICursor: ...
    def execute_sql(self, sql: str, params: Optional[tuple] = ..., commit: Union[bool, _TSentinel] = ...) -> __ICursor: ...
    def execute(self, query: Query, commit: Union[bool, _TSentinel] = ..., **context_options: object) -> __ICursor: ...
    def get_context_options(self) -> Mapping[str, object]: ...
    def get_sql_context(self, **context_options: object) -> _TContextClass: ...
    def conflict_statement(self, on_conflict: OnConflict, query: Query) -> Optional[SQL]: ...
    def conflict_update(self, oc: OnConflict, query: Query) -> NodeList: ...
    def last_insert_id(self, cursor: __ICursor, query_type: Optional[int] = ...) -> int: ...
    def rows_affected(self, cursor: __ICursor) -> int: ...
    def default_values_insert(self, ctx: Context) -> Context: ...
    def session_start(self) -> _transaction: ...
    def session_commit(self) -> bool: ...
    def session_rollback(self) -> bool: ...
    def in_transaction(self) -> bool: ...
    def push_transaction(self, transaction) -> None: ...
    def pop_transaction(self) -> Union[_manual, _transaction]: ...
    def transaction_depth(self) -> int: ...
    def top_transaction(self) -> Optional[Union[_manual, _transaction]]: ...
    def atomic(self, *args: object, **kwargs: object) -> _atomic: ...
    def manual_commit(self) -> _manual: ...
    def transaction(self, *args: object, **kwargs: object) -> _transaction: ...
    def savepoint(self) -> _savepoint: ...
    def begin(self) -> None: ...
    def commit(self) -> None: ...
    def rollback(self) -> None: ...
    def batch_commit(self, it: Iterable[T], n: int) -> Iterator[T]: ...
    def table_exists(self, table_name: str, schema: Optional[str] = ...) -> str: ...
    def get_tables(self, schema: Optional[str] = ...) -> List[str]: ...
    def get_indexes(self, table: str, schema: Optional[str] = ...) -> List[IndexMetadata]: ...
    def get_columns(self, table: str, schema: Optional[str] = ...) -> List[ColumnMetadata]: ...
    def get_primary_keys(self, table: str, schema: Optional[str] = ...) -> List[str]: ...
    def get_foreign_keys(self, table: str, schema: Optional[str] = ...) -> List[ForeignKeyMetadata]: ...
    def sequence_exists(self, seq: str) -> bool: ...
    def create_tables(self, models: Iterable[Type[Model]], **options: object) -> None: ...
    def drop_tables(self, models: Iterable[Type[Model]], **kwargs: object) -> None: ...
    def extract_date(self, date_part: str, date_field: Node) -> Function: ...
    def truncate_date(self, date_part: str, date_field: Node) -> Function: ...
    def to_timestamp(self, date_field: str) -> Function: ...
    def from_timestamp(self, date_field: str) -> Function: ...
    def random(self) -> Node: ...
    def bind(self, models: Iterable[Type[Model]], bind_refs: bool = ..., bind_backrefs: bool = ...) -> None: ...
    def bind_ctx(
        self, models: Iterable[Type[Model]], bind_refs: bool = ..., bind_backrefs: bool = ...
    ) -> _BoundModelsContext: ...
    def get_noop_select(self, ctx: Context) -> Context: ...

class SqliteDatabase(Database):
    field_types: ClassVar[Mapping[str, int]]
    operations: ClassVar[Mapping[str, str]]
    index_schema_prefix: ClassVar[bool]
    limit_max: ClassVar[int]
    server_version: ClassVar[Tuple[int, ...]]
    truncate_table: ClassVar[bool]
    # Instance variables
    timeout: int
    nulls_ordering: bool
    # Properties
    cache_size: int
    def __init__(
        self,
        database: str,
        *args: object,
        pragmas: Union[Mapping[str, object], Iterable[Tuple[str, Any]]] = ...,
        **kwargs: object,
    ): ...
    def init(
        self,
        database: str,
        pragmas: Optional[Union[Mapping[str, object], Iterable[Tuple[str, Any]]]] = ...,
        timeout: int = ...,
        **kwargs: object,
    ) -> None: ...
    def pragma(
        self, key: str, value: Union[str, bool, int] = ..., permanent: bool = ..., schema: Optional[str] = ...
    ) -> object: ...
    @property
    def foreign_keys(self) -> Any: ...
    @foreign_keys.setter
    def foreign_keys(self, value: object) -> Any: ...
    @property
    def journal_mode(self) -> Any: ...
    @journal_mode.setter
    def journal_mode(self, value: object) -> Any: ...
    @property
    def journal_size_limit(self) -> Any: ...
    @journal_size_limit.setter
    def journal_size_limit(self, value: object) -> Any: ...
    @property
    def mmap_size(self) -> Any: ...
    @mmap_size.setter
    def mmap_size(self, value: object) -> Any: ...
    @property
    def page_size(self) -> Any: ...
    @page_size.setter
    def page_size(self, value: object) -> Any: ...
    @property
    def read_uncommitted(self) -> Any: ...
    @read_uncommitted.setter
    def read_uncommitted(self, value: object) -> Any: ...
    @property
    def synchronous(self) -> Any: ...
    @synchronous.setter
    def synchronous(self, value: object) -> Any: ...
    @property
    def wal_autocheckpoint(self) -> Any: ...
    @wal_autocheckpoint.setter
    def wal_autocheckpoint(self, value: object) -> Any: ...
    def register_aggregate(self, klass: Type[__IAggregate], name: Optional[str] = ..., num_params: int = ...): ...
    def aggregate(self, name: Optional[str] = ..., num_params: int = ...) -> Callable[[_TClass], _TClass]: ...
    def register_collation(self, fn: Callable, name: Optional[str] = ...) -> None: ...
    def collation(self, name: Optional[str] = ...) -> Callable[[_TFunc], _TFunc]: ...
    def register_function(self, fn: Callable, name: Optional[str] = ..., num_params: int = ...) -> int: ...
    def func(self, name: Optional[str] = ..., num_params: int = ...) -> Callable[[_TFunc], _TFunc]: ...
    def register_window_function(self, klass: type, name: Optional[str] = ..., num_params: int = ...) -> None: ...
    def window_function(self, name: Optional[str] = ..., num_params: int = ...) -> Callable[[_TClass], _TClass]: ...
    def register_table_function(self, klass: Type[__ITableFunction], name: Optional[str] = ...) -> None: ...
    def table_function(self, name: Optional[str] = ...) -> Callable[[Type[__ITableFunction]], Type[__ITableFunction]]: ...
    def unregister_aggregate(self, name: str) -> None: ...
    def unregister_collation(self, name: str) -> None: ...
    def unregister_function(self, name: str) -> None: ...
    def unregister_window_function(self, name: str) -> None: ...
    def unregister_table_function(self, name: str) -> bool: ...
    def load_extension(self, extension: str) -> None: ...
    def unload_extension(self, extension: str) -> None: ...
    def attach(self, filename: str, name: str) -> bool: ...
    def detach(self, name: str) -> bool: ...
    def begin(self, lock_type: Optional[str] = ...) -> None: ...
    def get_views(self, schema: Optional[str] = ...) -> List[ViewMetadata]: ...
    def get_binary_type(self) -> type: ...

class PostgresqlDatabase(Database):
    field_types: ClassVar[Mapping[str, str]]
    operations: ClassVar[Mapping[str, str]]
    param: ClassVar[str]
    commit_select: ClassVar[bool]
    compound_select_parentheses: ClassVar[int]
    for_update: ClassVar[bool]
    nulls_ordering: ClassVar[bool]
    returning_clause: ClassVar[bool]
    safe_create_index: ClassVar[bool]
    sequences: ClassVar[bool]
    # Instance variables
    server_version: int
    def init(
        self,
        database: __IConnection,
        register_unicode: bool = ...,
        encoding: Optional[str] = ...,
        isolation_level: Optional[int] = ...,
        **kwargs: object,
    ): ...
    def is_connection_usable(self) -> bool: ...
    def last_insert_id(self, cursor: __ICursor, query_type: Optional[int] = ...) -> Union[Optional[int], __ICursor]: ...
    def get_views(self, schema: Optional[str] = ...) -> List[ViewMetadata]: ...
    def get_binary_type(self) -> type: ...
    def get_noop_select(self, ctx: Context) -> SelectQuery: ...
    def set_time_zone(self, timezone: str) -> None: ...

class MySQLDatabase(Database):
    field_types: ClassVar[Mapping[str, str]]
    operations: ClassVar[Mapping[str, str]]
    param: ClassVar[str]
    quote: ClassVar[str]
    commit_select: ClassVar[bool]
    compound_select_parentheses: ClassVar[int]
    for_update: ClassVar[bool]
    index_using_precedes_table: ClassVar[bool]
    limit_max: ClassVar[int]
    safe_create_index: ClassVar[bool]
    safe_drop_index: ClassVar[bool]
    sql_mode: ClassVar[str]
    # Instance variables
    server_version: Tuple[int, ...]
    def init(self, database: __IConnection, **kwargs: object): ...
    def default_values_insert(self, ctx: Context) -> SQL: ...
    def get_views(self, schema: Optional[str] = ...) -> List[ViewMetadata]: ...
    def get_binary_type(self) -> type: ...
    # TODO (dargueta) Verify return type on these function calls
    def extract_date(self, date_part: str, date_field: str) -> Function: ...
    def truncate_date(self, date_part: str, date_field: str) -> Function: ...
    def to_timestamp(self, date_field: str) -> Function: ...
    def from_timestamp(self, date_field: str) -> Function: ...
    def random(self) -> Function: ...
    def get_noop_select(self, ctx: Context) -> Context: ...

# TRANSACTION CONTROL.

class _manual(_callable_context_manager):
    db: Database
    def __init__(self, db: Database): ...
    def __enter__(self) -> None: ...
    def __exit__(self, exc_type: Type[Exception], exc_val: Exception, exc_tb: object) -> None: ...

class _atomic(_callable_context_manager):
    db: Database
    def __init__(self, db: Database, *args: object, **kwargs: object): ...
    def __enter__(self) -> Union[_transaction, _savepoint]: ...
    def __exit__(self, exc_type: Type[Exception], exc_val: Exception, exc_tb: object) -> None: ...

class _transaction(_callable_context_manager):
    db: Database
    def __init__(self, db: Database, *args: object, **kwargs: object): ...
    def commit(self, begin: bool = ...) -> None: ...
    def rollback(self, begin: bool = ...) -> None: ...
    def __enter__(self) -> _transaction: ...
    def __exit__(self, exc_type: Type[Exception], exc_val: Exception, exc_tb: object) -> None: ...

class _savepoint(_callable_context_manager):
    db: Database
    sid: str
    quoted_sid: str
    def __init__(self, db: Database, sid: Optional[str] = ...): ...
    def commit(self, begin: bool = ...) -> None: ...
    def rollback(self) -> None: ...
    def __enter__(self) -> _savepoint: ...
    def __exit__(self, exc_type: Type[Exception], exc_val: Exception, exc_tb: object) -> None: ...

class CursorWrapper(Generic[T]):
    cursor: __ICursor
    count: int
    index: int
    initialized: bool
    populated: bool
    row_cache: List[T]
    def __init__(self, cursor: __ICursor): ...
    def __iter__(self) -> Union[ResultIterator[T], Iterator[T]]: ...
    @overload
    def __getitem__(self, item: int) -> T: ...
    @overload
    def __getitem__(self, item: slice) -> List[T]: ...
    def __len__(self) -> int: ...
    def initialize(self) -> None: ...
    def iterate(self, cache: bool = ...) -> T: ...
    def process_row(self, row: tuple) -> T: ...
    def iterator(self) -> Iterator[T]: ...
    def fill_cache(self, n: int = ...) -> None: ...

class DictCursorWrapper(CursorWrapper[Mapping[str, object]]): ...

# FIXME (dargueta): Somehow figure out how to make this a NamedTuple sorta deal
class NamedTupleCursorWrapper(CursorWrapper[tuple]):
    tuple_class: Type[tuple]

class ObjectCursorWrapper(DictCursorWrapper[T]):
    constructor: Callable[..., T]
    def __init__(self, cursor: __ICursor, constructor: Callable[..., T]): ...
    def process_row(self, row: tuple) -> T: ...  # type: ignore

class ResultIterator(Generic[T]):
    cursor_wrapper: CursorWrapper[T]
    index: int
    def __init__(self, cursor_wrapper: CursorWrapper[T]): ...
    def __iter__(self) -> Iterator[T]: ...

# FIELDS

class FieldAccessor:
    model: Type[Model]
    field: Field
    name: str
    def __init__(self, model: Type[Model], field: Field, name: str): ...
    @overload
    def __get__(self, instance: None, instance_type: type) -> Field: ...
    @overload
    def __get__(self, instance: T, instance_type: Type[T]) -> Any: ...

class ForeignKeyAccessor(FieldAccessor):
    model: Type[Model]
    field: ForeignKeyField
    name: str
    rel_model: Type[Model]
    def __init__(self, model: Type[Model], field: ForeignKeyField, name: str): ...
    def get_rel_instance(self, instance: Model) -> Any: ...
    @overload
    def __get__(self, instance: None, instance_type: type) -> Any: ...
    @overload
    def __get__(self, instance: _TModel, instance_type: Type[_TModel]) -> ForeignKeyField: ...
    def __set__(self, instance: _TModel, obj: object) -> None: ...

class NoQueryForeignKeyAccessor(ForeignKeyAccessor):
    def get_rel_instance(self, instance: Model) -> Any: ...

class BackrefAccessor:
    field: ForeignKeyField
    model: Type[Model]
    rel_model: Type[Model]
    def __init__(self, field: ForeignKeyField): ...
    @overload
    def __get__(self, instance: None, instance_type: type) -> BackrefAccessor: ...
    @overload
    def __get__(self, instance: Field, instance_type: Type[Field]) -> SelectQuery: ...

class ObjectIdAccessor:
    """Gives direct access to the underlying id"""

    field: ForeignKeyField
    def __init__(self, field: ForeignKeyField): ...
    @overload
    def __get__(self, instance: None, instance_type: Type[Model]) -> ForeignKeyField: ...
    @overload
    def __get__(self, instance: _TModel, instance_type: Type[_TModel] = ...) -> Any: ...
    def __set__(self, instance: Model, value: object) -> None: ...

class Field(ColumnBase):
    accessor_class: ClassVar[Type[FieldAccessor]]
    auto_increment: ClassVar[bool]
    default_index_type: ClassVar[Optional[str]]
    field_type: ClassVar[str]
    unpack: ClassVar[bool]
    # Instance variables
    model: Type[Model]
    null: bool
    index: bool
    unique: bool
    column_name: str
    default: Any
    primary_key: bool
    constraints: Optional[Iterable[Union[Callable[[str], SQL], SQL]]]
    sequence: Optional[str]
    collation: Optional[str]
    unindexed: bool
    help_text: Optional[str]
    verbose_name: Optional[str]
    index_type: Optional[str]
    def __init__(
        self,
        null: bool = ...,
        index: bool = ...,
        unique: bool = ...,
        column_name: str = ...,
        default: Any = ...,
        primary_key: bool = ...,
        constraints: Optional[Iterable[Union[Callable[[str], SQL], SQL]]] = ...,
        sequence: Optional[str] = ...,
        collation: Optional[str] = ...,
        unindexed: Optional[bool] = ...,
        choices: Optional[Iterable[Tuple[Any, str]]] = ...,
        help_text: Optional[str] = ...,
        verbose_name: Optional[str] = ...,
        index_type: Optional[str] = ...,
        db_column: Optional[str] = ...,  # Deprecated argument, undocumented
        _hidden: bool = ...,
    ): ...
    def __hash__(self) -> int: ...
    def __repr__(self) -> str: ...
    def bind(self, model: Type[Model], name: str, set_attribute: bool = ...) -> None: ...
    @property
    def column(self) -> Column: ...
    def adapt(self, value: T) -> T: ...
    def db_value(self, value: T) -> T: ...
    def python_value(self, value: T) -> T: ...
    def to_value(self, value: Any) -> Value: ...
    def get_sort_key(self, ctx: Context) -> Tuple[int, int]: ...
    def __sql__(self, ctx: Context) -> Context: ...
    def get_modifiers(self) -> Any: ...
    def ddl_datatype(self, ctx: Context) -> SQL: ...
    def ddl(self, ctx: Context) -> NodeList: ...

class IntegerField(Field):
    @overload
    def adapt(self, value: Union[str, float, bool]) -> int: ...  # type: ignore
    @overload
    def adapt(self, value: T) -> T: ...

class BigIntegerField(IntegerField): ...
class SmallIntegerField(IntegerField): ...

class AutoField(IntegerField):
    def __init__(self, *args: object, primary_key: bool = ..., **kwargs: object): ...

class BigAutoField(AutoField): ...

class IdentityField(AutoField):
    def __init__(self, generate_always: bool = ..., **kwargs: object): ...

class PrimaryKeyField(AutoField): ...

class FloatField(Field):
    @overload
    def adapt(self, value: Union[str, float, bool]) -> float: ...  # type: ignore
    @overload
    def adapt(self, value: T) -> T: ...

class DoubleField(FloatField): ...

class DecimalField(Field):
    max_digits: int
    decimal_places: int
    auto_round: int
    rounding: bool
    def __init__(
        self,
        max_digits: int = ...,
        decimal_places: int = ...,
        auto_round: bool = ...,
        rounding: bool = ...,
        *args: object,
        **kwargs: object,
    ): ...
    def get_modifiers(self) -> List[int]: ...
    @overload
    def db_value(self, value: None) -> None: ...
    @overload
    def db_value(self, value: Union[float, decimal.Decimal]) -> decimal.Decimal: ...  # type: ignore
    @overload
    def db_value(self, value: T) -> T: ...
    @overload
    def python_value(self, value: None) -> None: ...
    @overload
    def python_value(self, value: Union[str, float, decimal.Decimal]) -> decimal.Decimal: ...

class _StringField(Field):
    def adapt(self, value: AnyStr) -> str: ...
    def __add__(self, other: Any) -> StringExpression: ...
    def __radd__(self, other: Any) -> StringExpression: ...

class CharField(_StringField):
    max_length: int
    def __init__(self, max_length: int = ..., *args: object, **kwargs: object): ...
    def get_modifiers(self) -> Optional[List[int]]: ...

class FixedCharField(CharField): ...
class TextField(_StringField): ...

class BlobField(Field):
    @overload
    def db_value(self, value: Union[str, bytes]) -> bytearray: ...
    @overload
    def db_value(self, value: T) -> T: ...

class BitField(BitwiseMixin, BigIntegerField):
    def __init__(self, *args: object, default: Optional[int] = ..., **kwargs: object): ...
    # FIXME (dargueta) Return type isn't 100% accurate; function creates a new class
    def flag(self, value: Optional[int] = ...) -> ColumnBase: ...

class BigBitFieldData:
    name: str
    instance: Model
    def __init__(self, instance: Model, name: str): ...
    def set_bit(self, idx: int) -> None: ...
    def clear_bit(self, idx: bool) -> None: ...
    def toggle_bit(self, idx: int) -> bool: ...
    def is_set(self, idx: int) -> bool: ...
    def __repr__(self) -> str: ...

class BigBitFieldAccessor(FieldAccessor):
    @overload
    def __get__(self, instance: None, instance_type: Type[_TModel]) -> Field: ...
    @overload
    def __get__(self, instance: _TModel, instance_type: Type[_TModel]) -> BigBitFieldData: ...
    def __set__(self, instance: Any, value: Union[memoryview, bytearray, BigBitFieldData, str, bytes]) -> None: ...

class BigBitField(BlobField):
    accessor_class: ClassVar[Type[BigBitFieldAccessor]]
    def __init__(self, *args: object, default: type = ..., **kwargs: object): ...
    @overload
    def db_value(self, value: None) -> None: ...
    @overload
    def db_value(self, value: T) -> bytes: ...

class UUIDField(Field):
    @overload
    def db_value(self, value: AnyStr) -> str: ...
    @overload
    def db_value(self, value: T) -> T: ...
    @overload
    def python_value(self, value: Union[uuid.UUID, AnyStr]) -> uuid.UUID: ...
    @overload
    def python_value(self, value: None) -> None: ...

class BinaryUUIDField(BlobField):
    @overload
    def db_value(self, value: None) -> None: ...
    @overload
    def db_value(self, value: Optional[Union[bytearray, bytes, str, uuid.UUID]]) -> bytes: ...
    @overload
    def python_value(self, value: None) -> None: ...
    @overload
    def python_value(self, value: Union[bytearray, bytes, memoryview, uuid.UUID]) -> uuid.UUID: ...

def format_date_time(value: str, formats: Iterable[str], post_process: Optional[_TConvFunc] = ...) -> str: ...
@overload
def simple_date_time(value: T) -> T: ...

class _BaseFormattedField(Field):
    # TODO (dargueta): This is a class variable that can be overridden for instances
    formats: Optional[Container[str]]
    def __init__(self, formats: Optional[Container[str]] = ..., *args: object, **kwargs: object): ...

class DateTimeField(_BaseFormattedField):
    @property
    def year(self) -> int: ...
    @property
    def month(self) -> int: ...
    @property
    def day(self) -> int: ...
    @property
    def hour(self) -> int: ...
    @property
    def minute(self) -> int: ...
    @property
    def second(self) -> int: ...
    def adapt(self, value: T) -> T: ...
    def to_timestamp(self) -> Function: ...
    def truncate(self, part: str) -> Function: ...

class DateField(_BaseFormattedField):
    @property
    def year(self) -> int: ...
    @property
    def month(self) -> int: ...
    @property
    def day(self) -> int: ...
    @overload
    def adapt(self, value: datetime.datetime) -> datetime.date: ...
    @overload
    def adapt(self, value: T) -> T: ...
    def to_timestamp(self) -> Function: ...
    def truncate(self, part: str) -> Function: ...

class TimeField(_BaseFormattedField):
    @overload
    def adapt(self, value: Union[datetime.datetime, datetime.timedelta]) -> datetime.time: ...
    @overload
    def adapt(self, value: T) -> T: ...
    @property
    def hour(self) -> int: ...
    @property
    def minute(self) -> int: ...
    @property
    def second(self) -> int: ...

class TimestampField(BigIntegerField):
    valid_resolutions: ClassVar[Container[int]]
    # Instance variables
    resolution: int
    ticks_to_microsecond: int
    utc: bool
    def __init__(self, *args: object, resolution: int = ..., utc: bool = ..., **kwargs: object): ...
    def local_to_utc(self, dt: datetime.datetime) -> datetime.datetime: ...
    def utc_to_local(self, dt: datetime.datetime) -> datetime.datetime: ...
    def get_timestamp(self, value: datetime.datetime) -> float: ...
    @overload
    def db_value(self, value: None) -> None: ...
    @overload
    def db_value(self, value: Union[datetime.datetime, datetime.date, float]) -> int: ...
    @overload
    def python_value(self, value: Union[int, float]) -> datetime.datetime: ...
    @overload
    def python_value(self, value: T) -> T: ...
    def from_timestamp(self) -> float: ...
    @property
    def year(self) -> int: ...
    @property
    def month(self) -> int: ...
    @property
    def day(self) -> int: ...
    @property
    def hour(self) -> int: ...
    @property
    def minute(self) -> int: ...
    @property
    def second(self) -> float: ...  # TODO (dargueta) Int?

class IPField(BigIntegerField):
    @overload
    def db_value(self, val: str) -> int: ...
    @overload
    def db_value(self, val: None) -> None: ...
    @overload
    def python_value(self, val: int) -> str: ...
    @overload
    def python_value(self, val: None) -> None: ...

class BooleanField(Field):
    def adapt(self, value: Any) -> bool: ...

class BareField(Field):
    # If `adapt` was omitted from the constructor or None, this attribute won't exist.
    adapt: Optional[_TConvFunc]
    def __init__(self, adapt: Optional[_TConvFunc] = ..., *args: object, **kwargs: object): ...
    def ddl_datatype(self, ctx: Context) -> None: ...

class ForeignKeyField(Field):
    accessor_class: ClassVar[Type[ForeignKeyAccessor]]
    rel_model: Union[Type[Model], Literal["self"]]
    rel_field: Field
    declared_backref: Optional[str]
    backref: Optional[str]  # TODO (dargueta): Verify
    on_delete: Optional[str]
    on_update: Optional[str]
    deferrable: Optional[str]
    deferred: Optional[bool]
    object_id_name: Optional[str]
    lazy_load: bool
    safe_name: str
    def __init__(
        self,
        model: Union[Type[Model], Literal["self"]],
        field: Optional[Field] = ...,
        # TODO (dargueta): Documentation says this is only a string but code accepts a callable too
        backref: Optional[str] = ...,
        on_delete: Optional[str] = ...,
        on_update: Optional[str] = ...,
        deferrable: Optional[str] = ...,
        _deferred: Optional[bool] = ...,  # undocumented
        rel_model: object = ...,  # undocumented
        to_field: object = ...,  # undocumented
        object_id_name: Optional[str] = ...,
        lazy_load: bool = ...,
        # type for related_name is a guess
        related_name: Optional[str] = ...,  # undocumented
        *args: object,
        index: bool = ...,
        **kwargs: object,
    ): ...
    @property
    def field_type(self) -> str: ...
    def get_modifiers(self) -> Optional[Iterable[object]]: ...
    def adapt(self, value: object) -> Any: ...
    def db_value(self, value: object) -> Any: ...
    def python_value(self, value: object) -> Any: ...
    def bind(self, model: Type[Model], name: str, set_attribute: bool = ...) -> None: ...
    def foreign_key_constraint(self) -> NodeList: ...
    def __getattr__(self, attr: str) -> Field: ...

class DeferredForeignKey(Field):
    field_kwargs: Dict[str, object]
    rel_model_name: str
    def __init__(self, rel_model_name: str, *, column_name: Optional[str] = ..., null: Optional[str] = ..., **kwargs: object): ...
    def set_model(self, rel_model: Type[Model]) -> None: ...
    @staticmethod
    def resolve(model_cls: Type[Model]) -> None: ...
    def __hash__(self) -> int: ...

class DeferredThroughModel:
    def set_field(self, model: Type[Model], field: Type[Field], name: str) -> None: ...
    def set_model(self, through_model: Type[Model]) -> None: ...

class MetaField(Field):
    # These are declared as class variables in the source code but are used like local
    # variables
    column_name: Optional[str]
    default: Any
    model: Type[Model]
    name: Optional[str]
    primary_key: bool

class ManyToManyFieldAccessor(FieldAccessor):
    model: Type[Model]
    rel_model: Type[Model]
    through_model: Type[Model]
    src_fk: ForeignKeyField
    dest_fk: ForeignKeyField
    def __init__(self, model: Type[Model], field: ForeignKeyField, name: str): ...
    @overload
    def __get__(self, instance: None, instance_type: Type[T] = ..., force_query: bool = ...) -> Field: ...
    @overload
    def __get__(
        self, instance: T, instance_type: Type[T] = ..., force_query: bool = ...
    ) -> Union[List[str], ManyToManyQuery]: ...
    def __set__(self, instance: T, value) -> None: ...

class ManyToManyField(MetaField):
    accessor_class: ClassVar[Type[ManyToManyFieldAccessor]]
    # Instance variables
    through_model: Union[Type[Model], DeferredThroughModel]
    rel_model: Type[Model]
    backref: Optional[str]
    def __init__(
        self,
        model: Type[Model],
        backref: Optional[str] = ...,
        through_model: Optional[Union[Type[Model], DeferredThroughModel]] = ...,
        on_delete: Optional[str] = ...,
        on_update: Optional[str] = ...,
        _is_backref: bool = ...,
    ): ...
    def bind(self, model: Type[Model], name: str, set_attribute: bool = ...) -> None: ...
    def get_models(self) -> List[Type[Model]]: ...
    def get_through_model(self) -> Union[Type[Model], DeferredThroughModel]: ...

class VirtualField(MetaField, Generic[_TField]):
    field_class: Type[_TField]
    field_instance: Optional[_TField]
    def __init__(self, field_class: Optional[Type[_TField]] = ..., *args: object, **kwargs: object): ...
    def db_value(self, value: object) -> Any: ...
    def python_value(self, value: object) -> Any: ...
    def bind(self, model: Type[Model], name: str, set_attribute: bool = ...) -> None: ...

class CompositeKey(MetaField):
    sequence = None
    field_names: Tuple[str, ...]
    # The following attributes are not set in the constructor an so may not always be
    # present.
    model: Type[Model]
    column_name: str
    def __init__(self, *field_names: str): ...
    @property
    def safe_field_names(self) -> Union[List[str], Tuple[str, ...]]: ...
    @overload
    def __get__(self, instance: None, instance_type: type) -> CompositeKey: ...
    @overload
    def __get__(self, instance: T, instance_type: Type[T]) -> tuple: ...
    def __set__(self, instance: Model, value: Union[list, tuple]) -> None: ...
    def __eq__(self, other: Expression) -> Expression: ...
    def __ne__(self, other: Expression) -> Expression: ...
    def __hash__(self) -> int: ...
    def __sql__(self, ctx: Context) -> Context: ...
    def bind(self, model: Type[Model], name: str, set_attribute: bool = ...) -> None: ...

# MODELS

class SchemaManager:
    model: Type[Model]
    context_options: Dict[str, object]
    def __init__(self, model: Type[Model], database: Optional[Database] = ..., **context_options: object): ...
    @property
    def database(self) -> Database: ...
    @database.setter
    def database(self, value: Optional[Database]) -> None: ...
    def create_table(self, safe: bool = ..., **options: object) -> None: ...
    def create_table_as(self, table_name: str, query: SelectQuery, safe: bool = ..., **meta: object) -> None: ...
    def drop_table(self, safe: bool = ..., **options: object) -> None: ...
    def truncate_table(self, restart_identity: bool = ..., cascade: bool = ...) -> None: ...
    def create_indexes(self, safe: bool = ...) -> None: ...
    def drop_indexes(self, safe: bool = ...) -> None: ...
    def create_sequence(self, field: Field) -> None: ...
    def drop_sequence(self, field: Field) -> None: ...
    def create_foreign_key(self, field: Field) -> None: ...
    def create_sequences(self) -> None: ...
    def create_all(self, safe: bool = ..., **table_options: object) -> None: ...
    def drop_sequences(self) -> None: ...
    def drop_all(self, safe: bool = ..., drop_sequences: bool = ..., **options: object) -> None: ...

class Metadata:
    model: Type[Model]
    database: Optional[Database]
    fields: Dict[str, object]  # TODO (dargueta) This may be Dict[str, Field]
    columns: Dict[str, object]  # TODO (dargueta) Verify this
    combined: Dict[str, object]  # TODO (dargueta) Same as above
    sorted_fields: List[Field]
    sorted_field_names: List[str]
    defaults: Dict[str, object]
    name: str
    table_function: Optional[Callable[[Type[Model]], str]]
    legacy_table_names: bool
    table_name: str
    indexes: List[Union[Index, ModelIndex, SQL]]
    constraints: Optional[Iterable[Union[Callable[[str], SQL], SQL]]]
    primary_key: Union[Literal[False], Field, CompositeKey, None]
    composite_key: Optional[bool]
    auto_increment: Optional[bool]
    only_save_dirty: bool
    depends_on: Optional[Sequence[Type[Model]]]
    table_settings: Mapping[str, object]
    temporary: bool
    refs: Dict[ForeignKeyField, Type[Model]]
    backrefs: MutableMapping[ForeignKeyField, List[Type[Model]]]
    model_refs: MutableMapping[Type[Model], List[ForeignKeyField]]
    model_backrefs: MutableMapping[ForeignKeyField, List[Type[Model]]]
    manytomany: Dict[str, ManyToManyField]
    options: Mapping[str, object]
    table: Optional[Table]
    entity: Entity
    def __init__(
        self,
        model: Type[Model],
        database: Optional[Database] = ...,
        table_name: Optional[str] = ...,
        indexes: Optional[Iterable[Union[str, Sequence[str]]]] = ...,
        primary_key: Optional[Union[Literal[False], Field, CompositeKey]] = ...,
        constraints: Optional[Iterable[Union[Check, SQL]]] = ...,
        schema: Optional[str] = ...,
        only_save_dirty: bool = ...,
        depends_on: Optional[Sequence[Type[Model]]] = ...,
        options: Optional[Mapping[str, object]] = ...,
        db_table: Optional[str] = ...,
        table_function: Optional[Callable[[Type[Model]], str]] = ...,
        table_settings: Optional[Mapping[str, object]] = ...,
        without_rowid: bool = ...,
        temporary: bool = ...,
        legacy_table_names: bool = ...,
        **kwargs: object,
    ): ...
    def make_table_name(self) -> str: ...
    def model_graph(
        self, refs: bool = ..., backrefs: bool = ..., depth_first: bool = ...
    ) -> List[Tuple[ForeignKeyField, Type[Model], bool]]: ...
    def add_ref(self, field: ForeignKeyField) -> None: ...
    def remove_ref(self, field: ForeignKeyField) -> None: ...
    def add_manytomany(self, field: ManyToManyField) -> None: ...
    def remove_manytomany(self, field: ManyToManyField) -> None: ...
    def get_rel_for_model(self, model: Union[Type[Model], ModelAlias]) -> Tuple[List[ForeignKeyField], List[Type[Model]]]: ...
    def add_field(self, field_name: str, field: Field, set_attribute: bool = ...) -> None: ...
    def remove_field(self, field_name: str) -> None: ...
    def set_primary_key(self, name: str, field: Union[Field, CompositeKey]) -> None: ...
    def get_primary_keys(self) -> Tuple[Field, ...]: ...
    def get_default_dict(self) -> Dict[str, object]: ...
    def fields_to_index(self) -> List[ModelIndex]: ...
    def set_database(self, database: Database) -> None: ...
    def set_table_name(self, table_name: str) -> None: ...

class SubclassAwareMetadata(Metadata):
    models: ClassVar[List[Type[Model]]]
    def __init__(self, model: Type[Model], *args: object, **kwargs: object): ...
    def map_models(self, fn: Callable[[Type[Model]], Any]) -> None: ...

class DoesNotExist(Exception): ...

class ModelBase(type):
    inheritable: ClassVar[Set[str]]
    def __repr__(self) -> str: ...
    def __iter__(self) -> Iterator[Any]: ...
    def __getitem__(self, key: object) -> Model: ...
    def __setitem__(self, key: object, value: Model) -> None: ...
    def __delitem__(self, key: object) -> None: ...
    def __contains__(self, key: object) -> bool: ...
    def __len__(self) -> int: ...
    def __bool__(self) -> bool: ...
    def __nonzero__(self) -> bool: ...
    def __sql__(self, ctx: Context) -> Context: ...

class _BoundModelsContext(_callable_context_manager):
    models: Iterable[Type[Model]]
    database: Database
    bind_refs: bool
    bind_backrefs: bool
    def __init__(self, models: Iterable[Type[Model]], database, bind_refs: bool, bind_backrefs: bool): ...
    def __enter__(self) -> Iterable[Type[Model]]: ...
    def __exit__(self, exc_type: Type[Exception], exc_val: Exception, exc_tb: Any) -> None: ...

class Model(Node, metaclass=ModelBase):
    _meta: ClassVar[Metadata]
    _schema: ClassVar[SchemaManager]
    DoesNotExist: ClassVar[Type[DoesNotExist]]
    __data__: MutableMapping[str, object]
    __rel__: MutableMapping[str, object]
    def __init__(self, *, __no_default__: Union[int, bool] = ..., **kwargs: object): ...
    def __str__(self) -> str: ...
    @classmethod
    def validate_model(cls) -> None: ...
    @classmethod
    def alias(cls, alias: Optional[str] = ...) -> ModelAlias: ...
    @classmethod
    def select(cls, *fields: Field) -> ModelSelect: ...
    @classmethod
    def update(cls, __data: Optional[Iterable[Union[str, Field]]] = ..., **update: Any) -> ModelUpdate: ...
    @classmethod
    def insert(cls, __data: Optional[Iterable[Union[str, Field]]] = ..., **insert: Any) -> ModelInsert: ...
    @overload
    @classmethod
    def insert_many(cls, rows: Iterable[Mapping[str, object]], fields: None) -> ModelInsert: ...
    @overload
    @classmethod
    def insert_many(cls, rows: Iterable[tuple], fields: Sequence[Field]) -> ModelInsert: ...
    @classmethod
    def insert_from(cls, query: SelectQuery, fields: Iterable[Union[Field, Text]]) -> ModelInsert: ...
    @classmethod
    def replace(cls, __data: Optional[Iterable[Union[str, Field]]] = ..., **insert: object) -> OnConflict: ...
    @classmethod
    def replace_many(cls, rows: Iterable[tuple], fields: Optional[Sequence[Field]] = ...) -> OnConflict: ...
    @classmethod
    def raw(cls, sql: str, *params: object) -> ModelRaw: ...
    @classmethod
    def delete(cls) -> ModelDelete: ...
    @classmethod
    def create(cls: Type[T], **query) -> T: ...
    @classmethod
    def bulk_create(cls, model_list: Iterable[Type[Model]], batch_size: Optional[int] = ...) -> None: ...
    @classmethod
    def bulk_update(
        cls, model_list: Iterable[Type[Model]], fields: Iterable[Union[str, Field]], batch_size: Optional[int] = ...
    ) -> int: ...
    @classmethod
    def noop(cls) -> NoopModelSelect: ...
    @classmethod
    def get(cls, *query: object, **filters: object) -> ModelSelect: ...
    @classmethod
    def get_or_none(cls, *query: object, **filters: object) -> Optional[ModelSelect]: ...
    @classmethod
    def get_by_id(cls, pk: object) -> ModelSelect: ...
    # TODO (dargueta) I'm 99% sure of return value for this one
    @classmethod
    def set_by_id(cls, key, value) -> CursorWrapper: ...
    # TODO (dargueta) I'm also not 100% about this one's return value.
    @classmethod
    def delete_by_id(cls, pk: object) -> CursorWrapper: ...
    @classmethod
    def get_or_create(cls, *, defaults: Mapping[str, object] = ..., **kwargs: object) -> Tuple[Any, bool]: ...
    @classmethod
    def filter(cls, *dq_nodes: DQ, **filters: Any) -> SelectQuery: ...
    def get_id(self) -> Any: ...
    def save(self, force_insert: bool = ..., only: Optional[Iterable[Union[str, Field]]] = ...) -> Union[Literal[False], int]: ...
    def is_dirty(self) -> bool: ...
    @property
    def dirty_fields(self) -> List[Field]: ...
    def dependencies(self, search_nullable: bool = ...) -> Iterator[Tuple[Union[bool, Node], ForeignKeyField]]: ...
    def delete_instance(self: T, recursive: bool = ..., delete_nullable: bool = ...) -> T: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __sql__(self, ctx: Context) -> Context: ...
    @classmethod
    def bind(
        cls,
        database: Database,
        bind_refs: bool = ...,
        bind_backrefs: bool = ...,
        _exclude: Optional[MutableSet[Type[Model]]] = ...,
    ) -> bool: ...
    @classmethod
    def bind_ctx(cls, database: Database, bind_refs: bool = ..., bind_backrefs: bool = ...) -> _BoundModelsContext: ...
    @classmethod
    def table_exists(cls) -> bool: ...
    @classmethod
    def create_table(cls, safe: bool = ..., *, fail_silently: bool = ..., **options: object) -> None: ...
    @classmethod
    def drop_table(cls, safe: bool = ..., drop_sequences: bool = ..., **options: object) -> None: ...
    @classmethod
    def truncate_table(cls, **options: object) -> None: ...
    @classmethod
    def index(cls, *fields: Union[Field, Node, str], **kwargs: object) -> ModelIndex:
        return ModelIndex(cls, fields, **kwargs)
    @classmethod
    def add_index(cls, *fields: Union[str, SQL, Index], **kwargs: object) -> None: ...

class ModelAlias(Node, Generic[_TModel]):
    """Provide a separate reference to a model in a query."""

    model: Type[_TModel]
    alias: Optional[str]
    def __init__(self, model: Type[_TModel], alias: Optional[str] = ...): ...
    def __getattr__(self, attr: str) -> Any: ...
    def __setattr__(self, attr: str, value: object) -> NoReturn: ...
    def get_field_aliases(self) -> List[Field]: ...
    def select(self, *selection: Field) -> ModelSelect: ...
    def __call__(self, **kwargs) -> _TModel: ...
    def __sql__(self, ctx: Context) -> Context: ...

_TModelOrTable = Union[Type[Model], ModelAlias, Table]
_TSubquery = Union[Tuple[Query, Type[Model]], Type[Model], ModelAlias]
_TFieldOrModel = Union[_TModelOrTable, Field]

class FieldAlias(Field):
    source: Node
    model: Type[Model]
    field: Field
    # TODO (dargueta): Making an educated guess about `source`; might be `Node`
    def __init__(self, source: MetaField, field: Field): ...
    @classmethod
    def create(cls, source: ModelAlias, field: str) -> FieldAlias: ...
    def clone(self) -> FieldAlias: ...
    def adapt(self, value: object) -> Any: ...
    def python_value(self, value: object) -> Any: ...
    def db_value(self, value: object) -> Any: ...
    @overload
    def __getattr__(self, attr: Literal["model"]) -> Node: ...
    @overload
    def __getattr__(self, attr: str) -> Any: ...
    def __sql__(self, ctx: Context) -> Context: ...

def sort_models(models: Iterable[Type[Model]]) -> List[Type[Model]]: ...

class _ModelQueryHelper:
    default_row_type: ClassVar[int]
    def objects(self, constructor: Optional[Callable[..., Any]] = ...) -> _ModelQueryHelper: ...

class ModelRaw(_ModelQueryHelper, RawQuery, Generic[_TModel]):
    model: Type[_TModel]
    def __init__(self, model: Type[_TModel], sql: str, params: tuple, **kwargs: object): ...
    def get(self) -> _TModel: ...

class BaseModelSelect(_ModelQueryHelper):
    def union_all(self, rhs: object) -> ModelCompoundSelectQuery: ...
    __add__ = union_all
    def union(self, rhs: object) -> ModelCompoundSelectQuery: ...
    __or__ = union
    def intersect(self, rhs: object) -> ModelCompoundSelectQuery: ...
    __and__ = intersect
    def except_(self, rhs: object) -> ModelCompoundSelectQuery: ...
    __sub__ = except_
    def __iter__(self) -> Iterator[Any]: ...
    def prefetch(self, *subqueries: _TSubquery) -> List[Any]: ...
    def get(self, database: Optional[Database] = ...) -> Any: ...
    def group_by(self, *columns: Union[Type[Model], Table, Field]) -> BaseModelSelect: ...

class ModelCompoundSelectQuery(BaseModelSelect, CompoundSelectQuery, Generic[_TModel]):
    model: Type[_TModel]
    def __init__(self, model: Type[_TModel], *args: object, **kwargs: object): ...

class ModelSelect(BaseModelSelect, Select, Generic[_TModel]):
    model: Type[_TModel]
    def __init__(self, model: Type[_TModel], fields_or_models: Iterable[_TFieldOrModel], is_default: bool = ...): ...
    def clone(self) -> ModelSelect: ...
    def select(self, *fields_or_models: _TFieldOrModel) -> ModelSelect: ...  # type: ignore
    def switch(self, ctx: Optional[Type[Model]] = ...) -> ModelSelect: ...
    def join(  # type: ignore
        self,
        dest: Union[Type[Model], Table, ModelAlias, ModelSelect],
        join_type: int = ...,
        on: Optional[Union[Column, Expression, Field]] = ...,
        src: Optional[Union[Type[Model], Table, ModelAlias, ModelSelect]] = ...,
        attr: Optional[str] = ...,
    ) -> ModelSelect: ...
    def join_from(
        self,
        src: Union[Type[Model], Table, ModelAlias, ModelSelect],
        dest: Union[Type[Model], Table, ModelAlias, ModelSelect],
        join_type: int = ...,
        on: Optional[Union[Column, Expression, Field]] = ...,
        attr: Optional[str] = ...,
    ) -> ModelSelect: ...
    def ensure_join(
        self, lm: Type[Model], rm: Type[Model], on: Optional[Union[Column, Expression, Field]] = ..., **join_kwargs: Any
    ) -> ModelSelect: ...
    # TODO (dargueta): 85% sure about the return value
    def convert_dict_to_node(self, qdict: Mapping[str, object]) -> Tuple[List[Expression], List[Field]]: ...
    def filter(self, *args: Node, **kwargs: object) -> ModelSelect: ...
    def create_table(self, name: str, safe: bool = ..., **meta: object) -> None: ...
    def __sql_selection__(self, ctx: Context, is_subquery: bool = ...) -> Context: ...

class NoopModelSelect(ModelSelect):
    def __sql__(self, ctx: Context) -> Context: ...

class _ModelWriteQueryHelper(_ModelQueryHelper):
    model: Type[Model]
    def __init__(self, model: Type[Model], *args: object, **kwargs: object): ...
    def returning(self, *returning: Union[Type[Model], Field]) -> _ModelWriteQueryHelper: ...

class ModelUpdate(_ModelWriteQueryHelper, Update): ...

class ModelInsert(_ModelWriteQueryHelper, Insert):
    default_row_type: ClassVar[int]
    def returning(self, *returning: Union[Type[Model], Field]) -> ModelInsert: ...
    def get_default_data(self) -> Mapping[str, object]: ...
    def get_default_columns(self) -> Sequence[Field]: ...

class ModelDelete(_ModelWriteQueryHelper, Delete): ...

class ManyToManyQuery(ModelSelect):
    def __init__(
        self, instance: Model, accessor: ManyToManyFieldAccessor, rel: _TFieldOrModel, *args: object, **kwargs: object
    ): ...
    def add(self, value: Union[SelectQuery, Type[Model], Iterable[str]], clear_existing: bool = ...) -> None: ...
    def remove(self, value: Union[SelectQuery, Type[Model], Iterable[str]]) -> Optional[int]: ...
    def clear(self) -> int: ...

class BaseModelCursorWrapper(DictCursorWrapper, Generic[_TModel]):
    ncols: int
    columns: List[str]
    converters: List[_TConvFunc]
    fields: List[Field]
    model: Type[_TModel]
    select: Sequence[str]
    def __init__(self, cursor: __ICursor, model: Type[_TModel], columns: Optional[Sequence[str]]): ...
    def process_row(self, row: tuple) -> Mapping[str, object]: ...  # type: ignore

class ModelDictCursorWrapper(BaseModelCursorWrapper[_TModel]):
    def process_row(self, row: tuple) -> Dict[str, Any]: ...

class ModelTupleCursorWrapper(ModelDictCursorWrapper[_TModel]):
    constructor: ClassVar[Callable[[Sequence[Any]], tuple]]
    def process_row(self, row: tuple) -> tuple: ...  # type: ignore

class ModelNamedTupleCursorWrapper(ModelTupleCursorWrapper[_TModel]): ...

class ModelObjectCursorWrapper(ModelDictCursorWrapper[_TModel]):
    constructor: Union[Type[_TModel], Callable[[Any], _TModel]]
    is_model: bool
    # TODO (dargueta): `select` is some kind of Sequence
    def __init__(
        self,
        cursor: __ICursor,
        model: _TModel,
        select: Sequence[Any],  # incomplete
        constructor: Union[Type[_TModel], Callable[[Any], _TModel]],
    ): ...
    def process_row(self, row: tuple) -> _TModel: ...  # type: ignore

class ModelCursorWrapper(BaseModelCursorWrapper[_TModel]):
    # TODO (dargueta) -- Iterable[Union[Join, ...]]
    from_list: Iterable[Any]  # incomplete
    # TODO (dargueta) -- Mapping[<from list type>, Tuple[?, ?, Callable[..., _TModel], int?]]
    joins: Mapping[Hashable, Tuple[object, object, Callable[..., _TModel], int]]
    key_to_constructor: Dict[Type[_TModel], Callable[..., _TModel]]
    src_is_dest: Dict[Type[Model], bool]
    src_to_dest: List[tuple]  # TODO -- Tuple[<frmo list type>, join_type[1], join_type[0], bool, join_type[3]]
    column_keys: List  # incomplete
    def __init__(
        self,
        cursor: __ICursor,
        model: Type[_TModel],
        select,
        from_list: Iterable[object],
        joins: Mapping[Hashable, Tuple[object, object, Callable[..., _TModel], int]],
    ): ...
    def initialize(self) -> None: ...
    def process_row(self, row: tuple) -> _TModel: ...  # type: ignore

class __PrefetchQuery(NamedTuple):
    query: Query  # TODO (dargueta): Verify
    fields: Optional[Sequence[Field]]
    is_backref: Optional[bool]
    rel_models: Optional[List[Type[Model]]]
    field_to_name: Optional[List[Tuple[Field, str]]]
    model: Type[Model]

class PrefetchQuery(__PrefetchQuery):
    def populate_instance(self, instance: Model, id_map: Mapping[Tuple[object, object], object]): ...
    def store_instance(self, instance: Model, id_map: MutableMapping[Tuple[object, object], List[Model]]) -> None: ...

def prefetch_add_subquery(sq: Query, subqueries: Iterable[_TSubquery]) -> List[PrefetchQuery]: ...
def prefetch(sq: Query, *subqueries: _TSubquery) -> List[object]: ...
