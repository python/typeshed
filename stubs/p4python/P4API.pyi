#
# See:
#   - https://github.com/perforce/p4python/blob/master/P4API.cpp
#   - https://github.com/perforce/p4python/blob/master/PythonClientAPI.cpp

from logging import Logger
from typing import Any, Literal, Self, TypeAlias, TypedDict

import P4

def identify() -> str: ...
def dvcs_init(
    user: str | None = None,
    client: str | None = None,
    directory: str | None = None,
    port: str | None = None,
    casesensitive: bool | None = None,
    unicode: bool | None = None,
) -> P4.P4: ...
def dvcs_clone(
    user: str | None = None,
    client: str | None = None,
    directory: str | None = None,
    depth: int | None = None,
    verbose: bool | None = None,
    port: str | None = None,
    remote: str | None = None,
    file: str | None = None,
    noarchive: bool | None = None,
    progress: P4.Progress | None = None,
) -> P4.P4: ...

class P4Adapter:
    def connect(self) -> Self: ...
    def connected(self) -> bool: ...
    def disconnect(self) -> None: ...
    def env(self, var: str, /) -> str | None: ...
    def set_env(self, var: str, val: str | None = None, /) -> None: ...
    def run(self, cmd: str, /, *args: Any) -> Any: ...
    def format_spec(self, type_: str, dict_: dict[str, Any], /) -> str: ...
    def parse_spec(self, type_: str, form: str, /) -> P4.Spec | dict[str, Any] | Literal[False]: ...
    def define_spec(self, type_: str, spec: str, /) -> None: ...
    def protocol(self, var: str, val: str | None = None, /) -> None: ...
    def disable_tmp_cleanup(self) -> None: ...
    def is_ignored(self, path: str, /) -> bool | None: ...
    def set_tunable(self, tunable: str, value: str, /) -> str | None: ...
    def get_tunable(self, tunable: str, /) -> str | Literal[0]: ...
    def setbreak(self, keepalive: P4.PyKeepAlive, /) -> None: ...

    # From PythonClientAPI::intattributes
    @property
    def tagged(self) -> int: ...
    @tagged.setter
    def tagged(self, value: bool | int) -> None: ...
    api_level: int
    maxresults: int
    maxscanrows: int
    maxlocktime: int
    maxopenfiles: int
    maxmemory: int
    exception_level: RAISE_ALL | RAISE_ERRORS | RAISE_NONE
    @property
    def debug(self) -> int: ...
    @debug.setter
    def debug(self, value: bool | int) -> None: ...
    @property
    def track(self) -> int: ...
    @track.setter
    def track(self, value: bool | int) -> None: ...
    @property
    def streams(self) -> int: ...
    @streams.setter
    def streams(self, value: bool | int) -> None: ...
    @property
    def graph(self) -> int: ...
    @graph.setter
    def graph(self, value: bool | int) -> None: ...
    @property
    def case_folding(self) -> int: ...
    @case_folding.setter
    def case_folding(self, value: bool | int) -> None: ...

    # From PythonClientAPI::strattributes
    charset: str
    client: str
    @property
    def p4config_file(self) -> str | None: ...
    p4enviro_file: str
    cwd: str
    host: str
    ignore_file: str
    language: str
    port: str
    prog: str
    ticket_file: str
    password: str
    user: str
    version: str
    @property
    def PATCHLEVEL(self) -> str: ...
    @property
    def OS(self) -> str: ...
    encoding: str

    # From PythonClientAPI::objattributes
    input: object | None
    resolver: P4.Resolver | None
    handler: P4.OutputHandler | None
    progress: P4.Progress | None
    @property
    def errors(self) -> list[str]: ...
    @property
    def warnings(self) -> list[str]: ...
    @property
    def messages(self) -> list[str | P4Message]: ...
    @property
    def p4config_files(self) -> list[str]: ...
    @property
    def track_output(self) -> list[str]: ...
    @property
    def server_level(self) -> int | None: ...
    @property
    def server_case_insensitive(self) -> bool | None: ...
    @property
    def server_unicode(self) -> bool | None: ...
    logger: Logger | None

class P4Map:
    def insert(self, lhs: str, rhs: str | None = None, /) -> None: ...
    def clear(self) -> None: ...
    def translate(self, path: str, left_to_right: bool | Literal[0, 1] = True, /) -> str | None: ...
    def translate_array(self, path: str, left_to_right: bool | Literal[0, 1] = True, /) -> list[str] | None: ...
    def count(self) -> int: ...
    def reverse(self) -> P4Map: ...
    def lhs(self) -> list[str]: ...
    def rhs(self) -> list[str]: ...
    def as_array(self) -> list[str]: ...
    @classmethod
    def join(cls, left: P4Map, right: P4Map) -> P4Map: ...

class P4ActionMergeData:
    @property
    def merge_action(self) -> str: ...
    @property
    def yours_action(self) -> str: ...
    @property
    def their_action(self) -> str: ...
    @property
    def type(self) -> str: ...
    @property
    def merge_hint(self) -> ResolveAction: ...
    @property
    def info(self) -> P4MergeDataInfo | None: ...

class P4MergeDataInfo(TypedDict):
    clientFile: str
    fromFile: str
    startFromRev: str
    endFromRev: str
    resolveFlag: str
    resolveType: str

class P4MergeData:
    @property
    def your_name(self) -> str: ...
    @property
    def their_name(self) -> str: ...
    @property
    def base_name(self) -> str | None: ...
    @property
    def your_path(self) -> str: ...
    @property
    def their_path(self) -> str | None: ...
    @property
    def base_path(self) -> str | None: ...
    @property
    def result_path(self) -> str | None: ...
    @property
    def merge_hint(self) -> ResolveAction: ...
    def run_merge(self) -> bool: ...

ResolveAction: TypeAlias = Literal["ay", "at", "am", "ae", "s", "q"]

class P4Message:
    @property
    def severity(self) -> E_EMPTY | E_INFO | E_WARN | E_FAILED | E_FATAL: ...
    @property
    def generic(self) -> int: ...
    @property
    def msgid(self) -> int: ...
    @property
    def dict(self) -> dict[str, str]: ...

RAISE_ALL: TypeAlias = Literal[2]
RAISE_ERRORS: TypeAlias = Literal[1]
RAISE_NONE: TypeAlias = Literal[0]

E_EMPTY: TypeAlias = Literal[0]
E_INFO: TypeAlias = Literal[1]
E_WARN: TypeAlias = Literal[2]
E_FAILED: TypeAlias = Literal[3]
E_FATAL: TypeAlias = Literal[4]
