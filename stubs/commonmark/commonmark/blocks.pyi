import re
from typing import Any, Final, Literal

from .inlines import InlineParser
from .node import Node

CODE_INDENT: Final[int]
reHtmlBlockOpen: Final[list[re.Pattern[str]]]
reHtmlBlockClose: Final[list[re.Pattern[str]]]
reThematicBreak: Final[re.Pattern[str]]
reMaybeSpecial: Final[re.Pattern[str]]
reNonSpace: Final[re.Pattern[str]]
reBulletListMarker: Final[re.Pattern[str]]
reOrderedListMarker: Final[re.Pattern[str]]
reATXHeadingMarker: Final[re.Pattern[str]]
reCodeFence: Final[re.Pattern[str]]
reClosingCodeFence: Final[re.Pattern[str]]
reSetextHeadingLine: Final[re.Pattern[str]]
reLineEnding: Final[re.Pattern[str]]

def is_blank(s: str) -> bool: ...
def is_space_or_tab(s: str) -> bool: ...
def peek(ln: str, pos: int) -> str | None: ...
def ends_with_blank_line(block: Node) -> bool: ...
def parse_list_marker(parser: Parser, container: Node) -> dict[str, Any] | None: ...
def lists_match(list_data: dict[str, Any], item_data: dict[str, Any]) -> bool: ...

class Block:
    accepts_lines: bool | None
    @staticmethod
    def continue_(parser: Parser | None = None, container: Node | None = None) -> int | None: ...
    @staticmethod
    def finalize(parser: Parser | None = None, block: Node | None = None) -> None: ...
    @staticmethod
    def can_contain(t: str) -> bool | None: ...

class Document(Block):
    accepts_lines: Literal[False]
    @staticmethod
    def continue_(parser: Parser | None = None, container: Node | None = None) -> Literal[0]: ...
    @staticmethod
    def finalize(parser: Parser | None = None, block: Node | None = None) -> None: ...
    @staticmethod
    def can_contain(t: str) -> bool: ...

class List(Block):
    accepts_lines: Literal[False]
    @staticmethod
    def continue_(parser: Parser | None = None, container: Node | None = None) -> Literal[0]: ...
    @staticmethod
    def finalize(parser: Parser | None = None, block: Node | None = None) -> None: ...
    @staticmethod
    def can_contain(t: str) -> bool: ...

class BlockQuote(Block):
    accepts_lines: Literal[False]
    @staticmethod
    def continue_(parser: Parser | None = None, container: Node | None = None) -> Literal[0, 1]: ...
    @staticmethod
    def finalize(parser: Parser | None = None, block: Node | None = None) -> None: ...
    @staticmethod
    def can_contain(t: str) -> bool: ...

class Item(Block):
    accepts_lines: Literal[False]
    @staticmethod
    def continue_(parser: Parser | None = None, container: Node | None = None) -> Literal[0, 1]: ...
    @staticmethod
    def finalize(parser: Parser | None = None, block: Node | None = None) -> None: ...
    @staticmethod
    def can_contain(t: str) -> bool: ...

class Heading(Block):
    accepts_lines: Literal[False]
    @staticmethod
    def continue_(parser: Parser | None = None, container: Node | None = None) -> Literal[1]: ...
    @staticmethod
    def finalize(parser: Parser | None = None, block: Node | None = None) -> None: ...
    @staticmethod
    def can_contain(t: str) -> Literal[False]: ...

class ThematicBreak(Block):
    accepts_lines: Literal[False]
    @staticmethod
    def continue_(parser: Parser | None = None, container: Node | None = None) -> Literal[1]: ...
    @staticmethod
    def finalize(parser: Parser | None = None, block: Node | None = None) -> None: ...
    @staticmethod
    def can_contain(t: str) -> Literal[False]: ...

class CodeBlock(Block):
    accepts_lines: Literal[True]
    @staticmethod
    def continue_(parser: Parser | None = None, container: Node | None = None) -> Literal[0, 1, 2]: ...
    @staticmethod
    def finalize(parser: Parser | None = None, block: Node | None = None) -> None: ...
    @staticmethod
    def can_contain(t: str) -> Literal[False]: ...

class HtmlBlock(Block):
    accepts_lines: Literal[True]
    @staticmethod
    def continue_(parser: Parser | None = None, container: Node | None = None) -> Literal[0, 1]: ...
    @staticmethod
    def finalize(parser: Parser | None = None, block: Node | None = None) -> None: ...
    @staticmethod
    def can_contain(t: str) -> Literal[False]: ...

class Paragraph(Block):
    accepts_lines: Literal[True]
    @staticmethod
    def continue_(parser: Parser | None = None, container: Node | None = None) -> Literal[0, 1]: ...
    @staticmethod
    def finalize(parser: Parser | None = None, block: Node | None = None) -> None: ...
    @staticmethod
    def can_contain(t: str) -> Literal[False]: ...

class BlockStarts:
    METHODS: list[str]
    @staticmethod
    def block_quote(parser: Parser, container: Node | None = None) -> Literal[0, 1]: ...
    @staticmethod
    def atx_heading(parser: Parser, container: Node | None = None) -> Literal[0, 2]: ...
    @staticmethod
    def fenced_code_block(parser: Parser, container: Node | None = None) -> Literal[0, 2]: ...
    @staticmethod
    def html_block(parser: Parser, container: Node | None = None) -> Literal[0, 2]: ...
    @staticmethod
    def setext_heading(parser: Parser, container: Node | None = None) -> Literal[0, 2]: ...
    @staticmethod
    def thematic_break(parser: Parser, container: Node | None = None) -> Literal[0, 2]: ...
    @staticmethod
    def list_item(parser: Parser, container: Node | None = None) -> Literal[0, 1]: ...
    @staticmethod
    def indented_code_block(parser: Parser, container: Node | None = None) -> Literal[0, 2]: ...

class Parser:
    doc: Node
    block_starts: BlockStarts
    tip: Node
    oldtip: Node
    current_line: str
    line_number: int
    offset: int
    column: int
    next_nonspace: int
    next_nonspace_column: int
    indent: int
    indented: bool
    blank: bool
    partially_consumed_tab: bool
    all_closed: bool
    last_matched_container: Node
    refmap: dict[str, Any]
    last_line_length: int
    inline_parser: InlineParser
    options: dict[str, Any]
    blocks: dict[str, Block]
    def __init__(self, options: dict[str, Any] = {}) -> None: ...
    def add_line(self) -> None: ...
    def add_child(self, tag: str, offset: int) -> Node: ...
    def close_unmatched_blocks(self) -> None: ...
    def find_next_nonspace(self) -> None: ...
    def advance_next_nonspace(self) -> None: ...
    def advance_offset(self, count: int, columns: bool) -> None: ...
    def incorporate_line(self, ln: str) -> None: ...
    def finalize(self, block: Node, line_number: int) -> None: ...
    def process_inlines(self, block: Node) -> None: ...
    def parse(self, my_input: str) -> Node: ...

CAMEL_RE: Final[re.Pattern[str]]
