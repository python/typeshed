import datetime
import traceback
from collections.abc import Sequence
from typing import IO
from typing_extensions import Self

from . import olefile

__date__: str
__version__: str
__author__: str

DEFAULT_PATH_ENCODING: str | None

def enable_logging() -> None: ...

MAGIC: bytes

MAXREGSECT: int
DIFSECT: int
FATSECT: int
ENDOFCHAIN: int
FREESECT: int

MAXREGSID: int
NOSTREAM: int

STGTY_EMPTY: int
STGTY_STORAGE: int
STGTY_STREAM: int
STGTY_LOCKBYTES: int
STGTY_PROPERTY: int
STGTY_ROOT: int

UNKNOWN_SIZE: int

WORD_CLSID: str
DEFECT_UNSURE: int
DEFECT_POTENTIAL: int
DEFECT_INCORRECT: int
DEFECT_FATAL: int = 40
MINIMAL_OLEFILE_SIZE: int

def isOleFile(filename: IO[bytes] | bytes | str | None = None, data: bytes | None = None) -> bool: ...

class OleMetadata:
    SUMMARY_ATTRIBS: list[str]
    DOCSUM_ATTRIBS: list[str]

    def __init__(self) -> None: ...
    def parse_properties(self, ole_file: OleFileIO) -> None: ...
    def dump(self) -> None: ...

class OleFileIONotClosed(RuntimeWarning):
    def __init__(self, stack_of_open: traceback.FrameSummary | None = None) -> None: ...

class OleFileIO:
    def __init__(
        self,
        filename: IO[bytes] | bytes | str | None = None,
        raise_defects: int = 40,
        write_mode: bool = False,
        debug: bool = False,
        path_encoding: str | None = DEFAULT_PATH_ENCODING,  # noqaY011
    ) -> None: ...
    def __del__(self) -> None: ...
    def __enter__(self) -> Self: ...
    def __exit__(self, *args: object) -> None: ...
    def _raise_defect(
        self, defect_level: int, message: str, exception_type: type[Exception] = olefile.OleFileError  # noqaY011
    ) -> None: ...
    def _decode_utf16_str(self, utf16_str: bytes, errors: str = "replace") -> bytes: ...
    def open(self, filename: IO[bytes] | bytes | str, write_mode: bool = False) -> None: ...
    def close(self) -> None: ...
    def _close(self, warn: bool = False) -> None: ...
    def _check_duplicate_stream(self, first_sect: int, minifat: bool = False) -> None: ...
    def dumpfat(self, fat: Sequence[int], firstindex: int = 0) -> None: ...
    def dumpsect(self, sector: bytes, firstindex: int = 0) -> None: ...
    def sect2array(self, sect: bytes) -> Sequence[int]: ...
    def loadfat_sect(self, sect: bytes | list[int]) -> int | None: ...
    def loadfat(self, header: bytes) -> None: ...
    def loadminifat(self) -> None: ...
    def getsect(self, sect: int) -> bytes: ...
    def write_sect(self, sect: int, data: bytes, padding: bytes = b"\x00") -> None: ...
    def _write_mini_sect(self, fp_pos: int, data: bytes, padding: bytes = b"\x00") -> None: ...
    def loaddirectory(self, sect: int) -> None: ...
    def _load_direntry(self, sid: int) -> olefile.OleDirectoryEntry: ...
    def dumpdirectory(self) -> None: ...
    def _open(self, start: int, size: int = 0x7FFFFFFF, force_FAT: bool = False) -> olefile.OleStream: ...
    def _list(
        self,
        files: list[list[bytes]],
        prefix: list[bytes],
        node: olefile.OleDirectoryEntry,
        streams: bool = True,
        storages: bool = False,
    ) -> None: ...
    def listdir(self, streams: bool = True, storages: bool = False) -> list[list[bytes]]: ...
    def _find(self, filename: str | Sequence[str]) -> int: ...
    def openstream(self, filename: str | Sequence[str]) -> olefile.OleStream: ...
    def _write_mini_stream(self, entry: olefile.OleDirectoryEntry, data_to_write: bytes) -> None: ...
    def write_stream(self, stream_name: str | Sequence[str], data: bytes) -> None: ...
    def get_type(self, filename: str | Sequence[str]) -> bool | int: ...
    def getclsid(self, filename: str | Sequence[str]) -> str: ...
    def getmtime(self, filename: str | Sequence[str]) -> datetime.datetime | None: ...
    def getctime(self, filename: str | Sequence[str]) -> datetime.datetime | None: ...
    def exists(self, filename: str | Sequence[str]) -> bool: ...
    def get_size(self, filename: str | Sequence[str]) -> int: ...
    def get_rootentry_name(self) -> bytes: ...
    def getproperties(
        self, filename: str | Sequence[str], convert_time: bool = False, no_conversion: list[int] | None = None
    ) -> dict[int, list[int | str | bytes | bool | None]]: ...
    def _parse_property(
        self, s: bytes, offset: int, property_id: int, property_type: int, convert_time: bool, no_conversion: list[int]
    ) -> list[int | str | bytes | bool | None] | None: ...
    def _parse_property_basic(
        self, s: bytes, offset: int, property_id: int, property_type: int, convert_time: bool, no_conversion: list[int]
    ) -> tuple[int | str | bytes | bool | None, int]: ...
    def get_metadata(self) -> OleMetadata: ...
    def get_userdefined_properties(
        self, filename: str | Sequence[str], convert_time: bool = False, no_conversion: list[int] | None = None
    ) -> list[dict[str, bytes | int | None]]: ...
