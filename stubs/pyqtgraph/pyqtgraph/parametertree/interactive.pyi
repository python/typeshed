import contextlib
from _typeshed import Incomplete
from collections.abc import Generator

class PARAM_UNSET: ...

class RunOptions:
    ON_ACTION: str
    ON_CHANGED: str
    ON_CHANGING: str

class InteractiveFunction:
    __qualname__: str
    parameters: Incomplete
    extra: Incomplete
    function: Incomplete
    closures: Incomplete
    parametersNeedRunKwargs: bool
    parameterCache: Incomplete
    def __init__(self, function, *, closures=None, **extra) -> None: ...
    def __call__(self, **kwargs): ...
    def updateCachedParameterValues(self, param, value) -> None: ...
    def hookupParameters(self, params=None, clearOld: bool = True) -> None: ...
    def removeParameters(self, clearCache: bool = True) -> None: ...
    def runFromChangedOrChanging(self, param, value): ...
    def runFromAction(self, **kwargs): ...
    def disconnect(self): ...
    def setDisconnected(self, disconnected): ...
    def reconnect(self): ...

class Interactor:
    runOptions: Incomplete
    parent: Incomplete
    titleFormat: Incomplete
    nest: bool
    existOk: bool
    runActionTemplate: Incomplete
    def __init__(self, **kwargs) -> None: ...
    def setOpts(self, **opts): ...
    @contextlib.contextmanager
    def optsContext(self, **opts) -> Generator[None]: ...
    def interact(
        self,
        function,
        *,
        ignores=None,
        runOptions=...,
        parent=...,
        titleFormat=...,
        nest=...,
        runActionTemplate=...,
        existOk=...,
        **overrides,
    ): ...
    def __call__(self, function, **kwargs): ...
    def decorate(self, **kwargs): ...
    def resolveAndHookupParameterChild(self, functionGroup, childOpts, interactiveFunction): ...
    def functionToParameterDict(self, function, **overrides): ...
    def createFunctionParameter(self, name, signatureParameter, overridesInfo): ...
    def getOpts(self): ...

interact: Incomplete
