from _typeshed import Incomplete

from .Qt import QtGui

__all__ = [
    "siScale",
    "siFormat",
    "siParse",
    "siEval",
    "siApply",
    "Color",
    "mkColor",
    "mkBrush",
    "mkPen",
    "hsvColor",
    "CIELabColor",
    "colorCIELab",
    "colorDistance",
    "colorTuple",
    "colorStr",
    "intColor",
    "glColor",
    "makeArrowPath",
    "eq",
    "affineSliceCoords",
    "affineSlice",
    "interweaveArrays",
    "interpolateArray",
    "subArray",
    "transformToArray",
    "transformCoordinates",
    "solve3DTransform",
    "solveBilinearTransform",
    "clip_scalar",
    "clip_array",
    "rescaleData",
    "applyLookupTable",
    "makeRGBA",
    "makeARGB",
    "makeQImage",
    "imageToArray",
    "colorToAlpha",
    "gaussianFilter",
    "downsample",
    "arrayToQPath",
    "isocurve",
    "traceImage",
    "isosurface",
    "invertQTransform",
    "pseudoScatter",
    "toposort",
    "disconnect",
    "SignalBlock",
]

def siScale(x, minVal: float = 1e-25, allowUnicode: bool = True): ...
def siFormat(
    x, precision: int = 3, suffix: str = "", space: bool = True, error=None, minVal: float = 1e-25, allowUnicode: bool = True
): ...
def siParse(s, regex=..., suffix=None): ...
def siEval(s, typ=..., regex=..., suffix=None): ...
def siApply(val, siprefix): ...

class Color(QtGui.QColor):
    def __init__(self, *args) -> None: ...
    def glColor(self): ...
    def __getitem__(self, ind): ...

def mkColor(*args): ...
def mkBrush(*args, **kwds): ...
def mkPen(*args, **kargs): ...
def hsvColor(hue, sat: float = 1.0, val: float = 1.0, alpha: float = 1.0): ...
def CIELabColor(L, a, b, alpha: float = 1.0): ...
def colorCIELab(qcol): ...
def colorDistance(colors, metric: str = "CIE76"): ...
def colorTuple(c): ...
def colorStr(c): ...
def intColor(
    index,
    hues: int = 9,
    values: int = 1,
    maxValue: int = 255,
    minValue: int = 150,
    maxHue: int = 360,
    minHue: int = 0,
    sat: int = 255,
    alpha: int = 255,
): ...
def glColor(*args, **kargs): ...
def makeArrowPath(
    headLen: int = 20, headWidth=None, tipAngle: int = 20, tailLen: int = 20, tailWidth: int = 3, baseAngle: int = 0
): ...
def eq(a, b): ...
def affineSliceCoords(shape, origin, vectors, axes): ...
def affineSlice(data, shape, origin, vectors, axes, order: int = 1, returnCoords: bool = False, **kargs): ...
def interweaveArrays(*args): ...
def interpolateArray(data, x, default: float = 0.0, order: int = 1): ...
def subArray(data, offset, shape, stride): ...
def transformToArray(tr): ...
def transformCoordinates(tr, coords, transpose: bool = False): ...
def solve3DTransform(points1, points2): ...
def solveBilinearTransform(points1, points2): ...
def clip_scalar(val, vmin, vmax): ...
def clip_array(arr, vmin, vmax, out=None): ...

clip_array: Incomplete

def rescaleData(data, scale, offset, dtype=None, clip=None): ...
def applyLookupTable(data, lut): ...
def makeRGBA(*args, **kwds): ...
def makeARGB(data, lut=None, levels=None, scale=None, useRGBA: bool = False, maskNans: bool = True, output=None): ...
def makeQImage(imgData, alpha=None, copy: bool = True, transpose: bool = True): ...
def imageToArray(img, copy: bool = False, transpose: bool = True): ...
def colorToAlpha(data, color): ...
def gaussianFilter(data, sigma): ...
def downsample(data, n, axis: int = 0, xvals: str = "subsample"): ...
def arrayToQPath(x, y, connect: str = "all", finiteCheck: bool = True): ...
def isocurve(data, level, connected: bool = False, extendToEdge: bool = False, path: bool = False): ...
def traceImage(image, values, smooth: float = 0.5): ...
def isosurface(data, level): ...
def invertQTransform(tr): ...
def pseudoScatter(data, spacing=None, shuffle: bool = True, bidir: bool = False, method: str = "exact"): ...
def toposort(deps, nodes=None, seen=None, stack=None, depth: int = 0): ...
def disconnect(signal, slot): ...

class SignalBlock:
    signal: Incomplete
    slot: Incomplete
    def __init__(self, signal, slot) -> None: ...
    reconnect: Incomplete
    def __enter__(self): ...
    def __exit__(self, *args) -> None: ...
