import datetime
import io
from _typeshed import (
    ExcInfo,
    Incomplete,
    ReadableBuffer,
    SupportsItems,
    SupportsKeysAndGetItem,
    SupportsNoArgReadline,
    SupportsRead,
)
from cgi import FieldStorage
from collections.abc import Iterable, Iterator, Mapping
from re import Pattern
from tempfile import _TemporaryFileWrapper
from typing import IO, Any, ClassVar, Literal, Protocol, TypeVar, overload
from typing_extensions import Self, TypeAlias, TypedDict

from webob.acceptparse import _AcceptCharsetProperty, _AcceptEncodingProperty, _AcceptLanguageProperty, _AcceptProperty
from webob.cachecontrol import _RequestCacheControl
from webob.cookies import RequestCookies
from webob.descriptors import _authorization, _DateProperty
from webob.etag import IfRange, IfRangeDate, _ETagProperty
from webob.headers import EnvironHeaders
from webob.multidict import GetDict, MultiDict, NestedMultiDict, NoVars
from webob.response import Response, _HTTPHeader, _WSGIApplication

_T = TypeVar("_T")
_HTTPMethod: TypeAlias = Literal["GET", "HEAD", "POST", "PUT", "DELETE", "PATCH"]
_ListOrTuple: TypeAlias = list[_T] | tuple[_T, ...]

class _SupportsReadAndNoArgReadline(SupportsRead[bytes], SupportsNoArgReadline[bytes], Protocol): ...

class _RequestCacheControlDict(TypedDict, total=False):
    max_stale: int
    min_stale: int
    only_if_cached: bool
    no_cache: Literal[True] | str
    no_store: bool
    no_transform: bool
    max_age: int

class _NoDefault: ...

NoDefault: TypeAlias = _NoDefault

class BaseRequest:
    request_body_tempfile_limit: ClassVar[int]
    method: _HTTPMethod
    def __init__(self, environ: dict[str, Any], **kw: Any) -> None: ...
    def encget(self, key: str, default: Any = ..., encattr: str | None = ...) -> Any: ...
    def encset(self, key: str, val: Any, encattr: str | None = ...) -> None: ...
    @property
    def charset(self) -> str | None: ...
    def decode(self, charset: str | None = ..., errors: str = ...) -> Self: ...
    @property
    def body_file(self) -> SupportsRead[bytes]: ...
    @body_file.setter
    def body_file(self, value: SupportsRead[bytes]) -> None: ...
    content_length: int | None
    body_file_raw: SupportsRead[bytes]
    is_body_seekable: bool
    @property
    def body_file_seekable(self) -> IO[bytes]: ...
    url_encoding: str
    @property
    def scheme(self) -> str | None: ...
    @scheme.setter
    def scheme(self, value: str | None) -> None: ...
    @property
    def http_version(self) -> str | None: ...
    @http_version.setter
    def http_version(self, value: str | None) -> None: ...
    remote_user: str | None
    remote_host: str | None
    remote_addr: str | None
    query_string: str
    @property
    def server_name(self) -> str | None: ...
    @server_name.setter
    def server_name(self, value: str | None) -> None: ...
    @property
    def server_port(self) -> int | None: ...
    @server_port.setter
    def server_port(self, value: int | None) -> None: ...
    script_name: str
    @property
    def path_info(self) -> str | None: ...
    @path_info.setter
    def path_info(self, value: str | None) -> None: ...
    uscript_name: str  # bw compat
    upath_info = path_info  # bw compat
    content_type: str | None
    @property
    def headers(self) -> EnvironHeaders: ...
    @headers.setter
    @overload
    def headers(self, value: SupportsItems[str, str]) -> None: ...
    @headers.setter
    @overload
    def headers(self, value: Iterable[tuple[str, str]]) -> None: ...
    @property
    def client_addr(self) -> str | None: ...
    @property
    def host_port(self) -> str: ...
    @property
    def host_url(self) -> str: ...
    @property
    def application_url(self) -> str: ...
    @property
    def path_url(self) -> str: ...
    @property
    def path(self) -> str: ...
    @property
    def path_qs(self) -> str: ...
    @property
    def url(self) -> str: ...
    def relative_url(self, other_url: str, to_application: bool = ...) -> str: ...
    def path_info_pop(self, pattern: Pattern[str] | None = ...) -> str | None: ...
    def path_info_peek(self) -> str | None: ...
    urlvars: dict[str, str]
    urlargs: tuple[str]
    @property
    def is_xhr(self) -> bool: ...
    host: str
    @property
    def domain(self) -> str: ...
    body: bytes
    json: Any
    json_body: Any
    text: str
    @property
    def POST(self) -> MultiDict[str, str] | NoVars: ...
    @property
    def GET(self) -> GetDict: ...
    @property
    def params(self) -> NestedMultiDict[str, str]: ...
    @property
    def cookies(self) -> RequestCookies: ...
    @cookies.setter
    @overload
    def cookies(self, val: SupportsKeysAndGetItem[str, str]) -> None: ...
    @cookies.setter
    @overload
    def cookies(self, val: Iterable[tuple[str, str]]) -> None: ...
    def copy(self) -> Self: ...
    def copy_get(self) -> Self: ...
    @property
    def is_body_readable(self) -> bool: ...
    @is_body_readable.setter
    def is_body_readable(self, flag: bool) -> None: ...
    def make_body_seekable(self) -> None: ...
    def copy_body(self) -> None: ...
    def make_tempfile(self) -> _TemporaryFileWrapper: ...
    def remove_conditional_headers(
        self, remove_encoding: bool = ..., remove_range: bool = ..., remove_match: bool = ..., remove_modified: bool = ...
    ) -> None: ...
    accept: _AcceptProperty
    accept_charset: _AcceptCharsetProperty
    accept_encoding: _AcceptEncodingProperty
    accept_language: _AcceptLanguageProperty
    @property
    def authorization(self) -> _authorization | None: ...
    @authorization.setter
    @overload
    def authorization(self, value: str | bytes | None): ...
    @authorization.setter
    @overload
    def authorization(self, value: tuple[str, str | dict[str, str]]): ...
    @authorization.setter
    @overload
    def authorization(self, value: list[str | dict[str, str]]): ...
    @authorization.deleter
    def authorization(self) -> None: ...
    @property
    def cache_control(self) -> _RequestCacheControl: ...
    @cache_control.setter
    @overload
    def cache_control(self, value: str | bytes | None) -> None: ...
    @cache_control.setter
    @overload
    def cache_control(self, value: _RequestCacheControl) -> None: ...
    @cache_control.setter
    @overload
    def cache_control(self, value: _RequestCacheControlDict) -> None: ...
    if_match: _ETagProperty
    if_none_match: _ETagProperty
    date: _DateProperty[str]
    if_modified_since: _DateProperty[str]
    if_unmodified_since: _DateProperty[str]
    @property
    def if_range(self) -> IfRange | IfRangeDate: ...
    @if_range.setter
    @overload
    def if_range(self, value: str | None) -> None: ...
    @if_range.setter
    @overload
    def if_range(self, value: IfRange | IfRangeDate) -> None: ...
    @if_range.setter
    @overload
    def if_range(self, value: datetime.datetime | datetime.date) -> None: ...
    max_forwards: int | None
    pragma: str | None
    range: Incomplete
    referer: str | None
    referrer: str | None
    user_agent: str | None
    def as_bytes(self, skip_body: bool = ...) -> bytes: ...
    def as_text(self) -> str: ...
    @classmethod
    def from_bytes(cls, b: bytes) -> Self: ...
    @classmethod
    def from_text(cls, s: str) -> Self: ...
    @classmethod
    def from_file(cls, fp: _SupportsReadAndNoArgReadline): ...
    @overload
    def call_application(
        self, application: _WSGIApplication, catch_exc_info: Literal[False] = ...
    ) -> tuple[str, list[_HTTPHeader], Iterator[bytes]]: ...
    @overload
    def call_application(
        self, application: _WSGIApplication, catch_exc_info: Literal[True]
    ) -> tuple[str, list[_HTTPHeader], Iterator[bytes], ExcInfo | None]: ...
    ResponseClass: type[Response]
    def send(self, application: _WSGIApplication | None = ..., catch_exc_info: bool = ...) -> Response: ...
    get_response = send
    def make_default_send_app(self) -> _WSGIApplication: ...
    @classmethod
    def blank(
        cls,
        path,
        environ: dict[str, None] | None = ...,
        base_url: Incomplete | None = ...,
        headers: Mapping[str, str] | None = ...,
        POST: str | bytes | Mapping[Any, Any] | Mapping[Any, _ListOrTuple[Any]] | None = ...,
        **kw,
    ) -> Self: ...

class LegacyRequest(BaseRequest):
    uscript_name: Incomplete
    upath_info: Incomplete
    def encget(self, key, default=..., encattr: Incomplete | None = ...): ...

class AdhocAttrMixin:
    def __setattr__(self, attr: str, value: Any) -> None: ...
    def __getattr__(self, attr: str) -> Any: ...
    def __delattr__(self, attr: str) -> None: ...

class Request(AdhocAttrMixin, BaseRequest): ...
class DisconnectionError(IOError): ...

def environ_from_url(path: str) -> dict[str, Any]: ...
def environ_add_POST(
    env: dict[str, Any],
    data: str | bytes | Mapping[Any, Any] | Mapping[Any, _ListOrTuple[Any]] | None,
    content_type: str | None = ...,
) -> None: ...

class LimitedLengthFile(io.RawIOBase):
    file: SupportsRead[bytes]
    maxlen: int
    remaining: int
    def __init__(self, file: SupportsRead[bytes], maxlen: int) -> None: ...
    @staticmethod
    def readable() -> Literal[True]: ...
    def readinto(self, buff: ReadableBuffer) -> int: ...

class Transcoder:
    charset: str
    errors: str
    def __init__(self, charset: str, errors: str = ...) -> None: ...
    def transcode_query(self, q: str) -> str: ...
    def transcode_fs(self, fs: FieldStorage, content_type: str) -> io.BytesIO: ...
