from collections.abc import Callable
from typing import Final

from .error import MarkedYAMLError, _Mark
from .events import Event
from .loader import _Loader
from .main import YAML
from .resolver import BaseResolver
from .scanner import Scanner
from .tag import Tag, _TagHandleToPrefix
from .tokens import CommentToken, Token, _VersionTuple

__all__ = ["Parser", "RoundTripParser", "ParserError"]

class ParserError(MarkedYAMLError): ...

class Parser:
    DEFAULT_TAGS: Final[_TagHandleToPrefix]
    loader: YAML | _Loader
    def __init__(self, loader: YAML | _Loader) -> None: ...
    current_event: Event | None
    last_event: Event | None
    tag_handles: _TagHandleToPrefix
    states: list[Callable[[], Event]]
    marks: list[_Mark]
    state: Callable[[], Event]
    def reset_parser(self) -> None: ...
    def dispose(self) -> None: ...
    @property
    def scanner(self) -> Scanner: ...
    @property
    def resolver(self) -> BaseResolver: ...
    def check_event(self, *choices: type[Event]) -> bool: ...
    def peek_event(self) -> Event: ...
    def get_event(self) -> Event: ...
    def parse_stream_start(self) -> Event: ...
    def parse_implicit_document_start(self) -> Event: ...
    def parse_document_start(self) -> Event: ...
    def parse_document_end(self) -> Event: ...
    def parse_document_content(self) -> Event: ...
    def process_directives(self) -> tuple[_VersionTuple | None, _TagHandleToPrefix | None]: ...
    def parse_block_node(self) -> Event: ...
    def parse_flow_node(self) -> Event: ...
    def parse_block_node_or_indentless_sequence(self) -> Event: ...
    def select_tag_transform(self, tag: Tag) -> None: ...
    def parse_node(self, block: bool = False, indentless_sequence: bool = False) -> Event: ...
    def parse_block_sequence_first_entry(self) -> Event: ...
    def parse_block_sequence_entry(self) -> Event: ...
    def parse_indentless_sequence_entry(self) -> Event: ...
    def parse_block_mapping_first_key(self) -> Event: ...
    def parse_block_mapping_key(self) -> Event: ...
    def parse_block_mapping_value(self) -> Event: ...
    def parse_flow_sequence_first_entry(self) -> Event: ...
    def parse_flow_sequence_entry(self, first: bool = False) -> Event: ...
    def parse_flow_sequence_entry_mapping_key(self) -> Event: ...
    def parse_flow_sequence_entry_mapping_value(self) -> Event: ...
    def parse_flow_sequence_entry_mapping_end(self) -> Event: ...
    def parse_flow_mapping_first_key(self) -> Event: ...
    def parse_flow_mapping_key(self, first: bool = False) -> Event: ...
    def parse_flow_mapping_value(self) -> Event: ...
    def parse_flow_mapping_empty_value(self) -> Event: ...
    def process_empty_scalar(self, mark: _Mark, comment: list[CommentToken | None] | list[None] | None = None) -> Event: ...
    def move_token_comment(self, token: Token, nt: Token | None = None, empty: bool | None = False) -> None: ...

class RoundTripParser(Parser):
    def select_tag_transform(self, tag: Tag) -> None: ...
    def move_token_comment(self, token: Token, nt: Token | None = None, empty: bool | None = False) -> None: ...

class RoundTripParserSC(RoundTripParser):
    def move_token_comment(self, token: Token, nt: Token | None = None, empty: bool | None = False) -> None: ...
    def distribute_comment(self, comment: list[list[int] | None] | None, line: int) -> list[list[int] | None]: ...
