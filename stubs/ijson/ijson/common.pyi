from _typeshed import Incomplete, ReadableBuffer, SupportsRead
from collections.abc import Callable, Generator, Iterable, MutableMapping
from decimal import Decimal
from typing_extensions import TypeGuard

class JSONError(Exception): ...
class IncompleteJSONError(JSONError): ...

def parse_basecoro(target: Generator[Incomplete, tuple[str, str, Incomplete]]) -> Generator[None, None, None]: ...

class ObjectBuilder:
    value: Incomplete
    containers: list[Callable[[object], object]]
    map_type: type[MutableMapping[Incomplete, Incomplete]]
    def __init__(self, map_type: type[MutableMapping[Incomplete, Incomplete]] | None = None) -> None: ...
    key: Incomplete
    def event(self, event: str, value: Incomplete) -> None: ...

def items_basecoro(
    target: Generator[object, tuple[Incomplete, str, object]], prefix: Incomplete, map_type: Incomplete | None = None
) -> Generator[None, Incomplete]: ...
def kvitems_basecoro(target, prefix, map_type: Incomplete | None = None) -> Generator[None, Incomplete]: ...
def integer_or_decimal(str_value: str): ...
def integer_or_float(str_value: str) -> Decimal | int: ...
def number(str_value: str) -> int | float: ...
def file_source(f: SupportsRead[str] | SupportsRead[ReadableBuffer], buf_size: int = 65536) -> Generator[bytes]: ...
def is_awaitablefunction(func: Callable[..., Incomplete]) -> bool: ...
def is_async_file(f: Incomplete) -> bool: ...
def is_file(x: object) -> TypeGuard[SupportsRead[Incomplete]]: ...
def is_iterable(x: object) -> TypeGuard[Iterable[Incomplete]]: ...
def parse(events): ...
def kvitems(events, prefix, map_type: Incomplete | None = None): ...
def items(events, prefix, map_type: Incomplete | None = None): ...
def enrich_backend(backend: dict[str, Incomplete]) -> None: ...
