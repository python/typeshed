from collections import OrderedDict
from typing import Callable, Iterable, TypeVar
from typing_extensions import ParamSpec

from ijson._abstract_backend import _BackendModule

_P = ParamSpec("_P")
_T = TypeVar("_T")
_Benchmark = Callable[[int], bytes]

BACKEND_NAMES: tuple[str, ...]

def benchmark(f: _Benchmark) -> _Benchmark: ...
def long_list(n: int) -> bytes: ...
def big_int_object(n: int) -> bytes: ...
def big_decimal_object(n: int) -> bytes: ...
def big_null_object(n: int) -> bytes: ...
def big_bool_object(n: int) -> bytes: ...
def big_str_object(n: int) -> bytes: ...
def big_longstr_object(n: int) -> bytes: ...
def object_with_10_keys(n: int) -> bytes: ...
def empty_lists(n: int) -> bytes: ...
def empty_objects(n: int) -> bytes: ...
def parse_benchmarks(s: str) -> list[_Benchmark]: ...
def load_backends() -> OrderedDict[str, _BackendModule]: ...
def parse_backends(s: str) -> OrderedDict[str, _BackendModule]: ...

class progress_message:
    message: str
    def __init__(self, message: str) -> None: ...
    def __enter__(self): ...
    def __exit__(self, *args: object) -> None: ...

class AsyncReader:
    data: bytes
    def __init__(self, data: bytes) -> None: ...
    async def read(self, n: int = -1): ...
    def close(self) -> None: ...

def median(values: Iterable[int]) -> int: ...
def stats(values: Iterable[int]) -> int: ...
def run_benchmarks(args, benchmark_func: Callable[[int], bytes] | None = None, fname: str | None = None) -> None: ...
def main() -> None: ...
