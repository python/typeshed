from _typeshed import Incomplete
from io import StringIO as StringIO

from antlr4.atn.ATN import ATN as ATN
from antlr4.atn.ATNDeserializationOptions import ATNDeserializationOptions as ATNDeserializationOptions
from antlr4.atn.ATNState import *
from antlr4.atn.ATNType import ATNType as ATNType
from antlr4.atn.LexerAction import *
from antlr4.atn.Transition import *
from antlr4.Token import Token as Token

SERIALIZED_VERSION: int

class ATNDeserializer:
    deserializationOptions: Incomplete
    def __init__(self, options: ATNDeserializationOptions = ...) -> None: ...
    data: Incomplete
    pos: int
    def deserialize(self, data: list[int]) -> Incomplete: ...
    def checkVersion(self) -> None: ...
    def readATN(self) -> Incomplete: ...
    def readStates(self, atn: ATN) -> Incomplete: ...
    def readRules(self, atn: ATN) -> Incomplete: ...
    def readModes(self, atn: ATN) -> Incomplete: ...
    def readSets(self, atn: ATN, sets: list[Incomplete]) -> Incomplete: ...
    def readEdges(self, atn: ATN, sets: list[Incomplete]) -> Incomplete: ...
    def readDecisions(self, atn: ATN) -> Incomplete: ...
    def readLexerActions(self, atn: ATN) -> Incomplete: ...
    def generateRuleBypassTransitions(self, atn: ATN) -> Incomplete: ...
    def generateRuleBypassTransition(self, atn: ATN, idx: int) -> Incomplete: ...
    def stateIsEndStateFor(self, state: ATNState, idx: int) -> Incomplete: ...
    def markPrecedenceDecisions(self, atn: ATN) -> Incomplete: ...
    def verifyATN(self, atn: ATN) -> Incomplete: ...
    def checkCondition(self, condition: bool, message: Incomplete | None = ...) -> Incomplete: ...
    def readInt(self) -> Incomplete: ...
    edgeFactories: Incomplete
    def edgeFactory(self, atn: ATN, type: int, src: int, trg: int, arg1: int, arg2: int, arg3: int, sets: list[Incomplete]) -> Incomplete: ...
    stateFactories: Incomplete
    def stateFactory(self, type: int, ruleIndex: int) -> Incomplete: ...
    CHANNEL: int
    CUSTOM: int
    MODE: int
    MORE: int
    POP_MODE: int
    PUSH_MODE: int
    SKIP: int
    TYPE: int
    actionFactories: Incomplete
    def lexerActionFactory(self, type: int, data1: int, data2: int) -> Incomplete: ...
