from _typeshed import SupportsWrite
from typing import Any, Callable, Generic, Iterable, Mapping, MutableMapping, TypeVar

_T = TypeVar("_T")

def dump(o: Mapping[str, _T], f: SupportsWrite[str], encoder: TomlEncoder[_T] | None = ...) -> str: ...
def dumps(o: Mapping[str, _T], encoder: TomlEncoder[_T] | None = ...) -> str: ...

class TomlEncoder(Generic[_T]):
    _dict: type[Mapping[str, _T]]
    preserve: bool
    dump_funcs: MutableMapping[type[Any], Callable[[Any], str]]
    def __init__(self, _dict: type[Mapping[str, _T]] = ..., preserve: bool = ...) -> None: ...
    def get_empty_table(self) -> Mapping[str, _T]: ...
    def dump_list(self, v: Iterable[object]) -> str: ...
    def dump_inline_table(self, section: dict[str, Any] | Any) -> str: ...
    def dump_value(self, v: Any) -> str: ...
    def dump_sections(self, o: Mapping[str, _T], sup: str) -> tuple[str, Mapping[str, _T]]: ...

class TomlPreserveInlineDictEncoder(TomlEncoder[_T]):
    def __init__(self, _dict: type[Mapping[str, _T]] = ...) -> None: ...

class TomlArraySeparatorEncoder(TomlEncoder[_T]):
    separator: str
    def __init__(self, _dict: type[Mapping[str, _T]] = ..., preserve: bool = ..., separator: str = ...) -> None: ...
    def dump_list(self, v: Iterable[Any]) -> str: ...

class TomlNumpyEncoder(TomlEncoder[_T]): ...
class TomlPreserveCommentEncoder(TomlEncoder[_T]): ...
class TomlPathlibEncoder(TomlEncoder[_T]): ...
