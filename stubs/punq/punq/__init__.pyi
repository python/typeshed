from collections.abc import Callable
from enum import Enum
from typing import Any, Generic, NamedTuple, TypeVar, overload

__version__: str

class MissingDependencyException(Exception): ...
class MissingDependencyError(MissingDependencyException): ...
class InvalidRegistrationException(Exception): ...
class InvalidRegistrationError(InvalidRegistrationException): ...
class InvalidForwardReferenceException(Exception): ...
class InvalidForwardReferenceError(InvalidForwardReferenceException): ...

class Scope(Enum):
    transient = 0
    singleton = 1

_T = TypeVar("_T")
_TOpt = TypeVar("_TOpt", default=object)

class _Registration(NamedTuple, Generic[_T]):
    service: type[_T] | str
    scope: Scope
    builder: Callable[[], _T]
    needs: dict[str, object]
    args: dict[str, object]

empty: Any

class _Registry:
    def register_service_and_impl(
        self, service: type | str, scope: Scope, impl: Callable[..., object], resolve_args: dict[str, object]
    ) -> None: ...
    def register_service_and_instance(self, service: type[_T] | str, instance: _T) -> None: ...
    def register_concrete_service(self, service: type | str, scope: Scope) -> None: ...
    def build_context(self, key: type | str, existing: _ResolutionContext | None = None) -> _ResolutionContext: ...
    def register(
        self, service: type[_T] | str, factory: Callable[..., _T] = ..., instance: _T = ..., scope: Scope = ..., **kwargs: object
    ) -> None: ...
    def __getitem__(self, service: type[_T] | str) -> list[_Registration[_T]]: ...

class _ResolutionTarget(Generic[_T]):
    service: type[_T] | str
    impls: list[_Registration[_T]]
    def __init__(self, key: type[_T] | str, impls: list[_Registration[_T]]) -> None: ...
    def is_generic_list(self) -> bool: ...
    @property
    def generic_parameter(self) -> Any: ...
    def next_impl(self) -> _Registration[_T]: ...

class _ResolutionContext:
    targets: dict[type | str, _ResolutionTarget[object]]
    cache: dict[type | str, object]
    service: type | str
    def __init__(self, key: type | str, impls: list[_Registration[object]]) -> None: ...
    def target(self, key: type[_T] | str) -> _ResolutionTarget[_T]: ...
    def has_cached(self, key: type | str) -> bool: ...
    def __getitem__(self, key: type | str) -> object: ...
    def __setitem__(self, key: type | str, value: object) -> None: ...
    def all_registrations(self, service: type[_T] | str) -> list[_Registration[_T]]: ...

class Container:
    registrations: _Registry
    def __init__(self) -> None: ...
    @overload
    def register(self, service: type[_TOpt] | str, *, instance: _TOpt, **kwargs: Any) -> Container: ...
    @overload
    def register(
        self, service: type[_TOpt] | str, factory: Callable[..., _TOpt] = ..., *, scope: Scope = ..., **kwargs: Any
    ) -> Container: ...
    @overload
    def register(
        self,
        service: type[_TOpt] | str,
        factory: Callable[..., _TOpt] = ...,
        instance: _TOpt = ...,
        scope: Scope = Scope.transient,
        **kwargs: Any,
    ): ...
    def resolve_all(self, service: type[_TOpt] | str, **kwargs: Any) -> list[_TOpt]: ...
    def resolve(self, service_key: type[_TOpt] | str, **kwargs: Any) -> _TOpt: ...
    def instantiate(self, service_key: type[_TOpt] | str, **kwargs: Any) -> _TOpt: ...
