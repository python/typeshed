import itertools
import logging
import threading
from collections.abc import Generator
from typing import Any, NamedTuple

from pysqlite2 import dbapi2 as pysq3

sqlite3 = pysq3
sqlite3 = pysq3

class NullHandler(logging.Handler):
    def emit(self, record) -> None: ...

text_type = str
bytes_type = bytes
buffer_type = memoryview
basestring = str
long = int
izip_longest = itertools.zip_longest

class attrdict(dict):
    def __getattr__(self, attr): ...
    def __setattr__(self, attr, value) -> None: ...
    def __iadd__(self, rhs): ...
    def __add__(self, rhs): ...

OP: Any
DJANGO_MAP: Any
JOIN: Any

def chunked(it, n) -> Generator[Any, None, None]: ...

class _callable_context_manager:
    def __call__(self, fn): ...

class Proxy:
    def __init__(self) -> None: ...
    obj: Any
    def initialize(self, obj) -> None: ...
    def attach_callback(self, callback): ...
    def passthrough(method): ...
    __enter__: Any
    __exit__: Any
    def __getattr__(self, attr): ...
    def __setattr__(self, attr, value): ...

class DatabaseProxy(Proxy):
    def connection_context(self): ...
    def atomic(self, *args, **kwargs): ...
    def manual_commit(self): ...
    def transaction(self, *args, **kwargs): ...
    def savepoint(self): ...

class ModelDescriptor: ...

class AliasManager:
    def __init__(self) -> None: ...
    @property
    def mapping(self): ...
    def add(self, source): ...
    def get(self, source, any_depth: bool = ...): ...
    def __getitem__(self, source): ...
    def __setitem__(self, source, alias) -> None: ...
    def push(self) -> None: ...
    def pop(self) -> None: ...

class State:
    def __new__(cls, scope=..., parentheses: bool = ..., **kwargs): ...
    def __call__(self, scope: Any | None = ..., parentheses: Any | None = ..., **kwargs): ...
    def __getattr__(self, attr_name): ...

class Context:
    stack: Any
    alias_manager: Any
    state: Any
    def __init__(self, **settings) -> None: ...
    def as_new(self): ...
    def column_sort_key(self, item): ...
    @property
    def scope(self): ...
    @property
    def parentheses(self): ...
    @property
    def subquery(self): ...
    def __call__(self, **overrides): ...
    scope_normal: Any
    scope_source: Any
    scope_values: Any
    scope_cte: Any
    scope_column: Any
    def __enter__(self): ...
    def __exit__(self, exc_type, exc_val, exc_tb) -> None: ...
    def push_alias(self) -> Generator[None, None, None]: ...
    def sql(self, obj): ...
    def literal(self, keyword): ...
    def value(self, value, converter: Any | None = ..., add_param: bool = ...): ...
    def __sql__(self, ctx): ...
    def parse(self, node): ...
    def query(self): ...

class Node:
    def clone(self): ...
    def __sql__(self, ctx) -> None: ...
    @staticmethod
    def copy(method): ...
    def coerce(self, _coerce: bool = ...): ...
    def is_alias(self): ...
    def unwrap(self): ...

class ColumnFactory:
    node: Any
    def __init__(self, node) -> None: ...
    def __getattr__(self, attr): ...

class _DynamicColumn:
    def __get__(self, instance, instance_type: Any | None = ...): ...

class _ExplicitColumn:
    def __get__(self, instance, instance_type: Any | None = ...): ...

class Source(Node):
    c: Any
    def __init__(self, alias: Any | None = ...) -> None: ...
    def alias(self, name) -> None: ...
    def select(self, *columns): ...
    def join(self, dest, join_type=..., on: Any | None = ...): ...
    def left_outer_join(self, dest, on: Any | None = ...): ...
    def cte(self, name, recursive: bool = ..., columns: Any | None = ..., materialized: Any | None = ...): ...
    def get_sort_key(self, ctx): ...
    def apply_alias(self, ctx): ...
    def apply_column(self, ctx): ...

class _HashableSource:
    def __init__(self, *args, **kwargs) -> None: ...
    def alias(self, name) -> None: ...
    def __hash__(self): ...
    def __eq__(self, other): ...
    def __ne__(self, other): ...
    __lt__: Any
    __le__: Any
    __gt__: Any
    __ge__: Any

class BaseTable(Source):
    __and__: Any
    __add__: Any
    __sub__: Any
    __or__: Any
    __mul__: Any
    __rand__: Any
    __radd__: Any
    __rsub__: Any
    __ror__: Any
    __rmul__: Any

class _BoundTableContext(_callable_context_manager):
    table: Any
    database: Any
    def __init__(self, table, database) -> None: ...
    def __enter__(self): ...
    def __exit__(self, exc_type, exc_val, exc_tb) -> None: ...

class Table(_HashableSource, BaseTable):
    __name__: Any
    c: Any
    primary_key: Any
    def __init__(
        self,
        name,
        columns: Any | None = ...,
        primary_key: Any | None = ...,
        schema: Any | None = ...,
        alias: Any | None = ...,
        _model: Any | None = ...,
        _database: Any | None = ...,
    ) -> None: ...
    def clone(self): ...
    def bind(self, database: Any | None = ...): ...
    def bind_ctx(self, database: Any | None = ...): ...
    def select(self, *columns): ...
    def insert(self, insert: Any | None = ..., columns: Any | None = ..., **kwargs): ...
    def replace(self, insert: Any | None = ..., columns: Any | None = ..., **kwargs): ...
    def update(self, update: Any | None = ..., **kwargs): ...
    def delete(self): ...
    def __sql__(self, ctx): ...

class Join(BaseTable):
    lhs: Any
    rhs: Any
    join_type: Any
    def __init__(self, lhs, rhs, join_type=..., on: Any | None = ..., alias: Any | None = ...) -> None: ...
    def on(self, predicate): ...
    def __sql__(self, ctx): ...

class ValuesList(_HashableSource, BaseTable):
    def __init__(self, values, columns: Any | None = ..., alias: Any | None = ...) -> None: ...
    def columns(self, *names) -> None: ...
    def __sql__(self, ctx): ...

class CTE(_HashableSource, Source):
    def __init__(self, name, query, recursive: bool = ..., columns: Any | None = ..., materialized: Any | None = ...) -> None: ...
    def select_from(self, *columns): ...
    def union_all(self, rhs): ...
    __add__: Any
    def union(self, rhs): ...
    __or__: Any
    def __sql__(self, ctx): ...

class ColumnBase(Node):
    def converter(self, converter: Any | None = ...) -> None: ...
    def alias(self, alias): ...
    def unalias(self): ...
    def bind_to(self, dest): ...
    def cast(self, as_type): ...
    def asc(self, collation: Any | None = ..., nulls: Any | None = ...): ...
    __pos__: Any
    def desc(self, collation: Any | None = ..., nulls: Any | None = ...): ...
    __neg__: Any
    def __invert__(self): ...
    __and__: Any
    __or__: Any
    __add__: Any
    __sub__: Any
    __mul__: Any
    __div__: Any
    __truediv__: Any
    __xor__: Any
    __radd__: Any
    __rsub__: Any
    __rmul__: Any
    __rdiv__: Any
    __rtruediv__: Any
    __rand__: Any
    __ror__: Any
    __rxor__: Any
    def __eq__(self, rhs): ...
    def __ne__(self, rhs): ...
    __lt__: Any
    __le__: Any
    __gt__: Any
    __ge__: Any
    __lshift__: Any
    __rshift__: Any
    __mod__: Any
    __pow__: Any
    like: Any
    ilike: Any
    bin_and: Any
    bin_or: Any
    in_: Any
    not_in: Any
    regexp: Any
    def is_null(self, is_null: bool = ...): ...
    def contains(self, rhs): ...
    def startswith(self, rhs): ...
    def endswith(self, rhs): ...
    def between(self, lo, hi): ...
    def concat(self, rhs): ...
    def regexp(self, rhs): ...
    def iregexp(self, rhs): ...
    def __getitem__(self, item): ...
    __iter__: Any
    def distinct(self): ...
    def collate(self, collation): ...
    def get_sort_key(self, ctx): ...

class Column(ColumnBase):
    source: Any
    name: Any
    def __init__(self, source, name) -> None: ...
    def get_sort_key(self, ctx): ...
    def __hash__(self): ...
    def __sql__(self, ctx): ...

class WrappedNode(ColumnBase):
    node: Any
    def __init__(self, node) -> None: ...
    def is_alias(self): ...
    def unwrap(self): ...

class EntityFactory:
    node: Any
    def __init__(self, node) -> None: ...
    def __getattr__(self, attr): ...

class _DynamicEntity:
    def __get__(self, instance, instance_type: Any | None = ...): ...

class Alias(WrappedNode):
    c: Any
    def __init__(self, node, alias) -> None: ...
    def __hash__(self): ...
    @property
    def name(self): ...
    @name.setter
    def name(self, value) -> None: ...
    def alias(self, alias: Any | None = ...): ...
    def unalias(self): ...
    def is_alias(self): ...
    def __sql__(self, ctx): ...

class BindTo(WrappedNode):
    dest: Any
    def __init__(self, node, dest) -> None: ...
    def __sql__(self, ctx): ...

class Negated(WrappedNode):
    def __invert__(self): ...
    def __sql__(self, ctx): ...

class BitwiseMixin:
    def __and__(self, other): ...
    def __or__(self, other): ...
    def __sub__(self, other): ...
    def __invert__(self): ...

class BitwiseNegated(BitwiseMixin, WrappedNode):
    def __invert__(self): ...
    def __sql__(self, ctx): ...

class Value(ColumnBase):
    value: Any
    converter: Any
    multi: Any
    values: Any
    def __init__(self, value, converter: Any | None = ..., unpack: bool = ...) -> None: ...
    def __sql__(self, ctx): ...

class ValueLiterals(WrappedNode):
    def __sql__(self, ctx): ...

def AsIs(value): ...

class Cast(WrappedNode):
    def __init__(self, node, cast) -> None: ...
    def __sql__(self, ctx): ...

class Ordering(WrappedNode):
    direction: Any
    collation: Any
    nulls: Any
    def __init__(self, node, direction, collation: Any | None = ..., nulls: Any | None = ...) -> None: ...
    def collate(self, collation: Any | None = ...): ...
    def __sql__(self, ctx): ...

class Expression(ColumnBase):
    lhs: Any
    op: Any
    rhs: Any
    flat: Any
    def __init__(self, lhs, op, rhs, flat: bool = ...) -> None: ...
    def __sql__(self, ctx): ...

class StringExpression(Expression):
    def __add__(self, rhs): ...
    def __radd__(self, lhs): ...

class Entity(ColumnBase):
    def __init__(self, *path) -> None: ...
    def __getattr__(self, attr): ...
    def get_sort_key(self, ctx): ...
    def __hash__(self): ...
    def __sql__(self, ctx): ...

class SQL(ColumnBase):
    sql: Any
    params: Any
    def __init__(self, sql, params: Any | None = ...) -> None: ...
    def __sql__(self, ctx): ...

def Check(constraint, name: Any | None = ...): ...

class Function(ColumnBase):
    name: Any
    arguments: Any
    def __init__(self, name, arguments, coerce: bool = ..., python_value: Any | None = ...) -> None: ...
    def __getattr__(self, attr): ...
    def filter(self, where: Any | None = ...) -> None: ...
    def order_by(self, *ordering) -> None: ...
    def python_value(self, func: Any | None = ...) -> None: ...
    def over(
        self,
        partition_by: Any | None = ...,
        order_by: Any | None = ...,
        start: Any | None = ...,
        end: Any | None = ...,
        frame_type: Any | None = ...,
        window: Any | None = ...,
        exclude: Any | None = ...,
    ): ...
    def __sql__(self, ctx): ...

fn: Any

class Window(Node):
    CURRENT_ROW: Any
    GROUP: Any
    TIES: Any
    NO_OTHERS: Any
    GROUPS: str
    RANGE: str
    ROWS: str
    partition_by: Any
    order_by: Any
    start: Any
    end: Any
    frame_type: Any
    def __init__(
        self,
        partition_by: Any | None = ...,
        order_by: Any | None = ...,
        start: Any | None = ...,
        end: Any | None = ...,
        frame_type: Any | None = ...,
        extends: Any | None = ...,
        exclude: Any | None = ...,
        alias: Any | None = ...,
        _inline: bool = ...,
    ) -> None: ...
    def alias(self, alias: Any | None = ...): ...
    def as_range(self) -> None: ...
    def as_rows(self) -> None: ...
    def as_groups(self) -> None: ...
    def extends(self, window: Any | None = ...) -> None: ...
    def exclude(self, frame_exclusion: Any | None = ...) -> None: ...
    @staticmethod
    def following(value: Any | None = ...): ...
    @staticmethod
    def preceding(value: Any | None = ...): ...
    def __sql__(self, ctx): ...

class WindowAlias(Node):
    window: Any
    def __init__(self, window) -> None: ...
    def alias(self, window_alias): ...
    def __sql__(self, ctx): ...

class ForUpdate(Node):
    def __init__(self, expr, of: Any | None = ..., nowait: Any | None = ...) -> None: ...
    def __sql__(self, ctx): ...

def Case(predicate, expression_tuples, default: Any | None = ...): ...

class NodeList(ColumnBase):
    nodes: Any
    glue: Any
    parens: Any
    def __init__(self, nodes, glue: str = ..., parens: bool = ...) -> None: ...
    def __sql__(self, ctx): ...

class _Namespace(Node):
    def __init__(self, name) -> None: ...
    def __getattr__(self, attr): ...
    __getitem__: Any

class NamespaceAttribute(ColumnBase):
    def __init__(self, namespace, attribute) -> None: ...
    def __sql__(self, ctx): ...

EXCLUDED: Any

class DQ(ColumnBase):
    query: Any
    def __init__(self, **query) -> None: ...
    def __invert__(self) -> None: ...
    def clone(self): ...

Tuple: Any

class QualifiedNames(WrappedNode):
    def __sql__(self, ctx): ...

class OnConflict(Node):
    def __init__(
        self,
        action: Any | None = ...,
        update: Any | None = ...,
        preserve: Any | None = ...,
        where: Any | None = ...,
        conflict_target: Any | None = ...,
        conflict_where: Any | None = ...,
        conflict_constraint: Any | None = ...,
    ) -> None: ...
    def get_conflict_statement(self, ctx, query): ...
    def get_conflict_update(self, ctx, query): ...
    def preserve(self, *columns) -> None: ...
    def update(self, _data: Any | None = ..., **kwargs) -> None: ...
    def where(self, *expressions) -> None: ...
    def conflict_target(self, *constraints) -> None: ...
    def conflict_where(self, *expressions) -> None: ...
    def conflict_constraint(self, constraint) -> None: ...

class BaseQuery(Node):
    default_row_type: Any
    def __init__(self, _database: Any | None = ..., **kwargs) -> None: ...
    def bind(self, database: Any | None = ...): ...
    def clone(self): ...
    def dicts(self, as_dict: bool = ...): ...
    def tuples(self, as_tuple: bool = ...): ...
    def namedtuples(self, as_namedtuple: bool = ...): ...
    def objects(self, constructor: Any | None = ...): ...
    def __sql__(self, ctx) -> None: ...
    def sql(self): ...
    def execute(self, database): ...
    def iterator(self, database: Any | None = ...): ...
    def __iter__(self): ...
    def __getitem__(self, value): ...
    def __len__(self): ...

class RawQuery(BaseQuery):
    def __init__(self, sql: Any | None = ..., params: Any | None = ..., **kwargs) -> None: ...
    def __sql__(self, ctx): ...

class Query(BaseQuery):
    def __init__(
        self, where: Any | None = ..., order_by: Any | None = ..., limit: Any | None = ..., offset: Any | None = ..., **kwargs
    ) -> None: ...
    def with_cte(self, *cte_list) -> None: ...
    def where(self, *expressions) -> None: ...
    def orwhere(self, *expressions) -> None: ...
    def order_by(self, *values) -> None: ...
    def order_by_extend(self, *values) -> None: ...
    def limit(self, value: Any | None = ...) -> None: ...
    def offset(self, value: Any | None = ...) -> None: ...
    def paginate(self, page, paginate_by: int = ...) -> None: ...
    def __sql__(self, ctx): ...

class SelectQuery(Query):
    union_all: Any
    __add__: Any
    union: Any
    __or__: Any
    intersect: Any
    __and__: Any
    except_: Any
    __sub__: Any
    __radd__: Any
    __ror__: Any
    __rand__: Any
    __rsub__: Any
    def select_from(self, *columns): ...

class SelectBase(_HashableSource, Source, SelectQuery):
    def peek(self, database, n: int = ...): ...
    def first(self, database, n: int = ...): ...
    def scalar(self, database, as_tuple: bool = ..., as_dict: bool = ...): ...
    def scalars(self, database) -> Generator[Any, None, None]: ...
    def count(self, database, clear_limit: bool = ...): ...
    def exists(self, database): ...
    def get(self, database): ...

class CompoundSelectQuery(SelectBase):
    lhs: Any
    op: Any
    rhs: Any
    def __init__(self, lhs, op, rhs) -> None: ...
    def exists(self, database): ...
    def __sql__(self, ctx): ...

class Select(SelectBase):
    def __init__(
        self,
        from_list: Any | None = ...,
        columns: Any | None = ...,
        group_by: Any | None = ...,
        having: Any | None = ...,
        distinct: Any | None = ...,
        windows: Any | None = ...,
        for_update: Any | None = ...,
        for_update_of: Any | None = ...,
        nowait: Any | None = ...,
        lateral: Any | None = ...,
        **kwargs,
    ) -> None: ...
    def clone(self): ...
    def columns(self, *columns, **kwargs) -> None: ...
    select: Any
    def select_extend(self, *columns) -> None: ...
    @property
    def selected_columns(self): ...
    @selected_columns.setter
    def selected_columns(self, value) -> None: ...
    def from_(self, *sources) -> None: ...
    def join(self, dest, join_type=..., on: Any | None = ...) -> None: ...
    def left_outer_join(self, dest, on: Any | None = ...): ...
    def group_by(self, *columns) -> None: ...
    def group_by_extend(self, *values): ...
    def having(self, *expressions) -> None: ...
    def distinct(self, *columns) -> None: ...
    def window(self, *windows) -> None: ...
    def for_update(self, for_update: bool = ..., of: Any | None = ..., nowait: Any | None = ...) -> None: ...
    def lateral(self, lateral: bool = ...) -> None: ...
    def __sql_selection__(self, ctx, is_subquery: bool = ...): ...
    def __sql__(self, ctx): ...

class _WriteQuery(Query):
    table: Any
    def __init__(self, table, returning: Any | None = ..., **kwargs) -> None: ...
    def cte(self, name, recursive: bool = ..., columns: Any | None = ..., materialized: Any | None = ...): ...
    def returning(self, *returning) -> None: ...
    def apply_returning(self, ctx): ...
    def execute_returning(self, database): ...
    def handle_result(self, database, cursor): ...
    def __sql__(self, ctx): ...

class Update(_WriteQuery):
    def __init__(self, table, update: Any | None = ..., **kwargs) -> None: ...
    def from_(self, *sources) -> None: ...
    def __sql__(self, ctx): ...

class Insert(_WriteQuery):
    SIMPLE: int
    QUERY: int
    MULTI: int

    class DefaultValuesException(Exception): ...

    def __init__(
        self, table, insert: Any | None = ..., columns: Any | None = ..., on_conflict: Any | None = ..., **kwargs
    ) -> None: ...
    def where(self, *expressions) -> None: ...
    def as_rowcount(self, _as_rowcount: bool = ...) -> None: ...
    def on_conflict_ignore(self, ignore: bool = ...) -> None: ...
    def on_conflict_replace(self, replace: bool = ...) -> None: ...
    def on_conflict(self, *args, **kwargs) -> None: ...
    def get_default_data(self): ...
    def get_default_columns(self): ...
    def __sql__(self, ctx): ...
    def handle_result(self, database, cursor): ...

class Delete(_WriteQuery):
    def __sql__(self, ctx): ...

class Index(Node):
    def __init__(
        self, name, table, expressions, unique: bool = ..., safe: bool = ..., where: Any | None = ..., using: Any | None = ...
    ) -> None: ...
    def safe(self, _safe: bool = ...) -> None: ...
    def where(self, *expressions) -> None: ...
    def using(self, _using: Any | None = ...) -> None: ...
    def __sql__(self, ctx): ...

class ModelIndex(Index):
    def __init__(
        self,
        model,
        fields,
        unique: bool = ...,
        safe: bool = ...,
        where: Any | None = ...,
        using: Any | None = ...,
        name: Any | None = ...,
    ) -> None: ...

class PeeweeException(Exception):
    def __init__(self, *args) -> None: ...

class ImproperlyConfigured(PeeweeException): ...
class DatabaseError(PeeweeException): ...
class DataError(DatabaseError): ...
class IntegrityError(DatabaseError): ...
class InterfaceError(PeeweeException): ...
class InternalError(DatabaseError): ...
class NotSupportedError(DatabaseError): ...
class OperationalError(DatabaseError): ...
class ProgrammingError(DatabaseError): ...

class ExceptionWrapper:
    exceptions: Any
    def __init__(self, exceptions) -> None: ...
    def __enter__(self) -> None: ...
    def __exit__(self, exc_type, exc_value, traceback) -> None: ...

class IndexMetadata(NamedTuple):
    name: Any
    sql: Any
    columns: Any
    unique: Any
    table: Any

class ColumnMetadata(NamedTuple):
    name: Any
    data_type: Any
    null: Any
    primary_key: Any
    table: Any
    default: Any

class ForeignKeyMetadata(NamedTuple):
    column: Any
    dest_table: Any
    dest_column: Any
    table: Any

class ViewMetadata(NamedTuple):
    name: Any
    sql: Any

class _ConnectionState:
    def __init__(self, **kwargs) -> None: ...
    closed: bool
    conn: Any
    ctx: Any
    transactions: Any
    def reset(self) -> None: ...
    def set_connection(self, conn) -> None: ...

class _ConnectionLocal(_ConnectionState, threading.local): ...

class _NoopLock:
    def __enter__(self): ...
    def __exit__(self, exc_type, exc_val, exc_tb) -> None: ...

class ConnectionContext(_callable_context_manager):
    db: Any
    def __init__(self, db) -> None: ...
    def __enter__(self) -> None: ...
    def __exit__(self, exc_type, exc_val, exc_tb) -> None: ...

class Database(_callable_context_manager):
    context_class: Any
    field_types: Any
    operations: Any
    param: str
    quote: str
    server_version: Any
    commit_select: bool
    compound_select_parentheses: Any
    for_update: bool
    index_schema_prefix: bool
    index_using_precedes_table: bool
    limit_max: Any
    nulls_ordering: bool
    returning_clause: bool
    safe_create_index: bool
    safe_drop_index: bool
    sequences: bool
    truncate_table: bool
    autoconnect: Any
    autorollback: Any
    thread_safe: Any
    connect_params: Any
    def __init__(
        self,
        database,
        thread_safe: bool = ...,
        autorollback: bool = ...,
        field_types: Any | None = ...,
        operations: Any | None = ...,
        autocommit: Any | None = ...,
        autoconnect: bool = ...,
        **kwargs,
    ) -> None: ...
    database: Any
    deferred: Any
    def init(self, database, **kwargs) -> None: ...
    def __enter__(self): ...
    def __exit__(self, exc_type, exc_val, exc_tb) -> None: ...
    def connection_context(self): ...
    def connect(self, reuse_if_open: bool = ...): ...
    def close(self): ...
    def is_closed(self): ...
    def is_connection_usable(self): ...
    def connection(self): ...
    def cursor(self, commit: Any | None = ...): ...
    def execute_sql(self, sql, params: Any | None = ..., commit=...): ...
    def execute(self, query, commit=..., **context_options): ...
    def get_context_options(self): ...
    def get_sql_context(self, **context_options): ...
    def conflict_statement(self, on_conflict, query) -> None: ...
    def conflict_update(self, on_conflict, query) -> None: ...
    def last_insert_id(self, cursor, query_type: Any | None = ...): ...
    def rows_affected(self, cursor): ...
    def default_values_insert(self, ctx): ...
    def session_start(self): ...
    def session_commit(self): ...
    def session_rollback(self): ...
    def in_transaction(self): ...
    def push_transaction(self, transaction) -> None: ...
    def pop_transaction(self): ...
    def transaction_depth(self): ...
    def top_transaction(self): ...
    def atomic(self, *args, **kwargs): ...
    def manual_commit(self): ...
    def transaction(self, *args, **kwargs): ...
    def savepoint(self): ...
    def begin(self) -> None: ...
    def commit(self): ...
    def rollback(self): ...
    def batch_commit(self, it, n) -> Generator[Any, None, None]: ...
    def table_exists(self, table_name, schema: Any | None = ...): ...
    def get_tables(self, schema: Any | None = ...) -> None: ...
    def get_indexes(self, table, schema: Any | None = ...) -> None: ...
    def get_columns(self, table, schema: Any | None = ...) -> None: ...
    def get_primary_keys(self, table, schema: Any | None = ...) -> None: ...
    def get_foreign_keys(self, table, schema: Any | None = ...) -> None: ...
    def sequence_exists(self, seq) -> None: ...
    def create_tables(self, models, **options) -> None: ...
    def drop_tables(self, models, **kwargs) -> None: ...
    def extract_date(self, date_part, date_field) -> None: ...
    def truncate_date(self, date_part, date_field) -> None: ...
    def to_timestamp(self, date_field) -> None: ...
    def from_timestamp(self, date_field) -> None: ...
    def random(self): ...
    def bind(self, models, bind_refs: bool = ..., bind_backrefs: bool = ...) -> None: ...
    def bind_ctx(self, models, bind_refs: bool = ..., bind_backrefs: bool = ...): ...
    def get_noop_select(self, ctx): ...

class SqliteDatabase(Database):
    field_types: Any
    operations: Any
    index_schema_prefix: bool
    limit_max: int
    server_version: Any
    truncate_table: bool
    nulls_ordering: Any
    def __init__(self, database, *args, **kwargs) -> None: ...
    returning_clause: Any
    def init(
        self, database, pragmas: Any | None = ..., timeout: int = ..., returning_clause: Any | None = ..., **kwargs
    ) -> None: ...
    def pragma(self, key, value=..., permanent: bool = ..., schema: Any | None = ...): ...
    cache_size: Any
    foreign_keys: Any
    journal_mode: Any
    journal_size_limit: Any
    mmap_size: Any
    page_size: Any
    read_uncommitted: Any
    synchronous: Any
    wal_autocheckpoint: Any
    application_id: Any
    user_version: Any
    data_version: Any
    @property
    def timeout(self): ...
    @timeout.setter
    def timeout(self, seconds) -> None: ...
    def register_aggregate(self, klass, name: Any | None = ..., num_params: int = ...) -> None: ...
    def aggregate(self, name: Any | None = ..., num_params: int = ...): ...
    def register_collation(self, fn, name: Any | None = ...): ...
    def collation(self, name: Any | None = ...): ...
    def register_function(self, fn, name: Any | None = ..., num_params: int = ...) -> None: ...
    def func(self, name: Any | None = ..., num_params: int = ...): ...
    def register_window_function(self, klass, name: Any | None = ..., num_params: int = ...) -> None: ...
    def window_function(self, name: Any | None = ..., num_params: int = ...): ...
    def register_table_function(self, klass, name: Any | None = ...) -> None: ...
    def table_function(self, name: Any | None = ...): ...
    def unregister_aggregate(self, name) -> None: ...
    def unregister_collation(self, name) -> None: ...
    def unregister_function(self, name) -> None: ...
    def unregister_window_function(self, name) -> None: ...
    def unregister_table_function(self, name): ...
    def load_extension(self, extension) -> None: ...
    def unload_extension(self, extension) -> None: ...
    def attach(self, filename, name): ...
    def detach(self, name): ...
    def last_insert_id(self, cursor, query_type: Any | None = ...): ...
    def rows_affected(self, cursor): ...
    def begin(self, lock_type: Any | None = ...) -> None: ...
    def get_tables(self, schema: Any | None = ...): ...
    def get_views(self, schema: Any | None = ...): ...
    def get_indexes(self, table, schema: Any | None = ...): ...
    def get_columns(self, table, schema: Any | None = ...): ...
    def get_primary_keys(self, table, schema: Any | None = ...): ...
    def get_foreign_keys(self, table, schema: Any | None = ...): ...
    def get_binary_type(self): ...
    def conflict_statement(self, on_conflict, query): ...
    def conflict_update(self, oc, query): ...
    def extract_date(self, date_part, date_field): ...
    def truncate_date(self, date_part, date_field): ...
    def to_timestamp(self, date_field): ...
    def from_timestamp(self, date_field): ...

class PostgresqlDatabase(Database):
    field_types: Any
    operations: Any
    param: str
    commit_select: bool
    compound_select_parentheses: Any
    for_update: bool
    nulls_ordering: bool
    returning_clause: bool
    safe_create_index: bool
    sequences: bool
    def init(
        self, database, register_unicode: bool = ..., encoding: Any | None = ..., isolation_level: Any | None = ..., **kwargs
    ) -> None: ...
    def is_connection_usable(self): ...
    def last_insert_id(self, cursor, query_type: Any | None = ...): ...
    def rows_affected(self, cursor): ...
    def get_tables(self, schema: Any | None = ...): ...
    def get_views(self, schema: Any | None = ...): ...
    def get_indexes(self, table, schema: Any | None = ...): ...
    def get_columns(self, table, schema: Any | None = ...): ...
    def get_primary_keys(self, table, schema: Any | None = ...): ...
    def get_foreign_keys(self, table, schema: Any | None = ...): ...
    def sequence_exists(self, sequence): ...
    def get_binary_type(self): ...
    def conflict_statement(self, on_conflict, query) -> None: ...
    def conflict_update(self, oc, query): ...
    def extract_date(self, date_part, date_field): ...
    def truncate_date(self, date_part, date_field): ...
    def to_timestamp(self, date_field): ...
    def from_timestamp(self, date_field): ...
    def get_noop_select(self, ctx): ...
    def set_time_zone(self, timezone) -> None: ...

class MySQLDatabase(Database):
    field_types: Any
    operations: Any
    param: str
    quote: str
    commit_select: bool
    compound_select_parentheses: Any
    for_update: bool
    index_using_precedes_table: bool
    limit_max: Any
    safe_create_index: bool
    safe_drop_index: bool
    sql_mode: str
    def init(self, database, **kwargs) -> None: ...
    def is_connection_usable(self): ...
    def default_values_insert(self, ctx): ...
    def get_tables(self, schema: Any | None = ...): ...
    def get_views(self, schema: Any | None = ...): ...
    def get_indexes(self, table, schema: Any | None = ...): ...
    def get_columns(self, table, schema: Any | None = ...): ...
    def get_primary_keys(self, table, schema: Any | None = ...): ...
    def get_foreign_keys(self, table, schema: Any | None = ...): ...
    def get_binary_type(self): ...
    def conflict_statement(self, on_conflict, query): ...
    def conflict_update(self, on_conflict, query): ...
    def extract_date(self, date_part, date_field): ...
    def truncate_date(self, date_part, date_field): ...
    def to_timestamp(self, date_field): ...
    def from_timestamp(self, date_field): ...
    def random(self): ...
    def get_noop_select(self, ctx): ...

class _manual(_callable_context_manager):
    db: Any
    def __init__(self, db) -> None: ...
    def __enter__(self) -> None: ...
    def __exit__(self, exc_type, exc_val, exc_tb) -> None: ...

class _atomic(_callable_context_manager):
    db: Any
    def __init__(self, db, *args, **kwargs) -> None: ...
    def __enter__(self): ...
    def __exit__(self, exc_type, exc_val, exc_tb): ...

class _transaction(_callable_context_manager):
    db: Any
    def __init__(self, db, *args, **kwargs) -> None: ...
    def commit(self, begin: bool = ...) -> None: ...
    def rollback(self, begin: bool = ...) -> None: ...
    def __enter__(self): ...
    def __exit__(self, exc_type, exc_val, exc_tb) -> None: ...

class _savepoint(_callable_context_manager):
    db: Any
    sid: Any
    quoted_sid: Any
    def __init__(self, db, sid: Any | None = ...) -> None: ...
    def commit(self, begin: bool = ...) -> None: ...
    def rollback(self) -> None: ...
    def __enter__(self): ...
    def __exit__(self, exc_type, exc_val, exc_tb) -> None: ...

class CursorWrapper:
    cursor: Any
    count: int
    index: int
    initialized: bool
    populated: bool
    row_cache: Any
    def __init__(self, cursor) -> None: ...
    def __iter__(self): ...
    def __getitem__(self, item): ...
    def __len__(self): ...
    def initialize(self) -> None: ...
    def iterate(self, cache: bool = ...): ...
    def process_row(self, row): ...
    def iterator(self) -> Generator[Any, None, None]: ...
    def fill_cache(self, n: int = ...) -> None: ...

class DictCursorWrapper(CursorWrapper):
    initialize: Any
    process_row: Any

class NamedTupleCursorWrapper(CursorWrapper):
    tuple_class: Any
    def initialize(self) -> None: ...
    def process_row(self, row): ...

class ObjectCursorWrapper(DictCursorWrapper):
    constructor: Any
    def __init__(self, cursor, constructor) -> None: ...
    def process_row(self, row): ...

class ResultIterator:
    cursor_wrapper: Any
    index: int
    def __init__(self, cursor_wrapper) -> None: ...
    def __iter__(self): ...
    def next(self): ...
    __next__: Any

class FieldAccessor:
    model: Any
    field: Any
    name: Any
    def __init__(self, model, field, name) -> None: ...
    def __get__(self, instance, instance_type: Any | None = ...): ...
    def __set__(self, instance, value) -> None: ...

class ForeignKeyAccessor(FieldAccessor):
    rel_model: Any
    def __init__(self, model, field, name) -> None: ...
    def get_rel_instance(self, instance): ...
    def __get__(self, instance, instance_type: Any | None = ...): ...
    def __set__(self, instance, obj) -> None: ...

class BackrefAccessor:
    field: Any
    model: Any
    rel_model: Any
    def __init__(self, field) -> None: ...
    def __get__(self, instance, instance_type: Any | None = ...): ...

class ObjectIdAccessor:
    field: Any
    def __init__(self, field) -> None: ...
    def __get__(self, instance, instance_type: Any | None = ...): ...
    def __set__(self, instance, value) -> None: ...

class Field(ColumnBase):
    accessor_class: Any
    auto_increment: bool
    default_index_type: Any
    field_type: str
    unpack: bool
    null: Any
    index: Any
    unique: Any
    column_name: Any
    default: Any
    primary_key: Any
    constraints: Any
    sequence: Any
    collation: Any
    unindexed: Any
    choices: Any
    help_text: Any
    verbose_name: Any
    index_type: Any
    def __init__(
        self,
        null: bool = ...,
        index: bool = ...,
        unique: bool = ...,
        column_name: Any | None = ...,
        default: Any | None = ...,
        primary_key: bool = ...,
        constraints: Any | None = ...,
        sequence: Any | None = ...,
        collation: Any | None = ...,
        unindexed: bool = ...,
        choices: Any | None = ...,
        help_text: Any | None = ...,
        verbose_name: Any | None = ...,
        index_type: Any | None = ...,
        db_column: Any | None = ...,
        _hidden: bool = ...,
    ) -> None: ...
    def __hash__(self): ...
    model: Any
    name: Any
    def bind(self, model, name, set_attribute: bool = ...) -> None: ...
    @property
    def column(self): ...
    def adapt(self, value): ...
    def db_value(self, value): ...
    def python_value(self, value): ...
    def to_value(self, value): ...
    def get_sort_key(self, ctx): ...
    def __sql__(self, ctx): ...
    def get_modifiers(self) -> None: ...
    def ddl_datatype(self, ctx): ...
    def ddl(self, ctx): ...

class AnyField(Field):
    field_type: str

class IntegerField(Field):
    field_type: str
    def adapt(self, value): ...

class BigIntegerField(IntegerField):
    field_type: str

class SmallIntegerField(IntegerField):
    field_type: str

class AutoField(IntegerField):
    auto_increment: bool
    field_type: str
    def __init__(self, *args, **kwargs) -> None: ...

class BigAutoField(AutoField):
    field_type: str

class IdentityField(AutoField):
    field_type: str
    def __init__(self, generate_always: bool = ..., **kwargs) -> None: ...

class PrimaryKeyField(AutoField):
    def __init__(self, *args, **kwargs) -> None: ...

class FloatField(Field):
    field_type: str
    def adapt(self, value): ...

class DoubleField(FloatField):
    field_type: str

class DecimalField(Field):
    field_type: str
    max_digits: Any
    decimal_places: Any
    auto_round: Any
    rounding: Any
    def __init__(
        self,
        max_digits: int = ...,
        decimal_places: int = ...,
        auto_round: bool = ...,
        rounding: Any | None = ...,
        *args,
        **kwargs,
    ) -> None: ...
    def get_modifiers(self): ...
    def db_value(self, value): ...
    def python_value(self, value): ...

class _StringField(Field):
    def adapt(self, value): ...
    def __add__(self, other): ...
    def __radd__(self, other): ...

class CharField(_StringField):
    field_type: str
    max_length: Any
    def __init__(self, max_length: int = ..., *args, **kwargs) -> None: ...
    def get_modifiers(self): ...

class FixedCharField(CharField):
    field_type: str
    def python_value(self, value): ...

class TextField(_StringField):
    field_type: str

class BlobField(Field):
    field_type: str
    def bind(self, model, name, set_attribute: bool = ...): ...
    def db_value(self, value): ...

class BitField(BitwiseMixin, BigIntegerField):
    def __init__(self, *args, **kwargs) -> None: ...
    def flag(self, value: Any | None = ...): ...

class BigBitFieldData:
    instance: Any
    name: Any
    def __init__(self, instance, name) -> None: ...
    def set_bit(self, idx) -> None: ...
    def clear_bit(self, idx) -> None: ...
    def toggle_bit(self, idx): ...
    def is_set(self, idx): ...

class BigBitFieldAccessor(FieldAccessor):
    def __get__(self, instance, instance_type: Any | None = ...): ...
    def __set__(self, instance, value) -> None: ...

class BigBitField(BlobField):
    accessor_class: Any
    def __init__(self, *args, **kwargs) -> None: ...
    def db_value(self, value): ...

class UUIDField(Field):
    field_type: str
    def db_value(self, value): ...
    def python_value(self, value): ...

class BinaryUUIDField(BlobField):
    field_type: str
    def db_value(self, value): ...
    def python_value(self, value): ...

class _BaseFormattedField(Field):
    formats: Any
    def __init__(self, formats: Any | None = ..., *args, **kwargs) -> None: ...

class DateTimeField(_BaseFormattedField):
    field_type: str
    formats: Any
    def adapt(self, value): ...
    def to_timestamp(self): ...
    def truncate(self, part): ...
    year: Any
    month: Any
    day: Any
    hour: Any
    minute: Any
    second: Any

class DateField(_BaseFormattedField):
    field_type: str
    formats: Any
    def adapt(self, value): ...
    def to_timestamp(self): ...
    def truncate(self, part): ...
    year: Any
    month: Any
    day: Any

class TimeField(_BaseFormattedField):
    field_type: str
    formats: Any
    def adapt(self, value): ...
    hour: Any
    minute: Any
    second: Any

class TimestampField(BigIntegerField):
    valid_resolutions: Any
    resolution: Any
    ticks_to_microsecond: Any
    utc: Any
    def __init__(self, *args, **kwargs) -> None: ...
    def local_to_utc(self, dt): ...
    def utc_to_local(self, dt): ...
    def get_timestamp(self, value): ...
    def db_value(self, value): ...
    def python_value(self, value): ...
    def from_timestamp(self): ...
    year: Any
    month: Any
    day: Any
    hour: Any
    minute: Any
    second: Any

class IPField(BigIntegerField):
    def db_value(self, val): ...
    def python_value(self, val): ...

class BooleanField(Field):
    field_type: str
    adapt: Any

class BareField(Field):
    adapt: Any
    def __init__(self, adapt: Any | None = ..., *args, **kwargs) -> None: ...
    def ddl_datatype(self, ctx) -> None: ...

class ForeignKeyField(Field):
    accessor_class: Any
    backref_accessor_class: Any
    rel_model: Any
    rel_field: Any
    declared_backref: Any
    backref: Any
    on_delete: Any
    on_update: Any
    deferrable: Any
    deferred: Any
    object_id_name: Any
    lazy_load: Any
    constraint_name: Any
    def __init__(
        self,
        model,
        field: Any | None = ...,
        backref: Any | None = ...,
        on_delete: Any | None = ...,
        on_update: Any | None = ...,
        deferrable: Any | None = ...,
        _deferred: Any | None = ...,
        rel_model: Any | None = ...,
        to_field: Any | None = ...,
        object_id_name: Any | None = ...,
        lazy_load: bool = ...,
        constraint_name: Any | None = ...,
        related_name: Any | None = ...,
        *args,
        **kwargs,
    ) -> None: ...
    @property
    def field_type(self): ...
    def get_modifiers(self): ...
    def adapt(self, value): ...
    def db_value(self, value): ...
    def python_value(self, value): ...
    column_name: Any
    safe_name: Any
    def bind(self, model, name, set_attribute: bool = ...) -> None: ...
    def foreign_key_constraint(self): ...
    def __getattr__(self, attr): ...

class DeferredForeignKey(Field):
    field_kwargs: Any
    rel_model_name: Any
    def __init__(self, rel_model_name, **kwargs) -> None: ...
    __hash__: Any
    def __deepcopy__(self, memo: Any | None = ...): ...
    def set_model(self, rel_model) -> None: ...
    @staticmethod
    def resolve(model_cls) -> None: ...

class DeferredThroughModel:
    def __init__(self) -> None: ...
    def set_field(self, model, field, name) -> None: ...
    def set_model(self, through_model) -> None: ...

class MetaField(Field):
    column_name: Any
    default: Any
    model: Any
    name: Any
    primary_key: bool

class ManyToManyFieldAccessor(FieldAccessor):
    model: Any
    rel_model: Any
    through_model: Any
    src_fk: Any
    dest_fk: Any
    def __init__(self, model, field, name) -> None: ...
    def __get__(self, instance, instance_type: Any | None = ..., force_query: bool = ...): ...
    def __set__(self, instance, value) -> None: ...

class ManyToManyField(MetaField):
    accessor_class: Any
    rel_model: Any
    backref: Any
    def __init__(
        self,
        model,
        backref: Any | None = ...,
        through_model: Any | None = ...,
        on_delete: Any | None = ...,
        on_update: Any | None = ...,
        _is_backref: bool = ...,
    ) -> None: ...
    def bind(self, model, name, set_attribute: bool = ...) -> None: ...
    def get_models(self): ...
    @property
    def through_model(self): ...
    @through_model.setter
    def through_model(self, value) -> None: ...
    def get_through_model(self): ...

class VirtualField(MetaField):
    field_class: Any
    field_instance: Any
    def __init__(self, field_class: Any | None = ..., *args, **kwargs) -> None: ...
    def db_value(self, value): ...
    def python_value(self, value): ...
    model: Any
    column_name: Any
    def bind(self, model, name, set_attribute: bool = ...) -> None: ...

class CompositeKey(MetaField):
    sequence: Any
    field_names: Any
    def __init__(self, *field_names) -> None: ...
    @property
    def safe_field_names(self): ...
    def __get__(self, instance, instance_type: Any | None = ...): ...
    def __set__(self, instance, value) -> None: ...
    def __eq__(self, other): ...
    def __ne__(self, other): ...
    def __hash__(self): ...
    def __sql__(self, ctx): ...
    model: Any
    column_name: Any
    def bind(self, model, name, set_attribute: bool = ...) -> None: ...

class _SortedFieldList:
    def __init__(self) -> None: ...
    def __getitem__(self, i): ...
    def __iter__(self): ...
    def __contains__(self, item): ...
    def index(self, field): ...
    def insert(self, item) -> None: ...
    def remove(self, item) -> None: ...

class SchemaManager:
    model: Any
    context_options: Any
    def __init__(self, model, database: Any | None = ..., **context_options) -> None: ...
    @property
    def database(self): ...
    @database.setter
    def database(self, value) -> None: ...
    def create_table(self, safe: bool = ..., **options) -> None: ...
    def create_table_as(self, table_name, query, safe: bool = ..., **meta) -> None: ...
    def drop_table(self, safe: bool = ..., **options) -> None: ...
    def truncate_table(self, restart_identity: bool = ..., cascade: bool = ...) -> None: ...
    def create_indexes(self, safe: bool = ...) -> None: ...
    def drop_indexes(self, safe: bool = ...) -> None: ...
    def create_sequence(self, field) -> None: ...
    def drop_sequence(self, field) -> None: ...
    def create_foreign_key(self, field) -> None: ...
    def create_sequences(self) -> None: ...
    def create_all(self, safe: bool = ..., **table_options) -> None: ...
    def drop_sequences(self) -> None: ...
    def drop_all(self, safe: bool = ..., drop_sequences: bool = ..., **options) -> None: ...

class Metadata:
    model: Any
    database: Any
    fields: Any
    columns: Any
    combined: Any
    sorted_fields: Any
    sorted_field_names: Any
    defaults: Any
    name: Any
    table_function: Any
    legacy_table_names: Any
    table_name: Any
    indexes: Any
    constraints: Any
    primary_key: Any
    composite_key: Any
    only_save_dirty: Any
    depends_on: Any
    table_settings: Any
    without_rowid: Any
    strict_tables: Any
    temporary: Any
    refs: Any
    backrefs: Any
    model_refs: Any
    model_backrefs: Any
    manytomany: Any
    options: Any
    def __init__(
        self,
        model,
        database: Any | None = ...,
        table_name: Any | None = ...,
        indexes: Any | None = ...,
        primary_key: Any | None = ...,
        constraints: Any | None = ...,
        schema: Any | None = ...,
        only_save_dirty: bool = ...,
        depends_on: Any | None = ...,
        options: Any | None = ...,
        db_table: Any | None = ...,
        table_function: Any | None = ...,
        table_settings: Any | None = ...,
        without_rowid: bool = ...,
        temporary: bool = ...,
        strict_tables: Any | None = ...,
        legacy_table_names: bool = ...,
        **kwargs,
    ) -> None: ...
    def make_table_name(self): ...
    def model_graph(self, refs: bool = ..., backrefs: bool = ..., depth_first: bool = ...): ...
    def add_ref(self, field) -> None: ...
    def remove_ref(self, field) -> None: ...
    def add_manytomany(self, field) -> None: ...
    def remove_manytomany(self, field) -> None: ...
    @property
    def table(self): ...
    @table.setter
    def table(self, value) -> None: ...
    def table(self) -> None: ...
    @property
    def schema(self): ...
    @schema.setter
    def schema(self, value) -> None: ...
    @property
    def entity(self): ...
    def get_rel_for_model(self, model): ...
    def add_field(self, field_name, field, set_attribute: bool = ...) -> None: ...
    def remove_field(self, field_name) -> None: ...
    auto_increment: Any
    def set_primary_key(self, name, field) -> None: ...
    def get_primary_keys(self): ...
    def get_default_dict(self): ...
    def fields_to_index(self): ...
    def set_database(self, database) -> None: ...
    def set_table_name(self, table_name) -> None: ...

class SubclassAwareMetadata(Metadata):
    models: Any
    def __init__(self, model, *args, **kwargs) -> None: ...
    def map_models(self, fn) -> None: ...

class DoesNotExist(Exception): ...

class ModelBase(type):
    inheritable: Any
    def __new__(cls, name, bases, attrs): ...
    def __iter__(self): ...
    def __getitem__(self, key): ...
    def __setitem__(self, key, value) -> None: ...
    def __delitem__(self, key) -> None: ...
    def __contains__(self, key): ...
    def __len__(self): ...
    def __bool__(self): ...
    __nonzero__: Any
    def __sql__(self, ctx): ...

class _BoundModelsContext(_callable_context_manager):
    models: Any
    database: Any
    bind_refs: Any
    bind_backrefs: Any
    def __init__(self, models, database, bind_refs, bind_backrefs) -> None: ...
    def __enter__(self): ...
    def __exit__(self, exc_type, exc_val, exc_tb) -> None: ...

class Model:
    __data__: Any
    __rel__: Any
    def __init__(self, *args, **kwargs) -> None: ...
    @classmethod
    def validate_model(cls) -> None: ...
    @classmethod
    def alias(cls, alias: Any | None = ...): ...
    @classmethod
    def select(cls, *fields): ...
    @classmethod
    def update(cls, __data: Any | None = ..., **update): ...
    @classmethod
    def insert(cls, __data: Any | None = ..., **insert): ...
    @classmethod
    def insert_many(cls, rows, fields: Any | None = ...): ...
    @classmethod
    def insert_from(cls, query, fields): ...
    @classmethod
    def replace(cls, __data: Any | None = ..., **insert): ...
    @classmethod
    def replace_many(cls, rows, fields: Any | None = ...): ...
    @classmethod
    def raw(cls, sql, *params): ...
    @classmethod
    def delete(cls): ...
    @classmethod
    def create(cls, **query): ...
    @classmethod
    def bulk_create(cls, model_list, batch_size: Any | None = ...) -> None: ...
    @classmethod
    def bulk_update(cls, model_list, fields, batch_size: Any | None = ...): ...
    @classmethod
    def noop(cls): ...
    @classmethod
    def get(cls, *query, **filters): ...
    @classmethod
    def get_or_none(cls, *query, **filters): ...
    @classmethod
    def get_by_id(cls, pk): ...
    @classmethod
    def set_by_id(cls, key, value): ...
    @classmethod
    def delete_by_id(cls, pk): ...
    @classmethod
    def get_or_create(cls, **kwargs): ...
    @classmethod
    def filter(cls, *dq_nodes, **filters): ...
    def get_id(self): ...
    def save(self, force_insert: bool = ..., only: Any | None = ...): ...
    def is_dirty(self): ...
    @property
    def dirty_fields(self): ...
    def dependencies(self, search_nullable: bool = ...) -> Generator[Any, None, None]: ...
    def delete_instance(self, recursive: bool = ..., delete_nullable: bool = ...): ...
    def __hash__(self): ...
    def __eq__(self, other): ...
    def __ne__(self, other): ...
    def __sql__(self, ctx): ...
    @classmethod
    def bind(cls, database, bind_refs: bool = ..., bind_backrefs: bool = ..., _exclude: Any | None = ...): ...
    @classmethod
    def bind_ctx(cls, database, bind_refs: bool = ..., bind_backrefs: bool = ...): ...
    @classmethod
    def table_exists(cls): ...
    @classmethod
    def create_table(cls, safe: bool = ..., **options) -> None: ...
    @classmethod
    def drop_table(cls, safe: bool = ..., drop_sequences: bool = ..., **options) -> None: ...
    @classmethod
    def truncate_table(cls, **options) -> None: ...
    @classmethod
    def index(cls, *fields, **kwargs): ...
    @classmethod
    def add_index(cls, *fields, **kwargs) -> None: ...

class ModelAlias(Node):
    def __init__(self, model, alias: Any | None = ...) -> None: ...
    def __getattr__(self, attr): ...
    def __setattr__(self, attr, value) -> None: ...
    def get_field_aliases(self): ...
    def select(self, *selection): ...
    def __call__(self, **kwargs): ...
    def __sql__(self, ctx): ...

class FieldAlias(Field):
    source: Any
    model: Any
    field: Any
    def __init__(self, source, field) -> None: ...
    @classmethod
    def create(cls, source, field): ...
    def clone(self): ...
    def adapt(self, value): ...
    def python_value(self, value): ...
    def db_value(self, value): ...
    def __getattr__(self, attr): ...
    def __sql__(self, ctx): ...

class _ModelQueryHelper:
    default_row_type: Any
    def __init__(self, *args, **kwargs) -> None: ...
    def objects(self, constructor: Any | None = ...) -> None: ...

class ModelRaw(_ModelQueryHelper, RawQuery):
    model: Any
    def __init__(self, model, sql, params, **kwargs) -> None: ...
    def get(self): ...

class BaseModelSelect(_ModelQueryHelper):
    def union_all(self, rhs): ...
    __add__: Any
    def union(self, rhs): ...
    __or__: Any
    def intersect(self, rhs): ...
    __and__: Any
    def except_(self, rhs): ...
    __sub__: Any
    def __iter__(self): ...
    def prefetch(self, *subqueries): ...
    def get(self, database: Any | None = ...): ...
    def get_or_none(self, database: Any | None = ...): ...
    def group_by(self, *columns) -> None: ...

class ModelCompoundSelectQuery(BaseModelSelect, CompoundSelectQuery):
    model: Any
    def __init__(self, model, *args, **kwargs) -> None: ...

class ModelSelect(BaseModelSelect, Select):
    model: Any
    def __init__(self, model, fields_or_models, is_default: bool = ...) -> None: ...
    def clone(self): ...
    def select(self, *fields_or_models): ...
    def select_extend(self, *columns): ...
    def switch(self, ctx: Any | None = ...): ...
    def join(self, dest, join_type=..., on: Any | None = ..., src: Any | None = ..., attr: Any | None = ...) -> None: ...
    def left_outer_join(self, dest, on: Any | None = ..., src: Any | None = ..., attr: Any | None = ...): ...
    def join_from(self, src, dest, join_type=..., on: Any | None = ..., attr: Any | None = ...): ...
    def ensure_join(self, lm, rm, on: Any | None = ..., **join_kwargs): ...
    def convert_dict_to_node(self, qdict): ...
    def filter(self, *args, **kwargs): ...
    def create_table(self, name, safe: bool = ..., **meta): ...
    def __sql_selection__(self, ctx, is_subquery: bool = ...): ...

class NoopModelSelect(ModelSelect):
    def __sql__(self, ctx): ...

class _ModelWriteQueryHelper(_ModelQueryHelper):
    model: Any
    def __init__(self, model, *args, **kwargs) -> None: ...
    def returning(self, *returning): ...

class ModelUpdate(_ModelWriteQueryHelper, Update): ...

class ModelInsert(_ModelWriteQueryHelper, Insert):
    default_row_type: Any
    def __init__(self, *args, **kwargs) -> None: ...
    def returning(self, *returning): ...
    def get_default_data(self): ...
    def get_default_columns(self): ...

class ModelDelete(_ModelWriteQueryHelper, Delete): ...

class ManyToManyQuery(ModelSelect):
    def __init__(self, instance, accessor, rel, *args, **kwargs) -> None: ...
    def add(self, value, clear_existing: bool = ...) -> None: ...
    def remove(self, value): ...
    def clear(self): ...

class BaseModelCursorWrapper(DictCursorWrapper):
    model: Any
    select: Any
    def __init__(self, cursor, model, columns) -> None: ...
    initialize: Any
    def process_row(self, row) -> None: ...

class ModelDictCursorWrapper(BaseModelCursorWrapper):
    def process_row(self, row): ...

class ModelTupleCursorWrapper(ModelDictCursorWrapper):
    constructor: Any
    def process_row(self, row): ...

class ModelNamedTupleCursorWrapper(ModelTupleCursorWrapper):
    tuple_class: Any
    constructor: Any
    def initialize(self): ...

class ModelObjectCursorWrapper(ModelDictCursorWrapper):
    constructor: Any
    is_model: Any
    def __init__(self, cursor, model, select, constructor) -> None: ...
    def process_row(self, row): ...

class ModelCursorWrapper(BaseModelCursorWrapper):
    from_list: Any
    joins: Any
    def __init__(self, cursor, model, select, from_list, joins) -> None: ...
    key_to_constructor: Any
    src_is_dest: Any
    src_to_dest: Any
    column_keys: Any
    def initialize(self) -> None: ...
    def process_row(self, row): ...

class PrefetchQuery:
    def __new__(
        cls,
        query,
        fields: Any | None = ...,
        is_backref: Any | None = ...,
        rel_models: Any | None = ...,
        field_to_name: Any | None = ...,
        model: Any | None = ...,
    ): ...
    def populate_instance(self, instance, id_map) -> None: ...
    def store_instance(self, instance, id_map) -> None: ...

def prefetch(sq, *subqueries): ...
