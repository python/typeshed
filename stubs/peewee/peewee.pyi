import itertools
import logging
import threading
from _typeshed import Incomplete, SupportsKeysAndGetItem
from collections.abc import Callable, Generator, Iterable, Iterator
from datetime import datetime
from decimal import Decimal
from types import TracebackType
from typing import Any, ClassVar, Final, Literal, NamedTuple, TypeVar
from typing_extensions import Self
from uuid import UUID

class NullHandler(logging.Handler):
    def emit(self, record) -> None: ...

text_type = str
bytes_type = bytes
buffer_type = memoryview
basestring = str
long = int
izip_longest = itertools.zip_longest

_VT = TypeVar("_VT")
_F = TypeVar("_F", bound=Callable[..., Any])

class attrdict(dict[str, _VT]):
    def __getattr__(self, attr: str) -> _VT: ...
    def __setattr__(self, attr: str, value: _VT) -> None: ...
    # calls dict.update()
    def __iadd__(self, rhs: SupportsKeysAndGetItem[str, _VT] | Iterable[tuple[str, _VT]]) -> Self: ...
    def __add__(self, rhs: SupportsKeysAndGetItem[str, _VT] | Iterable[tuple[str, _VT]]) -> attrdict[_VT]: ...

OP: attrdict[str]
DJANGO_MAP: attrdict[Incomplete]
JOIN: attrdict[str]
ROW: attrdict[int]
PREFETCH_TYPE: attrdict[int]
SCOPE_NORMAL: Final = 1
SCOPE_SOURCE: Final = 2
SCOPE_VALUES: Final = 4
SCOPE_CTE: Final = 8
SCOPE_COLUMN: Final = 16
CSQ_PARENTHESES_NEVER: Final = 0
CSQ_PARENTHESES_ALWAYS: Final = 1
CSQ_PARENTHESES_UNNESTED: Final = 2

def chunked(it, n) -> Generator[Incomplete, None, None]: ...

class _callable_context_manager:
    def __call__(self, fn): ...

class Proxy:
    __slots__ = ("obj", "_callbacks")
    def __init__(self) -> None: ...
    obj: Incomplete
    def initialize(self, obj) -> None: ...
    def attach_callback(self, callback): ...
    def passthrough(method): ...
    __enter__: Incomplete
    __exit__: Incomplete
    def __getattr__(self, attr: str): ...
    def __setattr__(self, attr: str, value) -> None: ...

class DatabaseProxy(Proxy):
    __slots__ = ("obj", "_callbacks", "_Model")
    def connection_context(self) -> ConnectionContext: ...
    def atomic(self, *args, **kwargs) -> _atomic: ...
    def manual_commit(self) -> _manual: ...
    def transaction(self, *args, **kwargs) -> _transaction: ...
    def savepoint(self) -> _savepoint: ...
    @property
    def Model(self) -> type[Model]: ...

class ModelDescriptor: ...

class AliasManager:
    __slots__ = ("_counter", "_current_index", "_mapping")
    def __init__(self) -> None: ...
    @property
    def mapping(self): ...
    def add(self, source): ...
    def get(self, source, any_depth: bool = False): ...
    def __getitem__(self, source): ...
    def __setitem__(self, source, alias) -> None: ...
    def push(self) -> None: ...
    def pop(self) -> None: ...

class State:
    def __new__(cls, scope=1, parentheses: bool = False, **kwargs) -> Self: ...
    def __call__(self, scope=None, parentheses=None, **kwargs) -> State: ...
    def __getattr__(self, attr_name: str): ...

class Context:
    __slots__ = ("stack", "_sql", "_values", "alias_manager", "state")
    stack: list[Incomplete]
    alias_manager: AliasManager
    state: State
    def __init__(self, **settings) -> None: ...
    def as_new(self) -> Context: ...
    def column_sort_key(self, item): ...
    @property
    def scope(self): ...
    @property
    def parentheses(self): ...
    @property
    def subquery(self): ...
    def __call__(self, **overrides) -> Self: ...
    scope_normal: Incomplete
    scope_source: Incomplete
    scope_values: Incomplete
    scope_cte: Incomplete
    scope_column: Incomplete
    def __enter__(self) -> Self: ...
    def __exit__(
        self, exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: TracebackType | None
    ) -> None: ...
    def push_alias(self) -> Generator[None]: ...
    def sql(self, obj): ...
    def literal(self, keyword) -> Self: ...
    def value(self, value, converter=None, add_param: bool = True): ...
    def __sql__(self, ctx): ...
    def parse(self, node): ...
    def query(self) -> tuple[str, list[Incomplete]]: ...

class Node:
    __isabstractmethod__: bool
    def clone(self) -> Self: ...
    def __sql__(self, ctx): ...
    @staticmethod
    def copy(method): ...
    def coerce(self, _coerce: bool = True) -> Self: ...
    def is_alias(self) -> bool: ...
    def unwrap(self) -> Self: ...

class ColumnFactory:
    __slots__ = ("node",)
    node: Node
    def __init__(self, node: Node) -> None: ...
    def __getattr__(self, attr: str) -> Column: ...
    __getitem__ = __getattr__

class _DynamicColumn:
    __slots__ = ()
    def __get__(self, instance, instance_type=None): ...

class _ExplicitColumn:
    __slots__ = ()
    def __get__(self, instance, instance_type=None) -> Self: ...

class Star(Node):
    def __init__(self, source) -> None: ...
    def __sql__(self, ctx): ...

class Source(Node):
    c: Incomplete
    def __init__(self, alias=None) -> None: ...
    def alias(self, name) -> Self: ...
    def select(self, *columns) -> Select: ...
    @property
    def __star__(self) -> Star: ...
    def join(self, dest, join_type="INNER JOIN", on=None) -> Join: ...
    def left_outer_join(self, dest, on=None) -> Join: ...
    def cte(self, name, recursive: bool = False, columns=None, materialized=None) -> CTE: ...
    def get_sort_key(self, ctx) -> tuple[Incomplete, ...]: ...
    def apply_alias(self, ctx): ...
    def apply_column(self, ctx): ...

class _HashableSource:
    def __init__(self, *args, **kwargs) -> None: ...
    def alias(self, name) -> Self: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other) -> Expression | bool: ...  # type: ignore[override]
    def __ne__(self, other) -> Expression | bool: ...  # type: ignore[override]
    __lt__: Callable[[Self, Any], Expression]
    __le__: Callable[[Self, Any], Expression]
    __gt__: Callable[[Self, Any], Expression]
    __ge__: Callable[[Self, Any], Expression]

class BaseTable(Source):
    def __and__(self, other) -> Join: ...
    def __add__(self, other) -> Join: ...
    def __sub__(self, other) -> Join: ...
    def __or__(self, other) -> Join: ...
    def __mul__(self, other) -> Join: ...
    def __rand__(self, other) -> Join: ...
    def __radd__(self, other) -> Join: ...
    def __rsub__(self, other) -> Join: ...
    def __ror__(self, other) -> Join: ...
    def __rmul__(self, other) -> Join: ...

class _BoundTableContext(_callable_context_manager):
    table: Incomplete
    database: Incomplete
    def __init__(self, table, database) -> None: ...
    def __enter__(self): ...
    def __exit__(
        self, exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: TracebackType | None
    ) -> None: ...

class Table(_HashableSource, BaseTable):  # type: ignore[misc]
    __name__: Incomplete
    c: Incomplete
    primary_key: Incomplete
    def __init__(
        self, name, columns=None, primary_key=None, schema: str | None = None, alias=None, _model=None, _database=None
    ) -> None: ...
    def clone(self) -> Table: ...
    def bind(self, database=None) -> Self: ...
    def bind_ctx(self, database=None) -> _BoundTableContext: ...
    def select(self, *columns) -> Select: ...
    def insert(self, insert=None, columns=None, **kwargs) -> Insert: ...
    def replace(self, insert=None, columns=None, **kwargs): ...
    def update(self, update=None, **kwargs) -> Update: ...
    def delete(self) -> Delete: ...
    def __sql__(self, ctx): ...

class Join(BaseTable):
    lhs: Incomplete
    rhs: Incomplete
    join_type: Incomplete
    def __init__(self, lhs, rhs, join_type="INNER JOIN", on=None, alias=None) -> None: ...
    def on(self, predicate) -> Self: ...
    def __sql__(self, ctx): ...

class ValuesList(_HashableSource, BaseTable):  # type: ignore[misc]
    def __init__(self, values, columns=None, alias=None) -> None: ...
    def columns(self, *names) -> Self: ...
    def __sql__(self, ctx): ...

class CTE(_HashableSource, Source):  # type: ignore[misc]
    def __init__(self, name, query, recursive: bool = False, columns=None, materialized=None) -> None: ...
    def select_from(self, *columns): ...
    def union_all(self, rhs) -> CTE: ...
    __add__ = union_all
    def union(self, rhs) -> CTE: ...
    __or__ = union
    def __sql__(self, ctx): ...

class ColumnBase(Node):
    def converter(self, converter=None) -> Self: ...
    def alias(self, alias): ...
    def unalias(self) -> Self: ...
    def bind_to(self, dest) -> BindTo: ...
    def cast(self, as_type) -> Cast: ...
    def asc(self, collation=None, nulls=None) -> Ordering: ...
    __pos__ = asc
    def desc(self, collation=None, nulls=None) -> Ordering: ...
    __neg__ = desc
    def __invert__(self): ...
    __and__: Incomplete
    __or__: Incomplete
    def __add__(self, rhs: Any) -> Expression: ...
    __sub__: Incomplete
    __mul__: ClassVar[Callable[[Self, Any], Expression]]
    __div__: ClassVar[Callable[[Self, Any], Expression]]
    __truediv__: ClassVar[Callable[[Self, Any], Expression]]
    __xor__: ClassVar[Callable[[Self, Any], Expression]]
    def __radd__(self, rhs: Any) -> Expression: ...
    __rsub__: ClassVar[Callable[[Self, Any], Expression]]
    __rmul__: ClassVar[Callable[[Self, Any], Expression]]
    __rdiv__: ClassVar[Callable[[Self, Any], Expression]]
    __rtruediv__: ClassVar[Callable[[Self, Any], Expression]]
    __rand__: ClassVar[Callable[[Self, Any], Expression]]
    __ror__: ClassVar[Callable[[Self, Any], Expression]]
    __rxor__: ClassVar[Callable[[Self, Any], Expression]]
    def __eq__(self, rhs) -> Expression: ...  # type: ignore[override]
    def __ne__(self, rhs) -> Expression: ...  # type: ignore[override]
    __lt__: ClassVar[Callable[[Self, Any], Expression]]
    __le__: ClassVar[Callable[[Self, Any], Expression]]
    __gt__: ClassVar[Callable[[Self, Any], Expression]]
    __ge__: ClassVar[Callable[[Self, Any], Expression]]
    __lshift__: ClassVar[Callable[[Self, Any], Expression]]
    __rshift__: ClassVar[Callable[[Self, Any], Expression]]
    __mod__: ClassVar[Callable[[Self, Any], Expression]]
    __pow__: ClassVar[Callable[[Self, Any], Expression]]
    like: ClassVar[Callable[[Self, Any], Expression]]
    ilike: ClassVar[Callable[[Self, Any], Expression]]
    bin_and: ClassVar[Callable[[Self, Any], Expression]]
    bin_or: ClassVar[Callable[[Self, Any], Expression]]
    in_: ClassVar[Callable[[Self, Any], Expression]]
    not_in: ClassVar[Callable[[Self, Any], Expression]]
    regexp: ClassVar[Callable[[Self, Any], Expression]]
    iregexp: ClassVar[Callable[[Self, Any], Expression]]
    def is_null(self, is_null: bool = True) -> Expression: ...
    def contains(self, rhs) -> Expression: ...
    def startswith(self, rhs) -> Expression: ...
    def endswith(self, rhs) -> Expression: ...
    def between(self, lo, hi) -> Expression: ...
    def concat(self, rhs) -> StringExpression: ...
    def __getitem__(self, item): ...
    __iter__: Incomplete
    def distinct(self) -> NodeList: ...
    def collate(self, collation) -> NodeList: ...
    def get_sort_key(self, ctx) -> tuple[Incomplete, ...]: ...

class Column(ColumnBase):
    source: Incomplete
    name: Incomplete
    def __init__(self, source, name) -> None: ...
    def get_sort_key(self, ctx) -> tuple[Incomplete, ...]: ...
    def __hash__(self) -> int: ...
    def __sql__(self, ctx): ...

class WrappedNode(ColumnBase):
    node: Incomplete
    def __init__(self, node) -> None: ...
    def is_alias(self) -> bool: ...
    def unwrap(self): ...

class EntityFactory:
    __slots__ = ("node",)
    node: Incomplete
    def __init__(self, node) -> None: ...
    def __getattr__(self, attr: str) -> Entity: ...

class _DynamicEntity:
    __slots__ = ()
    def __get__(self, instance, instance_type=None): ...

class Alias(WrappedNode):
    c: Incomplete
    def __init__(self, node, alias) -> None: ...
    def __hash__(self) -> int: ...
    @property
    def name(self): ...
    @name.setter
    def name(self, value) -> None: ...
    def alias(self, alias=None): ...
    def unalias(self): ...
    def is_alias(self) -> bool: ...
    def __sql__(self, ctx): ...

class BindTo(WrappedNode):
    dest: Incomplete
    def __init__(self, node, dest) -> None: ...
    def __sql__(self, ctx): ...

class Negated(WrappedNode):
    def __invert__(self): ...
    def __sql__(self, ctx): ...

class BitwiseMixin:
    def __and__(self, other): ...
    def __or__(self, other): ...
    def __sub__(self, other): ...
    def __invert__(self) -> BitwiseNegated: ...

class BitwiseNegated(BitwiseMixin, WrappedNode):
    def __invert__(self): ...
    def __sql__(self, ctx): ...

class Value(ColumnBase):
    value: Incomplete
    converter: Incomplete
    multi: Incomplete
    values: list[Incomplete]
    def __init__(self, value, converter=None, unpack: bool = True) -> None: ...
    def __sql__(self, ctx): ...

class ValueLiterals(WrappedNode):
    def __sql__(self, ctx): ...

def AsIs(value, converter=None) -> Value: ...

class Cast(WrappedNode):
    def __init__(self, node, cast) -> None: ...
    def __sql__(self, ctx): ...

class Ordering(WrappedNode):
    direction: Incomplete
    collation: Incomplete
    nulls: Incomplete
    def __init__(self, node, direction, collation=None, nulls=None) -> None: ...
    def collate(self, collation=None) -> Ordering: ...  # type: ignore[override]
    def __sql__(self, ctx): ...

class Expression(ColumnBase):
    lhs: Incomplete
    op: Incomplete
    rhs: Incomplete
    flat: bool
    def __init__(self, lhs, op, rhs, flat: bool = False) -> None: ...
    def __sql__(self, ctx): ...

class StringExpression(Expression):
    def __add__(self, rhs) -> StringExpression: ...
    def __radd__(self, lhs) -> StringExpression: ...

class Entity(ColumnBase):
    def __init__(self, *path) -> None: ...
    def __getattr__(self, attr: str) -> Entity: ...
    def get_sort_key(self, ctx) -> tuple[Incomplete, ...]: ...
    def __hash__(self) -> int: ...
    def __sql__(self, ctx): ...

class SQL(ColumnBase):
    sql: Incomplete
    params: Incomplete
    def __init__(self, sql, params=None) -> None: ...
    def __sql__(self, ctx): ...

def Check(constraint, name=None): ...

class Function(ColumnBase):
    no_coerce_functions: ClassVar[set[str]]
    name: Incomplete
    arguments: Incomplete
    def __init__(self, name, arguments, coerce: bool = True, python_value=None) -> None: ...
    def __getattr__(self, attr: str): ...
    def filter(self, where=None) -> Self: ...
    def order_by(self, *ordering) -> Self: ...
    def python_value(self, func=None) -> Self: ...
    def over(
        self, partition_by=None, order_by=None, start=None, end=None, frame_type=None, window=None, exclude=None
    ) -> NodeList: ...
    def __sql__(self, ctx): ...

fn: Incomplete

class Window(Node):
    CURRENT_ROW: SQL
    GROUP: SQL
    TIES: SQL
    NO_OTHERS: SQL
    GROUPS: str
    RANGE: str
    ROWS: str
    partition_by: Incomplete
    order_by: Incomplete
    start: Incomplete
    end: Incomplete
    frame_type: Incomplete
    def __init__(
        self,
        partition_by=None,
        order_by=None,
        start=None,
        end=None,
        frame_type=None,
        extends=None,
        exclude=None,
        alias=None,
        _inline: bool = False,
    ) -> None: ...
    def alias(self, alias=None) -> Self: ...
    def as_range(self) -> Self: ...
    def as_rows(self) -> Self: ...
    def as_groups(self) -> Self: ...
    def extends(self, window=None) -> Self: ...
    def exclude(self, frame_exclusion=None) -> Self: ...
    @staticmethod
    def following(value=None) -> SQL: ...
    @staticmethod
    def preceding(value=None) -> SQL: ...
    def __sql__(self, ctx): ...

class WindowAlias(Node):
    window: Incomplete
    def __init__(self, window) -> None: ...
    def alias(self, window_alias) -> Self: ...
    def __sql__(self, ctx): ...

class ForUpdate(Node):
    def __init__(self, expr, of=None, nowait=None) -> None: ...
    def __sql__(self, ctx): ...

class Case(ColumnBase):
    predicate: Incomplete
    expression_tuples: Incomplete
    default: Incomplete | None
    def __init__(self, predicate, expression_tuples, default=None) -> None: ...
    def __sql__(self, ctx): ...

class NodeList(ColumnBase):
    nodes: Incomplete
    glue: Incomplete
    parens: Incomplete
    def __init__(self, nodes, glue: str = " ", parens: bool = False) -> None: ...
    def __sql__(self, ctx): ...

class _Namespace(Node):
    __slots__ = ("_name",)
    def __init__(self, name) -> None: ...
    def __getattr__(self, attr: str) -> NamespaceAttribute: ...
    __getitem__ = __getattr__

class NamespaceAttribute(ColumnBase):
    def __init__(self, namespace, attribute) -> None: ...
    def __sql__(self, ctx): ...

EXCLUDED: Incomplete

class DQ(ColumnBase):
    query: Incomplete
    def __init__(self, **query) -> None: ...
    def __invert__(self) -> Self: ...  # type: ignore[override]
    def clone(self) -> DQ: ...

Tuple: Incomplete

class QualifiedNames(WrappedNode):
    def __sql__(self, ctx): ...

class OnConflict(Node):
    def __init__(
        self,
        action=None,
        update=None,
        preserve=None,
        where=None,
        conflict_target=None,
        conflict_where=None,
        conflict_constraint=None,
    ) -> None: ...
    def get_conflict_statement(self, ctx, query): ...
    def get_conflict_update(self, ctx, query): ...
    def preserve(self, *columns) -> Self: ...
    def update(self, _data=None, **kwargs) -> Self: ...
    def where(self, *expressions) -> Self: ...
    def conflict_target(self, *constraints) -> Self: ...
    def conflict_where(self, *expressions) -> Self: ...
    def conflict_constraint(self, constraint) -> Self: ...

class BaseQuery(Node):
    default_row_type: Incomplete
    def __init__(self, _database=None, **kwargs) -> None: ...
    def bind(self, database=None) -> Self: ...
    def clone(self) -> Self: ...
    def dicts(self, as_dict: bool = True) -> Self: ...
    def tuples(self, as_tuple: bool = True) -> Self: ...
    def namedtuples(self, as_namedtuple: bool = True) -> Self: ...
    def objects(self, constructor=None) -> Self: ...
    def __sql__(self, ctx) -> None: ...
    def sql(self): ...
    def execute(self, database=None): ...
    def iterator(self, database=None): ...
    def __iter__(self): ...
    def __getitem__(self, value): ...
    def __len__(self) -> int: ...

class RawQuery(BaseQuery):
    def __init__(self, sql=None, params=None, **kwargs) -> None: ...
    def __sql__(self, ctx): ...

class Query(BaseQuery):
    def __init__(self, where=None, order_by=None, limit=None, offset=None, **kwargs) -> None: ...
    def with_cte(self, *cte_list) -> Self: ...
    def where(self, *expressions) -> Self: ...
    def orwhere(self, *expressions) -> Self: ...
    def order_by(self, *values) -> Self: ...
    def order_by_extend(self, *values) -> Self: ...
    def limit(self, value=None) -> Self: ...
    def offset(self, value=None) -> Self: ...
    def paginate(self, page, paginate_by: int = 20) -> Self: ...
    def __sql__(self, ctx): ...

class SelectQuery(Query):
    def union_all(self, other) -> CompoundSelectQuery: ...
    def __add__(self, other) -> CompoundSelectQuery: ...
    def union(self, other) -> CompoundSelectQuery: ...
    def __or__(self, other) -> CompoundSelectQuery: ...
    def intersect(self, other) -> CompoundSelectQuery: ...
    def __and__(self, other) -> CompoundSelectQuery: ...
    def except_(self, other) -> CompoundSelectQuery: ...
    def __sub__(self, other) -> CompoundSelectQuery: ...
    def __radd__(self, other) -> CompoundSelectQuery: ...
    def __ror__(self, other) -> CompoundSelectQuery: ...
    def __rand__(self, other) -> CompoundSelectQuery: ...
    def __rsub__(self, other) -> CompoundSelectQuery: ...
    def select_from(self, *columns) -> Select: ...

class SelectBase(_HashableSource, Source, SelectQuery):  # type: ignore[misc]
    def peek(self, database=None, n: int = 1): ...
    def first(self, database=None, n: int = 1): ...
    def scalar(self, database=None, as_tuple: bool = False, as_dict: bool = False): ...
    def scalars(self, database=None) -> Generator[Incomplete, None, None]: ...
    def count(self, database=None, clear_limit: bool = False): ...
    def exists(self, database=None) -> bool: ...
    def get(self, database=None): ...

class CompoundSelectQuery(SelectBase):
    lhs: Incomplete
    op: Incomplete
    rhs: Incomplete
    def __init__(self, lhs, op, rhs) -> None: ...
    def exists(self, database=None) -> bool: ...
    def __sql__(self, ctx): ...

class Select(SelectBase):
    def __init__(
        self,
        from_list=None,
        columns=None,
        group_by=None,
        having=None,
        distinct=None,
        windows=None,
        for_update=None,
        for_update_of=None,
        nowait=None,
        lateral=None,
        **kwargs,
    ) -> None: ...
    def clone(self) -> Self: ...
    def columns(self, *columns, **kwargs) -> Self: ...
    select = columns
    def select_extend(self, *columns) -> Self: ...
    @property
    def selected_columns(self): ...
    @selected_columns.setter
    def selected_columns(self, value) -> None: ...
    def from_(self, *sources) -> Self: ...
    def join(self, dest, join_type="INNER JOIN", on=None) -> Self: ...  # type: ignore[override]
    def left_outer_join(self, dest, on=None) -> Self: ...  # type: ignore[override]
    def group_by(self, *columns) -> Self: ...
    def group_by_extend(self, *values) -> Self: ...
    def having(self, *expressions) -> Self: ...
    def distinct(self, *columns) -> Self: ...
    def window(self, *windows) -> Self: ...
    def for_update(self, for_update: bool = True, of=None, nowait=None) -> Self: ...
    def lateral(self, lateral: bool = True) -> Self: ...
    def __sql_selection__(self, ctx, is_subquery: bool = False): ...
    def __sql__(self, ctx): ...

class _WriteQuery(Query):
    table: Incomplete
    def __init__(self, table, returning=None, **kwargs) -> None: ...
    def cte(self, name, recursive: bool = False, columns=None, materialized=None) -> CTE: ...
    def returning(self, *returning) -> Self: ...
    def apply_returning(self, ctx): ...
    def execute_returning(self, database): ...
    def handle_result(self, database, cursor): ...
    def __sql__(self, ctx): ...

class Update(_WriteQuery):
    def __init__(self, table, update=None, **kwargs) -> None: ...
    def from_(self, *sources) -> Self: ...
    def __sql__(self, ctx): ...

class Insert(_WriteQuery):
    SIMPLE: int
    QUERY: int
    MULTI: int

    class DefaultValuesException(Exception): ...

    def __init__(self, table, insert=None, columns=None, on_conflict=None, **kwargs) -> None: ...
    def where(self, *expressions): ...
    def as_rowcount(self, _as_rowcount: bool = True) -> Self: ...
    def on_conflict_ignore(self, ignore: bool = True) -> Self: ...
    def on_conflict_replace(self, replace: bool = True) -> Self: ...
    def on_conflict(self, *args, **kwargs) -> Self: ...
    def get_default_data(self): ...
    def get_default_columns(self) -> list[Incomplete] | None: ...
    def __sql__(self, ctx): ...
    def handle_result(self, database, cursor): ...

class Delete(_WriteQuery):
    def __sql__(self, ctx): ...

class Index(Node):
    def __init__(
        self, name, table, expressions, unique: bool = False, safe: bool = False, where=None, using=None, nulls_distinct=None
    ) -> None: ...
    def safe(self, _safe: bool = True) -> Self: ...
    def where(self, *expressions) -> Self: ...
    def using(self, _using=None) -> Self: ...
    def nulls_distinct(self, nulls_distinct=None) -> Self: ...
    def __sql__(self, ctx): ...

class ModelIndex(Index):
    def __init__(
        self, model, fields, unique: bool = False, safe: bool = True, where=None, using=None, name=None, nulls_distinct=None
    ) -> None: ...

class PeeweeException(Exception):
    def __init__(self, *args) -> None: ...

class ImproperlyConfigured(PeeweeException): ...
class DatabaseError(PeeweeException): ...
class DataError(DatabaseError): ...
class IntegrityError(DatabaseError): ...
class InterfaceError(PeeweeException): ...
class InternalError(DatabaseError): ...
class NotSupportedError(DatabaseError): ...
class OperationalError(DatabaseError): ...
class ProgrammingError(DatabaseError): ...

class ExceptionWrapper:
    __slots__ = ("exceptions",)
    exceptions: Incomplete
    def __init__(self, exceptions) -> None: ...
    def __enter__(self) -> None: ...
    def __exit__(
        self, exc_type: type[BaseException] | None, exc_value: BaseException | None, traceback: TracebackType | None
    ) -> None: ...

class IndexMetadata(NamedTuple):
    name: Incomplete
    sql: Incomplete
    columns: Incomplete
    unique: Incomplete
    table: Incomplete

class ColumnMetadata(NamedTuple):
    name: Incomplete
    data_type: Incomplete
    null: Incomplete
    primary_key: Incomplete
    table: Incomplete
    default: Incomplete

class ForeignKeyMetadata(NamedTuple):
    column: Incomplete
    dest_table: Incomplete
    dest_column: Incomplete
    table: Incomplete

class ViewMetadata(NamedTuple):
    name: Incomplete
    sql: Incomplete

class _ConnectionState:
    def __init__(self, **kwargs) -> None: ...
    closed: bool
    conn: Incomplete
    ctx: Incomplete
    transactions: Incomplete
    def reset(self) -> None: ...
    def set_connection(self, conn) -> None: ...

class _ConnectionLocal(_ConnectionState, threading.local): ...

class _NoopLock:
    __slots__ = ()
    def __enter__(self) -> Self: ...
    def __exit__(
        self, exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: TracebackType | None
    ) -> None: ...

class ConnectionContext(_callable_context_manager):
    __slots__ = ("db",)
    db: Incomplete
    def __init__(self, db) -> None: ...
    def __enter__(self) -> None: ...
    def __exit__(
        self, exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: TracebackType | None
    ) -> None: ...

class Database(_callable_context_manager):
    context_class: Incomplete
    field_types: Incomplete
    operations: Incomplete
    param: str
    quote: str
    server_version: Incomplete
    commit_select: bool
    compound_select_parentheses: Incomplete
    for_update: bool
    index_schema_prefix: bool
    index_using_precedes_table: bool
    limit_max: Incomplete
    nulls_ordering: bool
    returning_clause: bool
    safe_create_index: bool
    safe_drop_index: bool
    sequences: bool
    truncate_table: bool
    autoconnect: Incomplete
    thread_safe: Incomplete
    connect_params: Incomplete
    def __init__(
        self,
        database,
        thread_safe: bool = True,
        autorollback: bool = False,
        field_types=None,
        operations=None,
        autocommit=None,
        autoconnect: bool = True,
        **kwargs,
    ) -> None: ...
    database: Incomplete
    deferred: Incomplete
    def init(self, database, **kwargs) -> None: ...
    def __enter__(self) -> Self: ...
    def __exit__(
        self, exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: TracebackType | None
    ) -> None: ...
    def connection_context(self) -> ConnectionContext: ...
    def connect(self, reuse_if_open: bool = False) -> bool: ...
    def close(self) -> bool: ...
    def is_closed(self) -> bool: ...
    def is_connection_usable(self) -> bool: ...
    def connection(self): ...
    def cursor(self, named_cursor=None): ...
    def execute_sql(self, sql, params=None): ...
    def execute(self, query, **context_options): ...
    def get_context_options(self) -> dict[str, Incomplete]: ...
    def get_sql_context(self, **context_options) -> context_class: ...
    def conflict_statement(self, on_conflict, query): ...
    def conflict_update(self, on_conflict, query): ...
    def last_insert_id(self, cursor, query_type=None): ...
    def rows_affected(self, cursor): ...
    def default_values_insert(self, ctx): ...
    def session_start(self) -> _transaction: ...
    def session_commit(self) -> bool: ...
    def session_rollback(self) -> bool: ...
    def in_transaction(self) -> bool: ...
    def push_transaction(self, transaction) -> None: ...
    def pop_transaction(self): ...
    def transaction_depth(self) -> int: ...
    def top_transaction(self): ...
    def atomic(self, *args, **kwargs) -> _atomic: ...
    def manual_commit(self) -> _manual: ...
    def transaction(self, *args, **kwargs) -> _transaction: ...
    def savepoint(self) -> _savepoint: ...
    def begin(self) -> None: ...
    def commit(self) -> None: ...
    def rollback(self) -> None: ...
    def batch_commit(self, it, n) -> Generator[Incomplete, None, None]: ...
    def table_exists(self, table_name, schema: str | None = None) -> bool: ...
    def get_tables(self, schema: str | None = None) -> list[str]: ...
    def get_indexes(self, table, schema: str | None = None) -> list[IndexMetadata]: ...
    def get_columns(self, table, schema: str | None = None) -> list[ColumnMetadata]: ...
    def get_primary_keys(self, table, schema: str | None = None): ...
    def get_foreign_keys(self, table, schema: str | None = None) -> list[ForeignKeyMetadata]: ...
    def sequence_exists(self, seq) -> bool: ...
    def create_tables(self, models: Iterable[type[Model]], **options) -> None: ...
    def drop_tables(self, models: Iterable[type[Model]], **kwargs) -> None: ...
    def extract_date(self, date_part, date_field): ...
    def truncate_date(self, date_part, date_field): ...
    def to_timestamp(self, date_field): ...
    def from_timestamp(self, date_field): ...
    def random(self): ...
    def bind(self, models: Iterable[type[Model]], bind_refs: bool = True, bind_backrefs: bool = True) -> None: ...
    def bind_ctx(
        self, models: Iterable[type[Model]], bind_refs: bool = True, bind_backrefs: bool = True
    ) -> _BoundModelsContext: ...
    def get_noop_select(self, ctx): ...
    @property
    def Model(self) -> type[Model]: ...

class SqliteDatabase(Database):
    field_types: Incomplete
    operations: Incomplete
    index_schema_prefix: bool
    limit_max: int
    server_version: Incomplete
    truncate_table: bool
    nulls_ordering: bool
    def __init__(self, database, regexp_function: bool = False, *args, **kwargs) -> None: ...
    returning_clause: Incomplete
    def init(self, database, pragmas=None, timeout: int = 5, returning_clause=None, **kwargs) -> None: ...
    def pragma(self, key, value=..., permanent: bool = False, schema: str | None = None): ...
    cache_size: Incomplete
    foreign_keys: Incomplete
    journal_mode: Incomplete
    journal_size_limit: Incomplete
    mmap_size: Incomplete
    page_size: Incomplete
    read_uncommitted: Incomplete
    synchronous: Incomplete
    wal_autocheckpoint: Incomplete
    application_id: Incomplete
    user_version: Incomplete
    data_version: Incomplete
    @property
    def timeout(self): ...
    @timeout.setter
    def timeout(self, seconds) -> None: ...
    def register_aggregate(self, klass, name=None, num_params: int = -1) -> None: ...
    def aggregate(self, name=None, num_params: int = -1): ...
    def register_collation(self, fn, name=None) -> None: ...
    def collation(self, name=None): ...
    def register_function(self, fn, name: str | None = None, num_params: int = -1, deterministic: bool | None = None) -> None: ...
    def func(self, name: str | None = None, num_params: int = -1, deterministic: bool | None = None) -> Callable[[_F], _F]: ...
    def register_window_function(self, klass, name=None, num_params: int = -1) -> None: ...
    def window_function(self, name=None, num_params: int = -1): ...
    def unregister_aggregate(self, name) -> None: ...
    def unregister_collation(self, name) -> None: ...
    def unregister_function(self, name) -> None: ...
    def unregister_window_function(self, name) -> None: ...
    def load_extension(self, extension) -> None: ...
    def unload_extension(self, extension) -> None: ...
    def attach(self, filename, name) -> bool: ...
    def detach(self, name) -> bool: ...
    def last_insert_id(self, cursor, query_type=None): ...
    def rows_affected(self, cursor): ...
    def begin(self, lock_type=None) -> None: ...
    def get_tables(self, schema: str | None = None) -> list[str]: ...
    def get_views(self, schema: str | None = None) -> list[ViewMetadata]: ...
    def get_indexes(self, table, schema: str | None = None) -> list[IndexMetadata]: ...
    def get_columns(self, table, schema: str | None = None) -> list[ColumnMetadata]: ...
    def get_primary_keys(self, table, schema: str | None = None) -> list[Incomplete]: ...
    def get_foreign_keys(self, table, schema: str | None = None) -> list[ForeignKeyMetadata]: ...
    def get_binary_type(self): ...
    def conflict_statement(self, on_conflict, query) -> SQL | None: ...
    def conflict_update(self, oc, query) -> SQL | NodeList | None: ...
    def extract_date(self, date_part, date_field) -> Function: ...
    def truncate_date(self, date_part, date_field) -> Function: ...
    def to_timestamp(self, date_field) -> Cast: ...
    def from_timestamp(self, date_field) -> Function: ...

class Psycopg2Adapter:
    json_type: Incomplete
    jsonb_type: Incomplete
    cast_json_case: bool
    def __init__(self) -> None: ...
    def check_driver(self) -> None: ...
    def get_binary_type(self) -> type[Incomplete]: ...
    def connect(self, db, **params): ...
    def get_server_version(self, conn): ...
    def is_connection_usable(self, conn) -> bool: ...
    def is_connection_reusable(self, conn) -> bool: ...
    def is_connection_closed(self, conn) -> bool: ...
    def extract_date(self, date_part, date_field) -> Function: ...

class Psycopg3Adapter:
    json_type: Incomplete
    jsonb_type: Incomplete
    cast_json_case: bool
    def __init__(self) -> None: ...
    def check_driver(self) -> None: ...
    def get_binary_type(self) -> type[Incomplete]: ...
    def connect(self, db, **params): ...
    def get_server_version(self, conn): ...
    def is_connection_usable(self, conn) -> bool: ...
    def is_connection_reusable(self, conn) -> bool: ...
    def is_connection_closed(self, conn) -> bool: ...
    def extract_date(self, date_part, date_field) -> Function: ...

class PostgresqlDatabase(Database):
    field_types: Incomplete
    operations: Incomplete
    param: str
    commit_select: bool
    compound_select_parentheses: Incomplete
    for_update: bool
    nulls_ordering: bool
    returning_clause: bool
    safe_create_index: bool
    sequences: bool
    psycopg2_adapter: Incomplete
    psycopg3_adapter: Incomplete
    def init(
        self,
        database,
        register_unicode: bool = True,
        encoding=None,
        isolation_level=None,
        *,
        prefer_psycopg3: bool = False,
        **kwargs,
    ) -> None: ...
    def is_connection_usable(self) -> bool: ...
    def last_insert_id(self, cursor, query_type=None): ...
    def rows_affected(self, cursor): ...
    def begin(self, isolation_level: str | None = None) -> None: ...
    def get_tables(self, schema: str | None = None) -> list[str]: ...
    def get_views(self, schema: str | None = None) -> list[ViewMetadata]: ...
    def get_indexes(self, table, schema: str | None = None) -> list[IndexMetadata]: ...
    def get_columns(self, table, schema: str | None = None) -> list[ColumnMetadata]: ...
    def get_primary_keys(self, table, schema: str | None = None) -> list[Incomplete]: ...
    def get_foreign_keys(self, table, schema: str | None = None) -> list[ForeignKeyMetadata]: ...
    def sequence_exists(self, sequence) -> bool: ...
    def get_binary_type(self) -> type[Incomplete]: ...
    def conflict_statement(self, on_conflict, query) -> None: ...
    def conflict_update(self, oc, query) -> NodeList: ...
    def extract_date(self, date_part, date_field) -> Function: ...
    def truncate_date(self, date_part, date_field) -> Function: ...
    def to_timestamp(self, date_field) -> Function: ...
    def from_timestamp(self, date_field) -> Function: ...
    def get_noop_select(self, ctx): ...
    def set_time_zone(self, timezone) -> None: ...

class MySQLDatabase(Database):
    field_types: Incomplete
    operations: Incomplete
    param: str
    quote: str
    commit_select: bool
    compound_select_parentheses: Incomplete
    for_update: bool
    index_using_precedes_table: bool
    limit_max: Incomplete
    safe_create_index: bool
    safe_drop_index: bool
    sql_mode: str
    def init(self, database, **kwargs) -> None: ...
    def is_connection_usable(self) -> bool: ...
    def default_values_insert(self, ctx): ...
    def begin(self, isolation_level: str | None = None) -> None: ...
    def get_tables(self, schema: str | None = None) -> list[str]: ...
    def get_views(self, schema: str | None = None) -> list[ViewMetadata]: ...
    def get_indexes(self, table, schema: str | None = None) -> list[IndexMetadata]: ...
    def get_columns(self, table, schema: str | None = None) -> list[ColumnMetadata]: ...
    def get_primary_keys(self, table, schema: str | None = None) -> list[Incomplete]: ...
    def get_foreign_keys(self, table, schema: str | None = None) -> list[ForeignKeyMetadata]: ...
    def get_binary_type(self): ...
    def conflict_statement(self, on_conflict, query) -> SQL | None: ...
    def conflict_update(self, on_conflict, query) -> NodeList | None: ...
    def extract_date(self, date_part, date_field) -> Function: ...
    def truncate_date(self, date_part, date_field) -> Function: ...
    def to_timestamp(self, date_field) -> Function: ...
    def from_timestamp(self, date_field) -> Function: ...
    def random(self) -> Function: ...
    def get_noop_select(self, ctx): ...

class _manual(_callable_context_manager):
    db: Incomplete
    def __init__(self, db) -> None: ...
    def __enter__(self) -> None: ...
    def __exit__(
        self, exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: TracebackType | None
    ) -> None: ...

class _atomic(_callable_context_manager):
    db: Incomplete
    def __init__(self, db, *args, **kwargs) -> None: ...
    def __enter__(self): ...
    def __exit__(self, exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: TracebackType | None): ...

class _transaction(_callable_context_manager):
    db: Incomplete
    def __init__(self, db, *args, **kwargs) -> None: ...
    def commit(self, begin: bool = True) -> None: ...
    def rollback(self, begin: bool = True) -> None: ...
    def __enter__(self) -> Self: ...
    def __exit__(
        self, exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: TracebackType | None
    ) -> None: ...

class _savepoint(_callable_context_manager):
    db: Incomplete
    sid: Incomplete
    quoted_sid: Incomplete
    def __init__(self, db, sid=None) -> None: ...
    def commit(self, begin: bool = True) -> None: ...
    def rollback(self) -> None: ...
    def __enter__(self) -> Self: ...
    def __exit__(
        self, exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: TracebackType | None
    ) -> None: ...

class CursorWrapper:
    cursor: Incomplete
    count: int
    index: int
    initialized: bool
    populated: bool
    row_cache: list[Incomplete]
    def __init__(self, cursor) -> None: ...
    def __iter__(self): ...
    def __getitem__(self, item): ...
    def __len__(self) -> int: ...
    def initialize(self) -> None: ...
    def iterate(self, cache: bool = True): ...
    def process_row(self, row): ...
    def iterator(self) -> Generator[Incomplete, None, None]: ...
    def fill_cache(self, n: int = 0) -> None: ...

class DictCursorWrapper(CursorWrapper):
    def initialize(self) -> None: ...
    def process_row(self, row): ...

class NamedTupleCursorWrapper(CursorWrapper):
    tuple_class: Incomplete
    def initialize(self) -> None: ...
    def process_row(self, row): ...

class ObjectCursorWrapper(DictCursorWrapper):
    constructor: Incomplete
    def __init__(self, cursor, constructor) -> None: ...
    def process_row(self, row): ...

class ResultIterator:
    cursor_wrapper: Incomplete
    index: int
    def __init__(self, cursor_wrapper) -> None: ...
    def __iter__(self) -> Self: ...
    def next(self): ...
    __next__ = next

class FieldAccessor:
    model: Incomplete
    field: Incomplete
    name: Incomplete
    def __init__(self, model, field, name) -> None: ...
    def __get__(self, instance, instance_type=None): ...
    def __set__(self, instance, value) -> None: ...

class ForeignKeyAccessor(FieldAccessor):
    rel_model: Incomplete
    def __init__(self, model, field, name) -> None: ...
    def get_rel_instance(self, instance): ...
    def __get__(self, instance, instance_type=None): ...
    def __set__(self, instance, obj) -> None: ...

class BackrefAccessor:
    field: Incomplete
    model: Incomplete
    rel_model: Incomplete
    def __init__(self, field) -> None: ...
    def __get__(self, instance, instance_type=None): ...

class ObjectIdAccessor:
    field: Incomplete
    def __init__(self, field) -> None: ...
    def __get__(self, instance, instance_type=None): ...
    def __set__(self, instance, value) -> None: ...

class Field(ColumnBase):
    accessor_class: Incomplete
    auto_increment: bool
    default_index_type: Incomplete
    field_type: ClassVar[str]
    unpack: bool
    null: Incomplete
    index: Incomplete
    unique: Incomplete
    column_name: Incomplete
    default: Incomplete
    primary_key: Incomplete
    constraints: Incomplete
    sequence: Incomplete
    collation: Incomplete
    unindexed: Incomplete
    choices: Incomplete
    help_text: Incomplete
    verbose_name: Incomplete
    index_type: Incomplete
    def __init__(
        self,
        null: bool = False,
        index: bool = False,
        unique: bool = False,
        column_name=None,
        default=None,
        primary_key: bool = False,
        constraints=None,
        sequence=None,
        collation=None,
        unindexed: bool = False,
        choices=None,
        help_text=None,
        verbose_name=None,
        index_type=None,
        db_column=None,
        _hidden: bool = False,
    ) -> None: ...
    def __hash__(self) -> int: ...
    model: Incomplete
    name: Incomplete
    def bind(self, model, name, set_attribute: bool = True) -> None: ...
    @property
    def column(self) -> Column: ...
    def adapt(self, value): ...
    def db_value(self, value): ...
    def python_value(self, value): ...
    def to_value(self, value, case: bool = False) -> Value: ...
    def get_sort_key(self, ctx) -> tuple[Incomplete, ...]: ...
    def __sql__(self, ctx): ...
    def get_modifiers(self) -> list[int] | None: ...
    def ddl_datatype(self, ctx) -> SQL: ...
    def ddl(self, ctx) -> NodeList: ...

class AnyField(Field): ...

class IntegerField(Field):
    def adapt(self, value): ...

class BigIntegerField(IntegerField): ...
class SmallIntegerField(IntegerField): ...

class AutoField(IntegerField):
    auto_increment: bool
    def __init__(self, *args, **kwargs) -> None: ...

class BigAutoField(AutoField): ...

class IdentityField(AutoField):
    def __init__(self, generate_always: bool = False, **kwargs) -> None: ...

class PrimaryKeyField(AutoField):
    def __init__(self, *args, **kwargs) -> None: ...

class FloatField(Field):
    def adapt(self, value): ...

class DoubleField(FloatField): ...

class DecimalField(Field):
    max_digits: Incomplete
    decimal_places: Incomplete
    auto_round: Incomplete
    rounding: Incomplete
    def __init__(
        self, max_digits: int = 10, decimal_places: int = 5, auto_round: bool = False, rounding=None, *args, **kwargs
    ) -> None: ...
    def get_modifiers(self) -> list[int]: ...
    def db_value(self, value): ...
    def python_value(self, value) -> Decimal | None: ...

class _StringField(Field):
    def adapt(self, value) -> str: ...
    def __add__(self, other) -> StringExpression: ...
    def __radd__(self, other) -> StringExpression: ...

class CharField(_StringField):
    max_length: int
    def __init__(self, max_length: int = 255, *args, **kwargs) -> None: ...
    def get_modifiers(self) -> list[int] | None: ...

class FixedCharField(CharField):
    def python_value(self, value): ...

class TextField(_StringField): ...

class FieldDatabaseHook:
    def bind(self, model, name, set_attribute: bool = True): ...

class BlobField(FieldDatabaseHook, Field):
    def db_value(self, value): ...

class BitField(BitwiseMixin, BigIntegerField):
    def __init__(self, *args, **kwargs) -> None: ...
    def flag(self, value=None): ...

class BigBitFieldData:
    instance: Incomplete
    name: Incomplete
    def __init__(self, instance, name) -> None: ...
    def clear(self) -> None: ...
    def set_bit(self, idx) -> None: ...
    def clear_bit(self, idx) -> None: ...
    def toggle_bit(self, idx) -> bool: ...
    def is_set(self, idx) -> bool: ...
    __getitem__ = is_set
    def __setitem__(self, item: int, value: bool) -> None: ...
    __delitem__ = clear_bit
    def __len__(self) -> int: ...
    def __and__(self, other: BigBitFieldData | bytes | bytearray | memoryview) -> bytearray: ...
    def __or__(self, other: BigBitFieldData | bytes | bytearray | memoryview) -> bytearray: ...
    def __xor__(self, other: BigBitFieldData | bytes | bytearray | memoryview) -> bytearray: ...
    def __iter__(self) -> Iterator[Literal[0, 1]]: ...
    def __bytes__(self) -> bytes: ...

class BigBitFieldAccessor(FieldAccessor):
    def __get__(self, instance, instance_type=None): ...
    def __set__(self, instance, value) -> None: ...

class BigBitField(BlobField):
    accessor_class: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    def db_value(self, value): ...

class UUIDField(Field):
    def db_value(self, value): ...
    def python_value(self, value) -> UUID | None: ...

class BinaryUUIDField(BlobField):
    def db_value(self, value): ...
    def python_value(self, value) -> UUID | None: ...

class _BaseFormattedField(Field):
    formats: Incomplete
    def __init__(self, formats=None, *args, **kwargs) -> None: ...

class DateTimeField(_BaseFormattedField):
    formats: Incomplete
    def adapt(self, value): ...
    def to_timestamp(self): ...
    def truncate(self, part): ...
    @property
    def year(self): ...
    @property
    def month(self): ...
    @property
    def day(self): ...
    @property
    def hour(self): ...
    @property
    def minute(self): ...
    @property
    def second(self): ...

class DateField(_BaseFormattedField):
    formats: Incomplete
    def adapt(self, value): ...
    def to_timestamp(self): ...
    def truncate(self, part): ...
    @property
    def year(self): ...
    @property
    def month(self): ...
    @property
    def day(self): ...

class TimeField(_BaseFormattedField):
    formats: Incomplete
    def adapt(self, value): ...
    @property
    def hour(self): ...
    @property
    def minute(self): ...
    @property
    def second(self): ...

class TimestampField(BigIntegerField):
    valid_resolutions: Incomplete
    resolution: Incomplete
    ticks_to_microsecond: Incomplete
    utc: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    def local_to_utc(self, dt) -> datetime: ...
    def utc_to_local(self, dt) -> datetime: ...
    def get_timestamp(self, value) -> float: ...
    def db_value(self, value) -> int | None: ...
    def python_value(self, value): ...
    def from_timestamp(self): ...
    @property
    def year(self): ...
    @property
    def month(self): ...
    @property
    def day(self): ...
    @property
    def hour(self): ...
    @property
    def minute(self): ...
    @property
    def second(self): ...

class IPField(BigIntegerField):
    def db_value(self, val): ...
    def python_value(self, val) -> str | None: ...

class BooleanField(Field):
    adapt: Incomplete

class BareField(Field):
    adapt: Incomplete
    def __init__(self, adapt=None, *args, **kwargs) -> None: ...
    def ddl_datatype(self, ctx): ...

class ForeignKeyField(Field):
    accessor_class: Incomplete
    backref_accessor_class: Incomplete
    rel_model: Incomplete
    rel_field: Incomplete
    declared_backref: Incomplete
    backref: Incomplete
    on_delete: Incomplete
    on_update: Incomplete
    deferrable: Incomplete
    deferred: Incomplete
    object_id_name: Incomplete
    lazy_load: Incomplete
    constraint_name: str | None
    def __init__(
        self,
        model,
        field=None,
        backref=None,
        on_delete=None,
        on_update=None,
        deferrable=None,
        _deferred=None,
        rel_model=None,
        to_field=None,
        object_id_name=None,
        lazy_load: bool = True,
        constraint_name: str | None = None,
        related_name=None,
        *args,
        **kwargs,
    ) -> None: ...
    @property
    def field_type(self): ...  # type: ignore[override]
    def get_modifiers(self): ...
    def adapt(self, value): ...
    def db_value(self, value): ...
    def python_value(self, value): ...
    column_name: Incomplete
    safe_name: Incomplete
    def bind(self, model, name, set_attribute: bool = True) -> None: ...
    def foreign_key_constraint(self, explicit_name: bool = False) -> NodeList: ...
    def get_constraint_name(self) -> str: ...
    def __getattr__(self, attr: str): ...

class DeferredForeignKey(Field):
    field_kwargs: Incomplete
    rel_model_name: Incomplete
    def __init__(self, rel_model_name, **kwargs) -> None: ...
    __hash__ = object.__hash__
    def __deepcopy__(self, memo=None) -> DeferredForeignKey: ...
    def set_model(self, rel_model) -> None: ...
    @staticmethod
    def resolve(model_cls) -> None: ...

class DeferredThroughModel:
    def __init__(self) -> None: ...
    def set_field(self, model, field, name) -> None: ...
    def set_model(self, through_model) -> None: ...

class MetaField(Field):
    column_name: Incomplete
    default: Incomplete
    model: Incomplete
    name: Incomplete
    primary_key: bool

class ManyToManyFieldAccessor(FieldAccessor):
    model: Incomplete
    rel_model: Incomplete
    through_model: Incomplete
    src_fk: Incomplete
    dest_fk: Incomplete
    def __init__(self, model, field, name) -> None: ...
    def __get__(self, instance, instance_type=None, force_query: bool = False): ...
    def __set__(self, instance, value) -> None: ...

class ManyToManyField(MetaField):
    accessor_class: Incomplete
    rel_model: Incomplete
    backref: Incomplete
    def __init__(
        self,
        model,
        backref=None,
        through_model=None,
        on_delete=None,
        on_update=None,
        prevent_unsaved: bool = True,
        _is_backref: bool = False,
    ) -> None: ...
    def bind(self, model, name, set_attribute: bool = True) -> None: ...
    def get_models(self) -> list[Incomplete]: ...
    @property
    def through_model(self): ...
    @through_model.setter
    def through_model(self, value) -> None: ...
    def get_through_model(self): ...

class VirtualField(MetaField):
    field_class: Incomplete
    field_instance: Incomplete
    def __init__(self, field_class=None, *args, **kwargs) -> None: ...
    def db_value(self, value): ...
    def python_value(self, value): ...
    model: Incomplete
    column_name: Incomplete
    def bind(self, model, name, set_attribute: bool = True) -> None: ...

class CompositeKey(MetaField):
    sequence: Incomplete
    field_names: Incomplete
    def __init__(self, *field_names) -> None: ...
    @property
    def safe_field_names(self): ...
    def __get__(self, instance, instance_type=None): ...
    def __set__(self, instance, value) -> None: ...
    def __eq__(self, other) -> Expression | bool: ...  # type: ignore[override]
    def __ne__(self, other) -> Expression | bool: ...  # type: ignore[override]
    def __hash__(self) -> int: ...
    def __sql__(self, ctx): ...
    model: Incomplete
    column_name: Incomplete
    def bind(self, model, name, set_attribute: bool = True) -> None: ...

class _SortedFieldList:
    __slots__ = ("_keys", "_items")
    def __init__(self) -> None: ...
    def __getitem__(self, i): ...
    def __iter__(self): ...
    def __contains__(self, item) -> bool: ...
    def index(self, field) -> int: ...
    def insert(self, item) -> None: ...
    def remove(self, item) -> None: ...

class SchemaManager:
    model: Incomplete
    context_options: Incomplete
    def __init__(self, model, database=None, **context_options) -> None: ...
    @property
    def database(self): ...
    @database.setter
    def database(self, value) -> None: ...
    def create_table(self, safe: bool = True, **options) -> None: ...
    def create_table_as(self, table_name, query, safe: bool = True, **meta) -> None: ...
    def drop_table(self, safe: bool = True, **options) -> None: ...
    def truncate_table(self, restart_identity: bool = False, cascade: bool = False) -> None: ...
    def create_indexes(self, safe: bool = True) -> None: ...
    def drop_indexes(self, safe: bool = True) -> None: ...
    def create_sequence(self, field) -> None: ...
    def drop_sequence(self, field) -> None: ...
    def create_foreign_key(self, field) -> None: ...
    def create_sequences(self) -> None: ...
    def create_all(self, safe: bool = True, **table_options) -> None: ...
    def drop_sequences(self) -> None: ...
    def drop_all(self, safe: bool = True, drop_sequences: bool = True, **options) -> None: ...

class Metadata:
    model: Incomplete
    database: Incomplete
    fields: Incomplete
    columns: Incomplete
    combined: Incomplete
    sorted_fields: Incomplete
    sorted_field_names: Incomplete
    defaults: Incomplete
    name: Incomplete
    table_function: Incomplete
    legacy_table_names: Incomplete
    table_name: Incomplete
    indexes: Incomplete
    constraints: Incomplete
    primary_key: Incomplete
    composite_key: Incomplete
    only_save_dirty: Incomplete
    depends_on: Incomplete
    table_settings: Incomplete
    without_rowid: Incomplete
    strict_tables: Incomplete
    temporary: Incomplete
    refs: Incomplete
    backrefs: Incomplete
    model_refs: Incomplete
    model_backrefs: Incomplete
    manytomany: Incomplete
    options: Incomplete
    def __init__(
        self,
        model,
        database=None,
        table_name=None,
        indexes=None,
        primary_key=None,
        constraints=None,
        schema: str | None = None,
        only_save_dirty: bool = False,
        depends_on=None,
        options=None,
        db_table=None,
        table_function=None,
        table_settings=None,
        without_rowid: bool = False,
        temporary: bool = False,
        strict_tables=None,
        legacy_table_names: bool = True,
        **kwargs,
    ) -> None: ...
    def make_table_name(self) -> str: ...
    def model_graph(
        self, refs: bool = True, backrefs: bool = True, depth_first: bool = True
    ) -> list[tuple[Incomplete, Incomplete, Incomplete]]: ...
    def add_ref(self, field) -> None: ...
    def remove_ref(self, field) -> None: ...
    def add_manytomany(self, field) -> None: ...
    def remove_manytomany(self, field) -> None: ...
    @property
    def table(self) -> Table: ...
    @table.deleter
    def table(self) -> None: ...
    @property
    def schema(self): ...
    @schema.setter
    def schema(self, value) -> None: ...
    @property
    def entity(self) -> Entity: ...
    def get_rel_for_model(self, model) -> tuple[list[Incomplete], list[Incomplete]]: ...
    def add_field(self, field_name, field, set_attribute: bool = True) -> None: ...
    def remove_field(self, field_name) -> None: ...
    auto_increment: Incomplete
    def set_primary_key(self, name, field) -> None: ...
    def get_primary_keys(self): ...
    def get_default_dict(self): ...
    def fields_to_index(self) -> list[Incomplete]: ...
    def set_database(self, database) -> None: ...
    def set_table_name(self, table_name) -> None: ...

class SubclassAwareMetadata(Metadata):
    models: Incomplete
    def __init__(self, model, *args, **kwargs) -> None: ...
    def map_models(self, fn) -> None: ...

class DoesNotExist(Exception): ...

class ModelBase(type):
    inheritable: set[str]
    def __new__(cls, name, bases, attrs): ...
    def __iter__(self): ...
    def __getitem__(self, key): ...
    def __setitem__(self, key, value) -> None: ...
    def __delitem__(self, key) -> None: ...
    def __contains__(self, key) -> bool: ...
    def __len__(self) -> int: ...
    def __bool__(self) -> bool: ...
    def __nonzero__(self) -> bool: ...
    def __sql__(self, ctx): ...

class _BoundModelsContext(_callable_context_manager):
    models: Incomplete
    database: Incomplete
    bind_refs: Incomplete
    bind_backrefs: Incomplete
    def __init__(self, models, database, bind_refs, bind_backrefs) -> None: ...
    def __enter__(self): ...
    def __exit__(
        self, exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: TracebackType | None
    ) -> None: ...

class Model(metaclass=ModelBase):
    __data__: Incomplete
    __rel__: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    @classmethod
    def validate_model(cls) -> None: ...
    @classmethod
    def alias(cls, alias=None) -> ModelAlias: ...
    @classmethod
    def select(cls, *fields) -> ModelSelect: ...
    @classmethod
    def update(cls, data=None, /, **update) -> ModelUpdate: ...
    @classmethod
    def insert(cls, data=None, /, **insert) -> ModelInsert: ...
    @classmethod
    def insert_many(cls, rows, fields=None) -> ModelInsert: ...
    @classmethod
    def insert_from(cls, query, fields) -> ModelInsert: ...
    @classmethod
    def replace(cls, data=None, /, **insert): ...
    @classmethod
    def replace_many(cls, rows, fields=None): ...
    @classmethod
    def raw(cls, sql, *params) -> ModelRaw: ...
    @classmethod
    def delete(cls) -> ModelDelete: ...
    @classmethod
    def create(cls, **query) -> Self: ...
    @classmethod
    def bulk_create(cls, model_list, batch_size=None) -> None: ...
    @classmethod
    def bulk_update(cls, model_list, fields, batch_size=None): ...
    @classmethod
    def noop(cls) -> NoopModelSelect: ...
    @classmethod
    def get(cls, *query, **filters): ...
    @classmethod
    def get_or_none(cls, *query, **filters): ...
    @classmethod
    def get_by_id(cls, pk): ...
    @classmethod
    def set_by_id(cls, key, value): ...
    @classmethod
    def delete_by_id(cls, pk): ...
    @classmethod
    def get_or_create(cls, **kwargs): ...
    @classmethod
    def filter(cls, *dq_nodes, **filters): ...
    def get_id(self): ...
    def save(self, force_insert: bool = False, only=None): ...
    def is_dirty(self) -> bool: ...
    @property
    def dirty_fields(self) -> list[Incomplete]: ...
    @property
    def dirty_field_names(self) -> list[Incomplete]: ...
    def dependencies(
        self, search_nullable: bool = True, exclude_null_children: bool = False
    ) -> Generator[Incomplete, None, None]: ...
    def delete_instance(self, recursive: bool = False, delete_nullable: bool = False): ...
    def __hash__(self) -> int: ...
    def __eq__(self, other) -> Expression | bool: ...  # type: ignore[override]
    def __ne__(self, other) -> Expression | bool: ...  # type: ignore[override]
    def __sql__(self, ctx): ...
    @classmethod
    def bind(cls, database, bind_refs: bool = True, bind_backrefs: bool = True, _exclude=None) -> bool: ...
    @classmethod
    def bind_ctx(cls, database, bind_refs: bool = True, bind_backrefs: bool = True) -> _BoundModelsContext: ...
    @classmethod
    def table_exists(cls): ...
    @classmethod
    def create_table(cls, safe: bool = True, **options) -> None: ...
    @classmethod
    def drop_table(cls, safe: bool = True, drop_sequences: bool = True, **options) -> None: ...
    @classmethod
    def truncate_table(cls, **options) -> None: ...
    @classmethod
    def index(cls, *fields, **kwargs) -> ModelIndex: ...
    @classmethod
    def add_index(cls, *fields, **kwargs) -> None: ...

class ModelAlias(Node):
    def __init__(self, model, alias=None) -> None: ...
    def __getattr__(self, attr: str): ...
    def __setattr__(self, attr: str, value) -> None: ...
    def get_field_aliases(self) -> list[Incomplete]: ...
    def select(self, *selection) -> ModelSelect: ...
    def __call__(self, **kwargs): ...
    def __sql__(self, ctx): ...

class FieldAlias(Field):
    source: Incomplete
    model: Incomplete
    field: Incomplete
    def __init__(self, source, field) -> None: ...
    @classmethod
    def create(cls, source, field): ...
    def clone(self) -> FieldAlias: ...
    def adapt(self, value): ...
    def python_value(self, value): ...
    def db_value(self, value): ...
    def __getattr__(self, attr: str): ...
    def __sql__(self, ctx): ...

class _ModelQueryHelper:
    default_row_type: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    def objects(self, constructor=None) -> Self: ...

class ModelRaw(_ModelQueryHelper, RawQuery):  # type: ignore[misc]
    model: Incomplete
    def __init__(self, model, sql, params, **kwargs) -> None: ...
    def get(self): ...

class BaseModelSelect(_ModelQueryHelper):
    def union_all(self, rhs) -> ModelCompoundSelectQuery: ...
    __add__ = union_all
    def union(self, rhs) -> ModelCompoundSelectQuery: ...
    __or__ = union
    def intersect(self, rhs) -> ModelCompoundSelectQuery: ...
    __and__ = intersect
    def except_(self, rhs) -> ModelCompoundSelectQuery: ...
    __sub__ = except_
    def __iter__(self): ...
    def prefetch(self, *subqueries): ...
    def get(self, database=None): ...
    def get_or_none(self, database=None): ...
    def group_by(self, *columns) -> Self: ...

class ModelCompoundSelectQuery(BaseModelSelect, CompoundSelectQuery):  # type: ignore[misc]
    model: Incomplete
    def __init__(self, model, *args, **kwargs) -> None: ...

class ModelSelect(BaseModelSelect, Select):  # type: ignore[misc]
    model: Incomplete
    def __init__(self, model, fields_or_models, is_default: bool = False) -> None: ...
    def clone(self) -> Self: ...
    def select(self, *fields_or_models): ...
    def select_extend(self, *columns): ...
    def switch(self, ctx=None) -> Self: ...
    def join(self, dest, join_type="INNER JOIN", on=None, src=None, attr=None) -> Self: ...  # type: ignore[override]
    def left_outer_join(self, dest, on=None, src=None, attr=None) -> Self: ...  # type: ignore[override]
    def join_from(self, src, dest, join_type="INNER JOIN", on=None, attr=None) -> Self: ...
    def ensure_join(self, lm, rm, on=None, **join_kwargs): ...
    def convert_dict_to_node(self, qdict) -> tuple[list[Incomplete], list[Incomplete]]: ...
    def filter(self, *args, **kwargs): ...
    def create_table(self, name, safe: bool = True, **meta): ...
    def __sql_selection__(self, ctx, is_subquery: bool = False): ...

class NoopModelSelect(ModelSelect):
    def __sql__(self, ctx): ...

class _ModelWriteQueryHelper(_ModelQueryHelper):
    model: Incomplete
    def __init__(self, model, *args, **kwargs) -> None: ...
    def returning(self, *returning): ...

class ModelUpdate(_ModelWriteQueryHelper, Update): ...  # type: ignore[misc]

class ModelInsert(_ModelWriteQueryHelper, Insert):  # type: ignore[misc]
    default_row_type: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    def returning(self, *returning): ...
    def get_default_data(self): ...
    def get_default_columns(self): ...

class ModelDelete(_ModelWriteQueryHelper, Delete): ...  # type: ignore[misc]

class ManyToManyQuery(ModelSelect):
    def __init__(self, instance, accessor, rel, *args, **kwargs) -> None: ...
    def add(self, value, clear_existing: bool = False) -> None: ...
    def remove(self, value): ...
    def clear(self): ...

class BaseModelCursorWrapper(DictCursorWrapper):
    model: Incomplete
    select: Incomplete
    def __init__(self, cursor, model, columns) -> None: ...
    initialize: Incomplete
    def process_row(self, row): ...

class ModelDictCursorWrapper(BaseModelCursorWrapper):
    def process_row(self, row) -> dict[Incomplete, Incomplete]: ...

class ModelTupleCursorWrapper(ModelDictCursorWrapper):
    constructor: Incomplete
    def process_row(self, row) -> tuple[Incomplete, ...]: ...  # type: ignore[override]

class ModelNamedTupleCursorWrapper(ModelTupleCursorWrapper):
    tuple_class: Incomplete
    constructor: Incomplete
    def initialize(self) -> None: ...

class ModelObjectCursorWrapper(ModelDictCursorWrapper):
    constructor: Incomplete
    is_model: Incomplete
    def __init__(self, cursor, model, select, constructor) -> None: ...
    def process_row(self, row): ...

class ModelCursorWrapper(BaseModelCursorWrapper):
    from_list: Incomplete
    joins: Incomplete
    def __init__(self, cursor, model, select, from_list, joins) -> None: ...
    key_to_constructor: Incomplete
    src_is_dest: Incomplete
    src_to_dest: Incomplete
    column_keys: Incomplete
    def initialize(self) -> None: ...
    def process_row(self, row): ...

class PrefetchQuery:
    def __new__(cls, query, fields=None, is_backref=None, rel_models=None, field_to_name=None, model=None) -> Self: ...
    def populate_instance(self, instance, id_map) -> None: ...
    def store_instance(self, instance, id_map) -> None: ...

def prefetch(sq, *subqueries): ...

__all__ = [
    "AnyField",
    "AsIs",
    "AutoField",
    "BareField",
    "BigAutoField",
    "BigBitField",
    "BigIntegerField",
    "BinaryUUIDField",
    "BitField",
    "BlobField",
    "BooleanField",
    "Case",
    "Cast",
    "CharField",
    "Check",
    "chunked",
    "Column",
    "CompositeKey",
    "Context",
    "Database",
    "DatabaseError",
    "DatabaseProxy",
    "DataError",
    "DateField",
    "DateTimeField",
    "DecimalField",
    "DeferredForeignKey",
    "DeferredThroughModel",
    "DJANGO_MAP",
    "DoesNotExist",
    "DoubleField",
    "DQ",
    "EXCLUDED",
    "Field",
    "FixedCharField",
    "FloatField",
    "fn",
    "ForeignKeyField",
    "IdentityField",
    "ImproperlyConfigured",
    "Index",
    "IntegerField",
    "IntegrityError",
    "InterfaceError",
    "InternalError",
    "IPField",
    "JOIN",
    "ManyToManyField",
    "Model",
    "ModelIndex",
    "MySQLDatabase",
    "NotSupportedError",
    "OP",
    "OperationalError",
    "PostgresqlDatabase",
    "PrimaryKeyField",
    "prefetch",
    "PREFETCH_TYPE",
    "ProgrammingError",
    "Proxy",
    "QualifiedNames",
    "SchemaManager",
    "SmallIntegerField",
    "Select",
    "SQL",
    "SqliteDatabase",
    "Table",
    "TextField",
    "TimeField",
    "TimestampField",
    "Tuple",
    "UUIDField",
    "Value",
    "ValuesList",
    "Window",
]
