"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import builtins
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.message
import google.protobuf.source_context_pb2
import google.protobuf.type_pb2
import typing
import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

class Api(google.protobuf.message.Message):
    """Api is a light-weight descriptor for an API Interface.

    Interfaces are also described as "protocol buffer services" in some contexts,
    such as by the "service" keyword in a .proto file, but they are different
    from API Services, which represent a concrete implementation of an interface
    as opposed to simply a description of methods and bindings. They are also
    sometimes simply referred to as "APIs" in other contexts, such as the name of
    this message itself. See https://cloud.google.com/apis/design/glossary for
    detailed terminology.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    NAME_FIELD_NUMBER: builtins.int
    METHODS_FIELD_NUMBER: builtins.int
    OPTIONS_FIELD_NUMBER: builtins.int
    VERSION_FIELD_NUMBER: builtins.int
    SOURCE_CONTEXT_FIELD_NUMBER: builtins.int
    MIXINS_FIELD_NUMBER: builtins.int
    SYNTAX_FIELD_NUMBER: builtins.int
    name: typing.Text
    """The fully qualified name of this interface, including package name
    followed by the interface's simple name.
    """

    @property
    def methods(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Method]:
        """The methods of this interface, in unspecified order."""
        pass
    @property
    def options(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[google.protobuf.type_pb2.Option]:
        """Any metadata attached to the interface."""
        pass
    version: typing.Text
    """A version string for this interface. If specified, must have the form
    `major-version.minor-version`, as in `1.10`. If the minor version is
    omitted, it defaults to zero. If the entire version field is empty, the
    major version is derived from the package name, as outlined below. If the
    field is not empty, the version in the package name will be verified to be
    consistent with what is provided here.

    The versioning schema uses [semantic
    versioning](http://semver.org) where the major version number
    indicates a breaking change and the minor version an additive,
    non-breaking change. Both version numbers are signals to users
    what to expect from different versions, and should be carefully
    chosen based on the product plan.

    The major version is also reflected in the package name of the
    interface, which must end in `v<major-version>`, as in
    `google.feature.v1`. For major versions 0 and 1, the suffix can
    be omitted. Zero major versions must only be used for
    experimental, non-GA interfaces.
    """

    @property
    def source_context(self) -> google.protobuf.source_context_pb2.SourceContext:
        """Source context for the protocol buffer service represented by this
        message.
        """
        pass
    @property
    def mixins(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Mixin]:
        """Included interfaces. See [Mixin][]."""
        pass
    syntax: google.protobuf.type_pb2.Syntax.ValueType
    """The source syntax of the service."""

    def __init__(self,
        *,
        name: typing.Optional[typing.Text] = ...,
        methods: typing.Optional[typing.Iterable[global___Method]] = ...,
        options: typing.Optional[typing.Iterable[google.protobuf.type_pb2.Option]] = ...,
        version: typing.Optional[typing.Text] = ...,
        source_context: typing.Optional[google.protobuf.source_context_pb2.SourceContext] = ...,
        mixins: typing.Optional[typing.Iterable[global___Mixin]] = ...,
        syntax: typing.Optional[google.protobuf.type_pb2.Syntax.ValueType] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["source_context",b"source_context"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["methods",b"methods","mixins",b"mixins","name",b"name","options",b"options","source_context",b"source_context","syntax",b"syntax","version",b"version"]) -> None: ...
global___Api = Api

class Method(google.protobuf.message.Message):
    """Method represents a method of an API interface."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    NAME_FIELD_NUMBER: builtins.int
    REQUEST_TYPE_URL_FIELD_NUMBER: builtins.int
    REQUEST_STREAMING_FIELD_NUMBER: builtins.int
    RESPONSE_TYPE_URL_FIELD_NUMBER: builtins.int
    RESPONSE_STREAMING_FIELD_NUMBER: builtins.int
    OPTIONS_FIELD_NUMBER: builtins.int
    SYNTAX_FIELD_NUMBER: builtins.int
    name: typing.Text
    """The simple name of this method."""

    request_type_url: typing.Text
    """A URL of the input message type."""

    request_streaming: builtins.bool
    """If true, the request is streamed."""

    response_type_url: typing.Text
    """The URL of the output message type."""

    response_streaming: builtins.bool
    """If true, the response is streamed."""

    @property
    def options(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[google.protobuf.type_pb2.Option]:
        """Any metadata attached to the method."""
        pass
    syntax: google.protobuf.type_pb2.Syntax.ValueType
    """The source syntax of this method."""

    def __init__(self,
        *,
        name: typing.Optional[typing.Text] = ...,
        request_type_url: typing.Optional[typing.Text] = ...,
        request_streaming: typing.Optional[builtins.bool] = ...,
        response_type_url: typing.Optional[typing.Text] = ...,
        response_streaming: typing.Optional[builtins.bool] = ...,
        options: typing.Optional[typing.Iterable[google.protobuf.type_pb2.Option]] = ...,
        syntax: typing.Optional[google.protobuf.type_pb2.Syntax.ValueType] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["name",b"name","options",b"options","request_streaming",b"request_streaming","request_type_url",b"request_type_url","response_streaming",b"response_streaming","response_type_url",b"response_type_url","syntax",b"syntax"]) -> None: ...
global___Method = Method

class Mixin(google.protobuf.message.Message):
    """Declares an API Interface to be included in this interface. The including
    interface must redeclare all the methods from the included interface, but
    documentation and options are inherited as follows:

    - If after comment and whitespace stripping, the documentation
      string of the redeclared method is empty, it will be inherited
      from the original method.

    - Each annotation belonging to the service config (http,
      visibility) which is not set in the redeclared method will be
      inherited.

    - If an http annotation is inherited, the path pattern will be
      modified as follows. Any version prefix will be replaced by the
      version of the including interface plus the [root][] path if
      specified.

    Example of a simple mixin:

        package google.acl.v1;
        service AccessControl {
          // Get the underlying ACL object.
          rpc GetAcl(GetAclRequest) returns (Acl) {
            option (google.api.http).get = "/v1/{resource=**}:getAcl";
          }
        }

        package google.storage.v2;
        service Storage {
          rpc GetAcl(GetAclRequest) returns (Acl);

          // Get a data record.
          rpc GetData(GetDataRequest) returns (Data) {
            option (google.api.http).get = "/v2/{resource=**}";
          }
        }

    Example of a mixin configuration:

        apis:
        - name: google.storage.v2.Storage
          mixins:
          - name: google.acl.v1.AccessControl

    The mixin construct implies that all methods in `AccessControl` are
    also declared with same name and request/response types in
    `Storage`. A documentation generator or annotation processor will
    see the effective `Storage.GetAcl` method after inheriting
    documentation and annotations as follows:

        service Storage {
          // Get the underlying ACL object.
          rpc GetAcl(GetAclRequest) returns (Acl) {
            option (google.api.http).get = "/v2/{resource=**}:getAcl";
          }
          ...
        }

    Note how the version in the path pattern changed from `v1` to `v2`.

    If the `root` field in the mixin is specified, it should be a
    relative path under which inherited HTTP paths are placed. Example:

        apis:
        - name: google.storage.v2.Storage
          mixins:
          - name: google.acl.v1.AccessControl
            root: acls

    This implies the following inherited HTTP annotation:

        service Storage {
          // Get the underlying ACL object.
          rpc GetAcl(GetAclRequest) returns (Acl) {
            option (google.api.http).get = "/v2/acls/{resource=**}:getAcl";
          }
          ...
        }
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    NAME_FIELD_NUMBER: builtins.int
    ROOT_FIELD_NUMBER: builtins.int
    name: typing.Text
    """The fully qualified name of the interface which is included."""

    root: typing.Text
    """If non-empty specifies a path under which inherited HTTP paths
    are rooted.
    """

    def __init__(self,
        *,
        name: typing.Optional[typing.Text] = ...,
        root: typing.Optional[typing.Text] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["name",b"name","root",b"root"]) -> None: ...
global___Mixin = Mixin
