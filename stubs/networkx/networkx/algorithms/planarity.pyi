from collections.abc import Iterable
from typing import Generic, TypeVar

import networkx as nx
from _typeshed import Incomplete

def check_planarity(G: Incomplete, counterexample: bool = ...) -> Incomplete: ...

_N = TypeVar("_N")

class Interval:
    low: Incomplete = ...
    high: Incomplete = ...
    def __init__(
        self, low: Incomplete | None = ..., high: Incomplete | None = ...
    ) -> None: ...
    def empty(self) -> Incomplete: ...
    def copy(self) -> Incomplete: ...
    def conflicting(self, b: Incomplete, planarity_state: Incomplete) -> Incomplete: ...

class ConflictPair:
    left: Incomplete = ...
    right: Incomplete = ...
    def __init__(self, left: Incomplete = ..., right: Incomplete = ...) -> None: ...
    def swap(self) -> None: ...
    def lowest(self, planarity_state: Incomplete) -> Incomplete: ...

class LRPlanarity:
    G: Incomplete = ...
    roots: Incomplete = ...
    height: Incomplete = ...
    lowpt: Incomplete = ...
    lowpt2: Incomplete = ...
    nesting_depth: Incomplete = ...
    parent_edge: Incomplete = ...
    DG: Incomplete = ...
    adjs: Incomplete = ...
    ordered_adjs: Incomplete = ...
    ref: Incomplete = ...
    side: Incomplete = ...
    S: Incomplete = ...
    stack_bottom: Incomplete = ...
    lowpt_edge: Incomplete = ...
    left_ref: Incomplete = ...
    right_ref: Incomplete = ...
    embedding: Incomplete = ...
    def __init__(self, G: Incomplete) -> None: ...
    def lr_planarity(self) -> Incomplete: ...
    def lr_planarity_recursive(self) -> Incomplete: ...
    def dfs_orientation(self, v: Incomplete) -> Incomplete: ...
    def dfs_orientation_recursive(self, v: Incomplete) -> None: ...
    def dfs_testing(self, v: Incomplete) -> Incomplete: ...
    def dfs_testing_recursive(self, v: Incomplete) -> Incomplete: ...
    def add_constraints(self, ei: Incomplete, e: Incomplete) -> Incomplete: ...
    def remove_back_edges(self, e: Incomplete) -> None: ...
    def dfs_embedding(self, v: Incomplete) -> Incomplete: ...
    def dfs_embedding_recursive(self, v: Incomplete) -> None: ...
    def sign(self, e: Incomplete) -> Incomplete: ...
    def sign_recursive(self, e: Incomplete) -> Incomplete: ...

class PlanarEmbedding(Generic[_N], nx.DiGraph[_N]):
    def get_data(self) -> dict[_N, list[_N]]: ...
    def set_data(self, data: dict[_N, list[_N]]) -> None: ...
    def neighbors_cw_order(self, v: _N) -> Iterable[_N]: ...
    def check_structure(self) -> None: ...
    def add_half_edge_ccw(
        self, start_node: _N, end_node: _N, reference_neighbor: _N
    ) -> None: ...
    def add_half_edge_cw(
        self, start_node: _N, end_node: _N, reference_neighbor: _N
    ) -> None: ...
    def connect_components(self, v: _N, w: _N) -> None: ...
    def add_half_edge_first(self, start_node: _N, end_node: _N) -> None: ...
    def next_face_half_edge(self, v: _N, w: _N) -> tuple[_N, _N]: ...
    def traverse_face(
        self, v: _N, w: _N, mark_half_edges: set[tuple[_N, _N]] | None = ...
    ) -> list[_N]: ...
    def is_directed(self) -> bool: ...
