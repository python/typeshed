from collections.abc import Iterable
from typing import Any, TypeVar, overload

from _typeshed import Incomplete
from networkx.classes.graph import Graph
from typing_extensions import Literal

_T = TypeVar("_T")
_U = TypeVar("_U")

def nodes(G: Incomplete) -> Incomplete: ...
def edges(G: Incomplete, nbunch: Incomplete | None = ...) -> Incomplete: ...
def degree(
    G: Incomplete, nbunch: Incomplete | None = ..., weight: Incomplete | None = ...
) -> Incomplete: ...
def neighbors(G: Incomplete, n: Incomplete) -> Incomplete: ...
def number_of_nodes(G: Incomplete) -> Incomplete: ...
def number_of_edges(G: Incomplete) -> Incomplete: ...
def density(G: Incomplete) -> Incomplete: ...
def degree_histogram(G: Incomplete) -> Incomplete: ...
def is_directed(G: Incomplete) -> Incomplete: ...
def freeze(G: Incomplete) -> Incomplete: ...
def is_frozen(G: Incomplete) -> Incomplete: ...
def add_star(
    G_to_add_to: Incomplete, nodes_for_star: Incomplete, **attr: Incomplete
) -> None: ...
def add_path(
    G_to_add_to: Incomplete, nodes_for_path: Incomplete, **attr: Incomplete
) -> None: ...
def add_cycle(
    G_to_add_to: Incomplete, nodes_for_cycle: Incomplete, **attr: Incomplete
) -> None: ...
def subgraph(G: Incomplete, nbunch: Incomplete) -> Incomplete: ...
def induced_subgraph(G: Graph[_T], nbunch: _T | Iterable[_T] | None) -> Graph[_T]: ...
def edge_subgraph(G: Incomplete, edges: Incomplete) -> Incomplete: ...
def restricted_view(
    G: Incomplete, nodes: Incomplete, edges: Incomplete
) -> Incomplete: ...
def reverse_view(digraph: Incomplete) -> Incomplete: ...
def to_directed(graph: Incomplete) -> Incomplete: ...
def to_undirected(graph: Incomplete) -> Incomplete: ...
def create_empty_copy(G: Incomplete, with_data: bool = ...) -> Incomplete: ...
def info(G: Incomplete, n: Incomplete | None = ...) -> Incomplete: ...
@overload
def set_node_attributes(
    G: Graph[_T], values: dict[_T, Incomplete], name: str = ...
) -> None: ...

# Can "Any scalar value" be enforced?
@overload
def set_node_attributes(G: Graph[Any], values: Incomplete, name: str = ...) -> None: ...
@overload
def set_node_attributes(
    G: Graph[_T], values: dict[_T, dict[Incomplete, Incomplete]], name: None = ...
) -> None: ...
def get_node_attributes(G: Graph[_T], name: str) -> dict[_T, Incomplete]: ...
@overload
def set_edge_attributes(
    G: Graph[_T], values: dict[tuple[_T, _T], Incomplete], name: str = ...
) -> None: ...
@overload
def set_edge_attributes(
    G: Graph[Any], values: Incomplete, name: None = ...
) -> None: ...
def get_edge_attributes(G: Graph[_T], name: str) -> dict[tuple[_T, _T], Incomplete]: ...
def all_neighbors(graph: Graph[_T], node: _T) -> Iterable[_T]: ...
def non_neighbors(graph: Graph[_T], node: _T) -> Iterable[_T]: ...
def non_edges(graph: Graph[_T]) -> Iterable[tuple[_T, _T]]: ...
def common_neighbors(G: Graph[_T], u: _T, v: _T) -> Iterable[_T]: ...
def is_weighted(
    G: Graph[_T], edge: tuple[_T, _T] | None = ..., weight: str | None = ...
) -> bool: ...
def is_negatively_weighted(
    G: Graph[_T], edge: tuple[_T, _T] | None = ..., weight: str | None = ...
) -> Incomplete: ...
def is_empty(G: Graph[Any]) -> bool: ...
def nodes_with_selfloops(G: Graph[_T]) -> Iterable[_T]: ...
@overload
def selfloop_edges(
    G: Graph[_T],
    data: Literal[False] = ...,
    keys: Literal[False] = ...,
    default: Incomplete = ...,
) -> Iterable[tuple[_T, _T]]: ...
@overload
def selfloop_edges(
    G: Graph[_T],
    data: Literal[True] = ...,
    keys: Literal[False] = ...,
    default: Incomplete = ...,
) -> Iterable[tuple[_T, _T, dict[str, Incomplete]]]: ...
@overload
def selfloop_edges(
    G: Graph[_T], data: str = ..., keys: Literal[False] = ..., default: _U | None = None
) -> Iterable[tuple[_T, _T, _U]]: ...
@overload
def selfloop_edges(
    G: Graph[_T],
    data: Literal[False] = ...,
    keys: Literal[True] = ...,
    default: Incomplete = ...,
) -> Iterable[tuple[_T, _T, int]]: ...
@overload
def selfloop_edges(
    G: Graph[_T],
    data: Literal[True] = ...,
    keys: Literal[True] = ...,
    default: Incomplete = ...,
) -> Iterable[tuple[_T, _T, int, dict[str, Incomplete]]]: ...
@overload
def selfloop_edges(
    G: Graph[_T], data: str = ..., keys: Literal[True] = ..., default: _U | None = None
) -> Iterable[tuple[_T, _T, int, _U]]: ...
def number_of_selfloops(G: Graph[Any]) -> int: ...
