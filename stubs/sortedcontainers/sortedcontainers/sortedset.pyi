from _typeshed import Self, SupportsDunderGT, SupportsDunderLT, SupportsRichComparison
from collections.abc import Callable, Hashable, Iterable, Iterator, MutableSet, Sequence
from typing import Any, Generic, Protocol, TypeVar, overload
from typing_extensions import TypeAlias

from .sortedlist import SortedList as SortedList, recursive_repr as recursive_repr

class _SupportsRichComparisonAndHashable(SupportsDunderLT[Any], SupportsDunderGT[Any], Hashable, Protocol): ...

_SupportsRichComparisonAndHashableT = TypeVar("_SupportsRichComparisonAndHashableT", bound=_SupportsRichComparisonAndHashable)
_SupportsRichComparisonAndHashableS = TypeVar("_SupportsRichComparisonAndHashableS", bound=_SupportsRichComparisonAndHashable)
_HashableT = TypeVar("_HashableT")
_HashableS = TypeVar("_HashableS")
_KeyT = TypeVar("_KeyT", bound=SupportsRichComparison)
_KeyFunction: TypeAlias = Callable[[_HashableT], _KeyT]
_SortedSetT = TypeVar("_SortedSetT", bound=SortedSet)

class SortedSet(
    MutableSet[_SupportsRichComparisonAndHashableT],
    Sequence[_SupportsRichComparisonAndHashableT],
    Generic[_SupportsRichComparisonAndHashableT],
):
    def issubset(self, __s: Iterable[_SupportsRichComparisonAndHashableT]) -> bool: ...
    def issuperset(self, __s: Iterable[_SupportsRichComparisonAndHashableT]) -> bool: ...
    def bisect_left(self, value: _SupportsRichComparisonAndHashableT) -> int: ...
    def bisect(self, value: _SupportsRichComparisonAndHashableT) -> int: ...
    def bisect_right(self, value: _SupportsRichComparisonAndHashableT) -> int: ...
    def index(self, value: _SupportsRichComparisonAndHashableT, start: int | None = ..., stop: int | None = ...) -> int: ...
    def irange(
        self,
        minimum: _SupportsRichComparisonAndHashableT | None = ...,
        maximum: _SupportsRichComparisonAndHashableT | None = ...,
        inclusive: tuple[bool, bool] = ...,
        reverse: bool = ...,
    ) -> Iterator[_SupportsRichComparisonAndHashableT]: ...
    def islice(
        self, start: int | None = ..., stop: int | None = ..., reverse: bool = ...
    ) -> Iterator[_SupportsRichComparisonAndHashableT]: ...
    @overload
    def __new__(
        cls: type[Self], iterable: Iterable[_SupportsRichComparisonAndHashableT] | None = ..., key: None = ...
    ) -> Self: ...
    @overload
    def __new__(cls, iterable: Iterable[_HashableT] | None = ..., *, key: _KeyFunction) -> _SortedKeySet[_HashableT, _KeyT]: ...
    @overload
    def __init__(self, iterable: Iterable[_SupportsRichComparisonAndHashableT] | None = ..., key: None = ...) -> None: ...
    @overload
    def __init__(self, iterable: Iterable[_HashableT] | None = ..., *, key: _KeyFunction) -> None: ...
    @property
    def key(self) -> None: ...
    def __contains__(self, item: Hashable) -> bool: ...
    @overload
    def __getitem__(self, index: int) -> _SupportsRichComparisonAndHashableT: ...
    @overload
    def __getitem__(self, index: slice) -> list[_SupportsRichComparisonAndHashableT]: ...
    def __delitem__(self, index: int | slice) -> None: ...
    def __len__(self) -> int: ...
    def add(self, value: _SupportsRichComparisonAndHashableT) -> None: ...
    def copy(self: _SortedSetT) -> _SortedSetT: ...  # noqa: Y019
    def __copy__(self: _SortedSetT) -> _SortedSetT: ...  # noqa: Y019
    def discard(self, value: Hashable) -> None: ...
    def pop(self, index: int = ...) -> _SupportsRichComparisonAndHashableT: ...
    def difference(self: _SortedSetT, *iterables: Iterable[Hashable]) -> _SortedSetT: ...  # noqa: Y019
    def __sub__(self: _SortedSetT, *iterables: Iterable[Hashable]) -> _SortedSetT: ...  # noqa: Y019
    def difference_update(self: Self, *iterables: Iterable[Hashable]) -> Self: ...
    def __isub__(self: Self, *iterables: Iterable[Hashable]) -> Self: ...
    def intersection(self: _SortedSetT, *iterables: Iterable[Hashable]) -> _SortedSetT: ...  # noqa: Y019
    def __and__(self: _SortedSetT, *iterables: Iterable[Hashable]) -> _SortedSetT: ...  # noqa: Y019
    def __rand__(self: _SortedSetT, *iterables: Iterable[Hashable]) -> _SortedSetT: ...  # noqa: Y019
    def intersection_update(self: Self, *iterables: Iterable[Hashable]) -> Self: ...
    def __iand__(self: Self, *iterables: Iterable[Hashable]) -> Self: ...
    def symmetric_difference(
        self, other: Iterable[_SupportsRichComparisonAndHashableS]
    ) -> SortedSet[_SupportsRichComparisonAndHashableT | _SupportsRichComparisonAndHashableS]: ...
    def __xor__(  # type: ignore[override]
        self, other: Iterable[_SupportsRichComparisonAndHashableS]
    ) -> SortedSet[_SupportsRichComparisonAndHashableT | _SupportsRichComparisonAndHashableS]: ...
    def __rxor__(
        self, other: Iterable[_SupportsRichComparisonAndHashableS]
    ) -> SortedSet[_SupportsRichComparisonAndHashableT | _SupportsRichComparisonAndHashableS]: ...
    def symmetric_difference_update(self: Self, other: Iterable[_SupportsRichComparisonAndHashableT]) -> Self: ...
    def __ixor__(self: Self, other: Iterable[_SupportsRichComparisonAndHashableT]) -> Self: ...  # type: ignore[override,misc]
    def union(
        self, *iterables: Iterable[_SupportsRichComparisonAndHashableS]
    ) -> SortedSet[_SupportsRichComparisonAndHashableT | _SupportsRichComparisonAndHashableS]: ...
    def __or__(  # type: ignore[override]
        self, *iterables: Iterable[_SupportsRichComparisonAndHashableS]
    ) -> SortedSet[_SupportsRichComparisonAndHashableT | _SupportsRichComparisonAndHashableS]: ...
    def __ror__(
        self, *iterables: Iterable[_SupportsRichComparisonAndHashableS]
    ) -> SortedSet[_SupportsRichComparisonAndHashableT | _SupportsRichComparisonAndHashableS]: ...
    def update(self: Self, *iterables: Iterable[_SupportsRichComparisonAndHashableT]) -> Self: ...
    def __ior__(self: Self, *iterables: Iterable[_SupportsRichComparisonAndHashableT]) -> Self: ...  # type: ignore[override,misc]

class _SortedKeySet(SortedSet[_HashableT], Generic[_HashableT, _KeyT]):  # type: ignore[type-var]
    def bisect_key_left(self, key: object) -> int: ...
    def bisect_key_right(self, key: object) -> int: ...
    def bisect_key(self, key: object) -> int: ...
    def irange_key(
        self, min_key: object = ..., max_key: object = ..., inclusive: tuple[bool, bool] = ..., reverse: bool = ...
    ) -> Iterator[_HashableT]: ...
    @property
    def key(self) -> _KeyFunction: ...  # type: ignore[override]
    def symmetric_difference(self, other: Iterable[_HashableS]) -> _SortedKeySet[_HashableT | _HashableS, _KeyT]: ...
    def __xor__(self, other: Iterable[_HashableS]) -> _SortedKeySet[_HashableT | _HashableS, _KeyT]: ...
    def __rxor__(self, other: Iterable[_HashableS]) -> _SortedKeySet[_HashableT | _HashableS, _KeyT]: ...
    def union(self, *iterables: Iterable[_HashableS]) -> _SortedKeySet[_HashableT | _HashableS, _KeyT]: ...
    def __or__(self, *iterables: Iterable[_HashableS]) -> _SortedKeySet[_HashableT | _HashableS, _KeyT]: ...
    def __ror__(self, *iterables: Iterable[_HashableS]) -> _SortedKeySet[_HashableT | _HashableS, _KeyT]: ...
