from _typeshed import Incomplete, Self
from asyncio import AbstractEventLoop, Future
from collections.abc import Awaitable, Callable, Coroutine, Generator, Iterable, Mapping, Sequence
from enum import Enum
from typing import Any, Generic, NoReturn, Protocol as _TypingProtocol, TypeVar
from typing_extensions import Literal, TypeAlias

_T = TypeVar("_T")

# region twisted.python.failure
class Failure(BaseException):
    pickled: int
    stack: Incomplete
    count: Incomplete
    type: Incomplete
    captureVars: Incomplete
    value: Incomplete
    tb: Incomplete
    parents: Incomplete
    def __init__(
        self,
        exc_value: Incomplete | None = ...,
        exc_type: Incomplete | None = ...,
        exc_tb: Incomplete | None = ...,
        captureVars: bool = ...,
    ) -> None: ...
    def trap(self, *errorTypes): ...
    def check(self, *errorTypes): ...
    def raiseException(self) -> NoReturn: ...
    def throwExceptionIntoGenerator(self, g): ...
    __dict__: Incomplete
    def cleanFailure(self) -> None: ...
    def getTracebackObject(self): ...
    def getErrorMessage(self) -> str: ...
    def getBriefTraceback(self) -> str: ...
    def getTraceback(self, elideFrameworkCode: int = ..., detail: str = ...) -> str: ...
    def printTraceback(self, file: Incomplete | None = ..., elideFrameworkCode: bool = ..., detail: str = ...) -> None: ...
    def printBriefTraceback(self, file: Incomplete | None = ..., elideFrameworkCode: int = ...) -> None: ...
    def printDetailedTraceback(self, file: Incomplete | None = ..., elideFrameworkCode: int = ...) -> None: ...

# endregion

# region twisted.internet.interfaces

class Interface:  # incomplete
    def __init__(self, obj, alternate=...) -> None: ...

class _InterfaceProtocol(_TypingProtocol):  # incomplete
    def __init__(self, obj, alternate=...) -> None: ...

class IAddress(Interface): ...

class IDelayedCall(Interface):
    def getTime(self) -> float: ...
    def cancel(self) -> None: ...
    def delay(self, secondsLater: float) -> None: ...
    def reset(sself, econdsFromNow: float) -> None: ...
    def active(self) -> bool: ...

class IReactorTime(_InterfaceProtocol):
    def seconds(self) -> float: ...
    def callLater(self, delay: float, callable: Callable[..., Any], *args: object, **kwargs: object) -> IDelayedCall: ...
    def getDelayedCalls(self) -> Sequence[IDelayedCall]: ...

class ITransport(_InterfaceProtocol):
    def write(self, data: bytes) -> None: ...
    def writeSequence(self, data: Iterable[bytes]) -> None: ...
    def loseConnection(self) -> None: ...
    def getPeer(self) -> IAddress: ...
    def getHost(self) -> IAddress: ...

# endregion

# region twisted.internet.base
class _Sentinel(Enum):
    _NO_RESULT = object()
    _CONTINUE = object()

DeferredCallback: TypeAlias = Callable[..., object]
DeferredErrback: TypeAlias = Callable[..., object]
_CallbackOrderedArguments: TypeAlias = tuple[object, ...]
_CallbackKeywordArguments: TypeAlias = Mapping[str, object]
_CallbackChain: TypeAlias = tuple[
    tuple[DeferredCallback | Literal[_Sentinel._CONTINUE], _CallbackOrderedArguments, _CallbackKeywordArguments],
    tuple[
        DeferredErrback | DeferredCallback, Literal[_Sentinel._CONTINUE], _CallbackOrderedArguments, _CallbackKeywordArguments,
    ],
]
_DeferredResultT = TypeVar("_DeferredResultT", contravariant=True)
_NextDeferredResultT = TypeVar("_NextDeferredResultT", covariant=True)

class DelayedCall(_TypingProtocol):
    debug: bool
    creator: Sequence[str] | None
    resetter: Incomplete
    canceller: Incomplete
    seconds: Incomplete
    cancelled: int
    delayed_time: float
    def __init__(
        self,
        time: float,
        func: Callable[..., Any],
        args: Sequence[object],
        kw: dict[str, object],
        cancel: Callable[[DelayedCall], None],
        reset: Callable[[DelayedCall], None],
        seconds: Callable[[], float] = ...,
    ) -> None: ...
    def getTime(self) -> float: ...
    def cancel(self) -> None: ...
    time: Incomplete
    def reset(self, secondsFromNow: float) -> None: ...
    def delay(self, secondsLater: float) -> None: ...
    def activate_delay(self) -> None: ...
    def active(self) -> bool: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...

# Variance: This is how it's typed in source
class Deferred(Awaitable[_DeferredResultT]):  # type: ignore[type-var]  # pyright: ignore[reportGeneralTypeIssues]
    called: bool
    paused: int
    debug: bool
    callbacks: list[_CallbackChain]
    def __init__(self, canceller: Callable[[Deferred[Any]], None] | None = ...) -> None: ...
    def addCallbacks(
        self,
        callback: Callable[..., _NextDeferredResultT | Deferred[_NextDeferredResultT]],
        errback: Callable[..., Failure | _NextDeferredResultT | Deferred[_NextDeferredResultT]] = ...,
        callbackArgs: _CallbackOrderedArguments = ...,
        callbackKeywords: _CallbackKeywordArguments = ...,
        errbackArgs: _CallbackOrderedArguments = ...,
        errbackKeywords: _CallbackKeywordArguments = ...,
    ) -> Deferred[_NextDeferredResultT]: ...
    def addCallback(
        self, callback: Callable[..., _NextDeferredResultT | Deferred[_NextDeferredResultT]], *args: object, **kwargs: object
    ) -> Deferred[_NextDeferredResultT]: ...
    def addErrback(
        self,
        errback: Callable[..., Failure | _NextDeferredResultT | Deferred[_NextDeferredResultT]],
        *args: object,
        **kwargs: object,
    ) -> Deferred[_DeferredResultT | _NextDeferredResultT]: ...
    def addBoth(
        self, callback: Callable[..., _NextDeferredResultT | Deferred[_NextDeferredResultT]], *args: object, **kwargs: object
    ) -> Deferred[_NextDeferredResultT]: ...
    def addTimeout(
        self, timeout: float, clock: IReactorTime, onTimeoutCancel: Callable[[object, float], object] | None = ...
    ) -> Deferred[_DeferredResultT]: ...
    def chainDeferred(self, d: Deferred[_DeferredResultT]) -> Deferred[None]: ...
    def callback(self, result: _DeferredResultT | Failure) -> None: ...
    def errback(self, fail: Failure | BaseException | None = ...) -> None: ...
    def pause(self) -> None: ...
    def unpause(self) -> None: ...
    def cancel(self) -> None: ...
    def __iter__(self) -> Deferred[_DeferredResultT]: ...
    def send(self, value: object = ...) -> Deferred[_DeferredResultT]: ...
    def __await__(self) -> Generator[Any, None, _DeferredResultT]: ...
    __next__: Incomplete
    def asFuture(self, loop: AbstractEventLoop) -> Future[_DeferredResultT]: ...
    @classmethod
    def fromFuture(cls, future: Future[Incomplete]) -> Deferred[Any]: ...
    @classmethod
    def fromCoroutine(cls, coro: Coroutine[Deferred[_T], Any, _T] | Generator[Deferred[_T], Any, _T]) -> Deferred[_T]: ...

class DeferredQueue(Generic[_T]):
    waiting: list[Deferred[_T]]
    pending: list[_T]
    size: int | None
    backlog: int | None
    def __init__(self, size: int | None = ..., backlog: int | None = ...) -> None: ...
    def put(self, obj: _T) -> None: ...
    def get(self) -> Deferred[_T]: ...

# endregion

# region twisted.internet.protocol

class Factory:
    protocol: Callable[[], Protocol] | None
    numPorts: int
    noisy: bool
    @classmethod
    def forProtocol(cls: type[Self], protocol: Protocol, *args, **kwargs) -> Self: ...
    def logPrefix(self): ...
    def doStart(self) -> None: ...
    def doStop(self) -> None: ...
    def startFactory(self) -> None: ...
    def stopFactory(self) -> None: ...
    def buildProtocol(self, addr: IAddress) -> Protocol | None: ...

class BaseProtocol:
    connected: int
    transport: ITransport | None
    def makeConnection(self, transport) -> None: ...
    def connectionMade(self) -> None: ...

class Protocol(BaseProtocol):
    factory: Factory | None
    def logPrefix(self): ...
    def dataReceived(self, data: bytes): ...
    def connectionLost(self, reason: BaseException = ...): ...

# endregion
