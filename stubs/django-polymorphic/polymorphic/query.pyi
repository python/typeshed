from collections.abc import Collection, Iterable, Iterator, Sequence
from typing import Any, overload
from typing_extensions import Self, TypeVar

from django.db import models
from django.db.models.expressions import Combinable
from django.db.models.query import ModelIterable, QuerySet

from .query_translate import (
    translate_polymorphic_field_path as translate_polymorphic_field_path,
    translate_polymorphic_filter_definitions_in_args as translate_polymorphic_filter_definitions_in_args,
    translate_polymorphic_filter_definitions_in_kwargs as translate_polymorphic_filter_definitions_in_kwargs,
    translate_polymorphic_Q_object as translate_polymorphic_Q_object,
)

_T = TypeVar("_T", bound=models.Model, default=models.Model)

Polymorphic_QuerySet_objects_per_request: int = 2000

class _Inconsistent: ...

class PolymorphicModelIterable(ModelIterable[_T]):
    def __iter__(self) -> Iterator[_T]: ...
    def _polymorphic_iterator(self, base_iter: Iterator[_T]) -> Iterator[_T]: ...

def transmogrify(cls: type[_T], obj: models.Model) -> _T: ...

class PolymorphicQuerySet(QuerySet[_T]):
    polymorphic_disabled: bool
    polymorphic_deferred_loading: tuple[set[str], bool]
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    def _clone(self, *args: Any, **kwargs: Any) -> Self: ...
    @classmethod
    def as_manager(cls) -> models.Manager[_T]: ...
    def bulk_create(
        self,
        objs: Iterable[_T],
        batch_size: int | None = None,
        ignore_conflicts: bool = False,
        update_conflicts: bool = False,
        update_fields: Collection[str] | None = None,
        unique_fields: Collection[str] | None = None,
    ) -> list[_T]: ...
    def non_polymorphic(self) -> Self: ...
    def instance_of(self, *args: type[models.Model]) -> Self: ...
    def not_instance_of(self, *args: type[models.Model]) -> Self: ...
    def _filter_or_exclude(self, negate: bool, args: Any, kwargs: Any) -> Self: ...
    def order_by(self, *field_names: str | Combinable) -> Self: ...
    @overload
    def defer(self, field: None, /) -> Self: ...
    @overload
    def defer(self, *fields: str) -> Self: ...
    def only(self, *fields: str) -> Self: ...
    def _polymorphic_add_deferred_loading(self, field_names: Iterable[str]) -> None: ...
    def _polymorphic_add_immediate_loading(self, field_names: Iterable[str]) -> None: ...
    def _process_aggregate_args(self, args: Sequence[Any], kwargs: dict[str, Any]) -> None: ...
    def annotate(self, *args: Any, **kwargs: Any) -> Self: ...
    def aggregate(self, *args: Any, **kwargs: Any) -> dict[str, Any]: ...
    def _values(self, *args: Any, **kwargs: Any) -> Self: ...
    def _get_real_instances(self, base_result_objects: Iterable[_T]) -> list[_T]: ...
    def get_real_instances(self, base_result_objects: Iterable[_T] | None = None) -> list[_T]: ...
    def delete(self) -> tuple[int, dict[str, int]]: ...

    class _p_list_class(list[Any]): ...
