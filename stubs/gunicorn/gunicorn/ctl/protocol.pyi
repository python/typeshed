from _typeshed import Incomplete
from asyncio import StreamReader, StreamWriter
from socket import socket
from typing import ClassVar

class ProtocolError(Exception): ...

class ControlProtocol:
    MAX_MESSAGE_SIZE: ClassVar[int]
    @staticmethod
    def encode_message(data: dict[Incomplete, Incomplete]) -> bytes: ...
    @staticmethod
    def decode_message(data: bytes) -> dict[Incomplete, Incomplete]: ...
    @staticmethod
    def read_message(sock: socket) -> dict[Incomplete, Incomplete]: ...
    @staticmethod
    def write_message(sock: socket, data: dict[Incomplete, Incomplete]) -> None: ...
    @staticmethod
    async def read_message_async(reader: StreamReader) -> dict[Incomplete, Incomplete]: ...
    @staticmethod
    async def write_message_async(writer: StreamWriter, data: dict[Incomplete, Incomplete]) -> None: ...

# TODO: Use TypedDict for next return types
def make_request(request_id: int, command: str, args: list[str] | None = None) -> dict[str, Incomplete]: ...
def make_response(request_id: int, data: dict[Incomplete, Incomplete] | None = None) -> dict[str, Incomplete]: ...
def make_error_response(request_id: int, error: str) -> dict[str, Incomplete]: ...
