import abc
from _typeshed import Incomplete
from typing import Any, Dict, Generator, List, Mapping, Optional, Type, TypeVar, Union

from redis.asyncio.client import ResponseCallbackT as ResponseCallbackT
from redis.asyncio.connection import Connection, DefaultParser, Encoder
from redis.client import AbstractRedis
from redis.cluster import AbstractRedisCluster
from redis.commands import AsyncRedisClusterCommands
from redis.typing import AnyKeyT as AnyKeyT, EncodableT as EncodableT, KeyT as KeyT

TargetNodesT = TypeVar("TargetNodesT", str, "ClusterNode", List["ClusterNode"], Dict[Any, "ClusterNode"])
CONNECTION_ALLOWED_KEYS: Incomplete

def cleanup_kwargs(**kwargs: Any) -> Dict[str, Any]: ...

class ClusterParser(DefaultParser):
    EXCEPTION_CLASSES: Incomplete

class RedisCluster(AbstractRedis, AbstractRedisCluster, AsyncRedisClusterCommands, metaclass=abc.ABCMeta):
    @classmethod
    def from_url(cls, url: str, **kwargs: Any) -> RedisCluster: ...
    connection_kwargs: Incomplete
    response_callbacks: Incomplete
    nodes_manager: Incomplete
    encoder: Incomplete
    cluster_error_retry_attempts: Incomplete
    read_from_replicas: Incomplete
    reinitialize_steps: Incomplete
    reinitialize_counter: int
    commands_parser: Incomplete
    node_flags: Incomplete
    command_flags: Incomplete
    result_callbacks: Incomplete
    def __init__(
        self,
        host: Optional[str] = ...,
        port: int = ...,
        startup_nodes: Optional[List["ClusterNode"]] = ...,
        require_full_coverage: bool = ...,
        read_from_replicas: bool = ...,
        cluster_error_retry_attempts: int = ...,
        reinitialize_steps: int = ...,
        url: Optional[str] = ...,
        **kwargs: Any,
    ) -> None: ...
    async def initialize(self) -> RedisCluster: ...
    async def close(self) -> None: ...
    async def __aenter__(self) -> RedisCluster: ...
    async def __aexit__(self, exc_type: None, exc_value: None, traceback: None) -> None: ...
    def __await__(self) -> Generator[Any, None, "RedisCluster"]: ...
    def __del__(self) -> None: ...
    async def on_connect(self, connection: Connection) -> None: ...
    def get_nodes(self) -> List["ClusterNode"]: ...
    def get_primaries(self) -> List["ClusterNode"]: ...
    def get_replicas(self) -> List["ClusterNode"]: ...
    def get_random_node(self) -> ClusterNode: ...
    def get_default_node(self) -> ClusterNode: ...
    def set_default_node(self, node: ClusterNode) -> None: ...
    def get_node(
        self, host: Optional[str] = ..., port: Optional[int] = ..., node_name: Optional[str] = ...
    ) -> Optional["ClusterNode"]: ...
    def get_node_from_key(self, key: str, replica: bool = ...) -> Optional["ClusterNode"]: ...
    def keyslot(self, key: EncodableT) -> int: ...
    def get_encoder(self) -> Encoder: ...
    def get_connection_kwargs(self) -> Dict[str, Optional[Any]]: ...
    def set_response_callback(self, command: str, callback: ResponseCallbackT) -> None: ...
    async def execute_command(self, *args: EncodableT, **kwargs: Any) -> Any: ...
    def pipeline(self, transaction: Optional[Any] = ..., shard_hint: Optional[Any] = ...) -> ClusterPipeline: ...

class ClusterNode:
    host: Incomplete
    port: Incomplete
    name: Incomplete
    server_type: Incomplete
    max_connections: Incomplete
    connection_class: Incomplete
    connection_kwargs: Incomplete
    response_callbacks: Incomplete
    def __init__(
        self,
        host: str,
        port: int,
        server_type: Optional[str] = ...,
        max_connections: int = ...,
        connection_class: Type[Connection] = ...,
        **connection_kwargs: Any,
    ) -> None: ...
    def __eq__(self, obj: Any) -> bool: ...
    def __del__(self) -> None: ...
    async def disconnect(self) -> None: ...
    def acquire_connection(self) -> Connection: ...
    async def parse_response(self, connection: Connection, command: str, **kwargs: Any) -> Any: ...
    async def execute_command(self, *args: Any, **kwargs: Any) -> Any: ...
    async def execute_pipeline(self, commands: List["PipelineCommand"]) -> bool: ...

class NodesManager:
    startup_nodes: Incomplete
    require_full_coverage: Incomplete
    connection_kwargs: Incomplete
    default_node: Incomplete
    nodes_cache: Incomplete
    slots_cache: Incomplete
    read_load_balancer: Incomplete
    def __init__(self, startup_nodes: List["ClusterNode"], require_full_coverage: bool = ..., **kwargs: Any) -> None: ...
    def get_node(
        self, host: Optional[str] = ..., port: Optional[int] = ..., node_name: Optional[str] = ...
    ) -> Optional["ClusterNode"]: ...
    def set_nodes(self, old: Dict[str, "ClusterNode"], new: Dict[str, "ClusterNode"], remove_old: bool = ...) -> None: ...
    def get_node_from_slot(self, slot: int, read_from_replicas: bool = ...) -> ClusterNode: ...
    def get_nodes_by_server_type(self, server_type: str) -> List["ClusterNode"]: ...
    async def initialize(self) -> None: ...
    async def close(self, attr: str = ...) -> None: ...

class ClusterPipeline(AbstractRedis, AbstractRedisCluster, AsyncRedisClusterCommands, metaclass=abc.ABCMeta):
    def __init__(self, client: RedisCluster) -> None: ...
    async def initialize(self) -> ClusterPipeline: ...
    async def __aenter__(self) -> ClusterPipeline: ...
    async def __aexit__(self, exc_type: None, exc_value: None, traceback: None) -> None: ...
    def __await__(self) -> Generator[Any, None, "ClusterPipeline"]: ...
    def __enter__(self) -> ClusterPipeline: ...
    def __exit__(self, exc_type: None, exc_value: None, traceback: None) -> None: ...
    def __bool__(self) -> bool: ...
    def __len__(self) -> int: ...
    def execute_command(self, *args: Union[KeyT, EncodableT], **kwargs: Any) -> ClusterPipeline: ...
    async def execute(self, raise_on_error: bool = ..., allow_redirections: bool = ...) -> List[Any]: ...
    def mset_nonatomic(self, mapping: Mapping[AnyKeyT, EncodableT]) -> ClusterPipeline: ...

command: Incomplete

class PipelineCommand:
    args: Incomplete
    kwargs: Incomplete
    position: Incomplete
    result: Incomplete
    def __init__(self, position: int, *args: Any, **kwargs: Any) -> None: ...
