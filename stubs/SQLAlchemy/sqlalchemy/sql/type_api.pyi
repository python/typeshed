from _typeshed import Incomplete, Unused
from collections.abc import Callable, Mapping
from typing import Any, Generic, TypeVar, overload
from typing_extensions import ParamSpec, Self

from .. import util
from ..engine.interfaces import Dialect
from ..sql.elements import BindParameter, ColumnElement
from ..sql.sqltypes import Boolean, Indexable, Integer, MatchType, NullType, String, TableValueType
from . import operators
from .base import SchemaEventTarget
from .visitors import Traversible, TraversibleType

_T = TypeVar("_T")
_P = ParamSpec("_P")

BOOLEANTYPE: Boolean
INTEGERTYPE: Integer
NULLTYPE: NullType
NUMERICTYPE: Incomplete
STRINGTYPE: String
MATCHTYPE: MatchType
INDEXABLE: type[Indexable]
TABLEVALUE: TableValueType

class TypeEngine(Traversible):
    class Comparator(operators.ColumnOperators[_T], Generic[_T]):
        default_comparator: Any
        def __clause_element__(self): ...
        expr: Any
        type: Incomplete
        def __init__(self, expr) -> None: ...
        def __reduce__(self): ...
        BOOLEANTYPE: Boolean
    hashable: bool
    comparator_factory: Callable[[Incomplete], Comparator[Incomplete]]
    sort_key_function: Any
    should_evaluate_none: bool
    def evaluates_none(self) -> Self: ...
    def copy(self, **kw: Unused) -> Self: ...
    def compare_against_backend(self, dialect: Dialect, conn_type): ...
    def copy_value(self, value: _T) -> _T: ...
    def literal_processor(self, dialect: Dialect) -> Callable[..., Incomplete] | None: ...
    def bind_processor(self, dialect: Dialect) -> Callable[..., Incomplete] | None: ...
    def result_processor(self, dialect: Dialect, coltype) -> Callable[..., Incomplete] | None: ...
    def column_expression(self, colexpr: str | ColumnElement[_T]) -> ColumnElement[_T] | None: ...
    def bind_expression(self, bindvalue: BindParameter[Incomplete]) -> Incomplete | None: ...
    def compare_values(self, x: object, y: object) -> bool: ...
    def get_dbapi_type(self, dbapi) -> Incomplete | None: ...
    @property
    def python_type(self) -> type: ...
    def with_variant(self, type_: type[TypeEngine] | TypeEngine, dialect_name: str) -> Variant: ...
    def as_generic(self, allow_nulltype: bool = False): ...
    def dialect_impl(self, dialect: Dialect): ...
    def adapt(self, cls: type[_T], **kw) -> _T: ...
    def coerce_compared_value(self, op: Unused, value) -> TypeEngine | Self: ...
    def compile(self, dialect: Dialect | None = None): ...

class VisitableCheckKWArg(util.EnsureKWArgType, TraversibleType): ...

class ExternalType:
    cache_ok: Any

class UserDefinedType(ExternalType, TypeEngine, metaclass=VisitableCheckKWArg):
    __visit_name__: str
    ensure_kwarg: str
    def coerce_compared_value(self, op: Unused, value: Unused) -> Self: ...

class Emulated:
    def adapt_to_emulated(self, impltype: type[Incomplete], **kw): ...
    def adapt(self, impltype: type[Incomplete], **kw): ...

class NativeForEmulated:
    @classmethod
    def adapt_native_to_emulated(cls, impl, **kw): ...
    @classmethod
    def adapt_emulated_to_native(cls, impl: Unused, **kw) -> Self: ...

class TypeDecorator(ExternalType, SchemaEventTarget, TypeEngine):
    __visit_name__: str
    impl: Any
    def __init__(self, *args, **kwargs) -> None: ...
    coerce_to_is_types: tuple[type[Incomplete], ...]

    class Comparator(TypeEngine.Comparator[_T]):
        def operate(self, op: Callable[_P, _T], *other: _P.args, **kwargs: _P.kwargs) -> _T: ...  # type: ignore[override]  # _T doesn't match
        def reverse_operate(self, op: Callable[..., _T], other, **kwargs) -> _T: ...  # type: ignore[override]  # _T doesn't match

    @property
    def comparator_factory(self) -> type[TypeDecorator.Comparator[Incomplete]]: ...  # type: ignore[override]  # supertype is attribute
    def type_engine(self, dialect: Dialect) -> TypeEngine: ...
    def load_dialect_impl(self, dialect: Dialect) -> TypeEngine: ...
    def __getattr__(self, key: str): ...
    def process_literal_param(self, value, dialect: Dialect) -> str | None: ...
    def process_bind_param(self, value, dialect: Dialect) -> str | None: ...
    def process_result_value(self, value, dialect: Dialect) -> Incomplete | None: ...
    def literal_processor(self, dialect: Dialect) -> Callable[[Incomplete | None], str | None]: ...
    def bind_processor(self, dialect: Dialect) -> Callable[[Incomplete | None], str | None]: ...
    def result_processor(self, dialect: Dialect, coltype) -> Callable[[Incomplete | None], Incomplete | None]: ...
    def bind_expression(self, bindparam): ...
    def column_expression(self, column): ...
    def coerce_compared_value(self, op: Unused, value: Unused) -> Self | TypeEngine: ...
    def copy(self, **kw: Unused) -> Self: ...
    def get_dbapi_type(self, dbapi): ...
    def compare_values(self, x, y) -> bool: ...
    @property
    def sort_key_function(self): ...

class Variant(TypeDecorator):
    cache_ok: bool
    impl: Any
    mapping: Mapping[str, TypeEngine]
    def __init__(self, base: TypeEngine, mapping: Mapping[str, TypeEngine]) -> None: ...
    def coerce_compared_value(self, operator, value) -> Self | TypeEngine: ...
    def load_dialect_impl(self, dialect: Dialect) -> TypeEngine: ...
    def with_variant(  # type: ignore[override]  # supertype ensures type[TypeEngine] is instanciated
        self, type_: TypeEngine, dialect_name: str
    ) -> Variant: ...
    @property
    def comparator_factory(self) -> type: ...  # type: ignore[override]  # supertype is attribute

@overload
def to_instance(typeobj: None, *arg: Unused, **kw: Unused) -> None: ...
@overload
def to_instance(typeobj: Callable[_P, _T], *arg: _P.args, **kw: _P.kwargs) -> _T: ...
@overload
def to_instance(typeobj: _T, *arg: Unused, **kw: Unused) -> _T: ...
def adapt_type(typeobj, colspecs: Mapping[type[Incomplete], Incomplete]): ...
