from _typeshed import Incomplete, Unused
from abc import ABCMeta, abstractmethod
from collections.abc import Iterable, Iterator, Mapping
from itertools import chain
from typing import Any, NoReturn, overload
from typing_extensions import Self

from .. import util
from ..engine import Connection, Engine
from ..sql.coercions import _CoercibleElement
from ..sql.dml import Delete, Insert, Update
from ..sql.functions import Function
from ..sql.schema import ForeignKey
from ..sql.type_api import TypeEngine
from ..util.langhelpers import HasMemoized, memoized_property
from . import roles, traversals, visitors
from .annotation import Annotated, SupportsCloneAnnotations
from .base import (
    CacheableOptions,
    ColumnSet,
    CompileState,
    Executable,
    Generative,
    HasCompileState,
    Immutable,
    ImmutableColumnCollection,
)
from .elements import (
    BindParameter as BindParameter,
    BooleanClauseList as BooleanClauseList,
    ClauseElement as ClauseElement,
    ClauseList as ClauseList,
    ColumnClause as ColumnClause,
    ColumnElement,
    GroupedElement as GroupedElement,
    Grouping as Grouping,
    Label,
    TableValuedColumn as TableValuedColumn,
    TextClause,
    UnaryExpression as UnaryExpression,
    literal_column as literal_column,
)

class _OffsetLimitParam(BindParameter[Any]):
    inherit_cache: bool

def subquery(alias, *args, **kwargs) -> Subquery: ...

class ReturnsRows(roles.ReturnsRowsRole, ClauseElement):
    @property
    def selectable(self): ...
    @property
    def exported_columns(self) -> None: ...

class Selectable(ReturnsRows):
    __visit_name__: str
    is_selectable: bool
    def lateral(self, name: Incomplete | None = None) -> Lateral: ...
    def replace_selectable(self, old, alias): ...
    def corresponding_column(self, column, require_embedded: bool = False): ...

class HasPrefixes:
    def prefix_with(self, *expr: str | ClauseElement, **kw) -> Self: ...

class HasSuffixes:
    def suffix_with(self, *expr: str | ClauseElement, **kw) -> Self: ...

class HasHints:
    def with_statement_hint(self, text: str, dialect_name: str = "*") -> Self: ...
    def with_hint(self, selectable: _CoercibleElement | None, text: str, dialect_name: str = "*") -> Self: ...

class FromClause(roles.AnonymizedFromClauseRole, Selectable):
    __visit_name__: str
    named_with_column: bool
    schema: str | None
    is_selectable: bool
    def select(self, whereclause: bool | str | visitors.Traversible | None = None, **kwargs) -> Select: ...
    def join(
        self, right: FromClause, onclause: ClauseElement | None = None, isouter: bool = False, full: bool = False
    ) -> Join: ...
    def outerjoin(self, right: FromClause, onclause: ClauseElement | None = None, full: bool = False) -> Join: ...
    def alias(self, name: str | None = None, flat: bool = False) -> Alias: ...
    def table_valued(self) -> TableValuedColumn: ...
    def tablesample(self, sampling: float | Function, name: str | None = None, seed: Incomplete | None = None) -> TableSample: ...
    def is_derived_from(self, fromclause: FromClause) -> bool: ...
    @property
    def description(self) -> str: ...
    @property
    def exported_columns(self): ...
    @memoized_property
    def columns(self) -> ImmutableColumnCollection: ...
    @property
    def entity_namespace(self): ...
    @memoized_property
    def primary_key(self) -> ColumnSet: ...
    @memoized_property
    def foreign_keys(self) -> set[ForeignKey]: ...
    @property
    def c(self) -> ImmutableColumnCollection: ...

LABEL_STYLE_NONE: Any
LABEL_STYLE_TABLENAME_PLUS_COL: Any
LABEL_STYLE_DISAMBIGUATE_ONLY: Any
LABEL_STYLE_DEFAULT: Any

class Join(roles.DMLTableRole, FromClause):
    __visit_name__: str
    left: FromClause
    right: FromClause
    onclause: ClauseElement
    isouter: bool
    full: bool
    def __init__(
        self,
        left: FromClause,
        right: FromClause,
        onclause: ClauseElement | None = None,
        isouter: bool = False,
        full: bool = False,
    ) -> None: ...
    @property
    def description(self) -> str: ...
    def is_derived_from(self, fromclause: FromClause) -> bool: ...
    def self_group(self, against: Unused = None) -> FromGrouping: ...  # type: ignore[override]  # Actual return type
    def select(self, whereclause: bool | str | visitors.Traversible | None = None, **kwargs) -> Select: ...
    @property
    def bind(self) -> Engine | Connection | None: ...
    def alias(self, name: str | None = None, flat: bool = False) -> Alias | Join: ...  # type: ignore[override]

class NoInit:
    @abstractmethod
    def __init__(self, *arg: Unused, **kw: Unused) -> None: ...

class _AliasedReturnRowsMetaMixin(visitors.TraversibleType, ABCMeta): ...

class AliasedReturnsRows(NoInit, FromClause, metaclass=_AliasedReturnRowsMetaMixin):
    named_with_column: bool
    @property
    def description(self) -> str: ...
    @property
    def original(self) -> Selectable: ...
    def is_derived_from(self, fromclause: FromClause) -> bool: ...
    @property
    def bind(self) -> Engine | Connection | None: ...

class Alias(roles.DMLTableRole, AliasedReturnsRows, metaclass=ABCMeta):
    __visit_name__: str
    inherit_cache: bool

class TableValuedAlias(Alias, metaclass=ABCMeta):
    __visit_name__: str
    joins_implicitly: bool
    def _init(
        self,
        selectable,
        name: Incomplete | None = None,
        table_value_type: Incomplete | None = None,
        joins_implicitly: bool = False,
    ) -> None: ...
    @HasMemoized.memoized_attribute
    def column(self): ...
    def alias(self, name: Incomplete | None = None) -> TableValuedAlias: ...  # type: ignore[override]
    def lateral(self, name: Incomplete | None = None) -> TableValuedAlias: ...  # type: ignore[override]
    def render_derived(self, name: Incomplete | None = None, with_types: bool = False): ...

class Lateral(AliasedReturnsRows, metaclass=ABCMeta):
    __visit_name__: str
    inherit_cache: bool

class TableSample(AliasedReturnsRows, metaclass=ABCMeta):
    __visit_name__: str

class CTE(roles.DMLTableRole, roles.IsCTERole, Generative, HasPrefixes, HasSuffixes, AliasedReturnsRows, metaclass=ABCMeta):
    __visit_name__: str
    def alias(self, name: str | None = None, flat: Unused = False) -> CTE: ...  # type: ignore[override]
    def union(self, *other: Select) -> CTE: ...
    def union_all(self, *other: Select) -> CTE: ...

class HasCTE(roles.HasCTERole):
    def add_cte(self, cte) -> Self: ...
    def cte(self, name: str | None = None, recursive: bool = False, nesting: bool = False) -> CTE: ...

class Subquery(AliasedReturnsRows, metaclass=ABCMeta):
    __visit_name__: str
    inherit_cache: bool
    def as_scalar(self): ...

class FromGrouping(GroupedElement, FromClause):
    element: FromClause
    def __init__(self, element: _CoercibleElement) -> None: ...
    @property
    def columns(self) -> ImmutableColumnCollection: ...  # type: ignore[override]  # supertype is @util.memoized_property
    @property
    def primary_key(self) -> ColumnSet: ...  # type: ignore[override]  # supertype is @util.memoized_property
    @property
    def foreign_keys(self) -> set[ForeignKey]: ...  # type: ignore[override]  # supertype is @util.memoized_property
    def is_derived_from(self, element: FromClause) -> bool: ...
    def alias(self, **kw) -> FromGrouping: ...  # type: ignore[override]

class TableClause(roles.DMLTableRole, Immutable, FromClause):
    __visit_name__: str
    named_with_column: bool
    implicit_returning: bool
    name: str
    @memoized_property
    def primary_key(self) -> ColumnSet: ...
    @memoized_property
    def foreign_keys(self) -> set[ForeignKey]: ...
    schema: Any
    fullname: Any
    def __init__(self, name: str, *columns: ColumnClause, **kw) -> None: ...
    @memoized_property
    def description(self) -> str: ...  # type: ignore[override]  # supertype is @property
    def append_column(self, c: ColumnClause, **kw: Unused) -> None: ...
    def insert(self, values: Mapping[Incomplete, Incomplete] | None = None, inline: bool = False, **kwargs) -> Insert: ...
    def update(
        self,
        whereclause: bool | str | visitors.Traversible | None = None,
        values: Mapping[Incomplete, Incomplete] | None = None,
        inline: bool = False,
        **kwargs,
    ) -> Update: ...
    def delete(self, whereclause: bool | str | visitors.Traversible | None = None, **kwargs) -> Delete: ...

class ForUpdateArg(ClauseElement):
    def __eq__(self, other) -> bool: ...
    def __ne__(self, other) -> bool: ...
    def __hash__(self) -> int: ...
    nowait: bool
    read: bool
    skip_locked: bool
    key_share: bool
    of: list[ColumnClause] | None
    def __init__(
        self,
        nowait: bool = False,
        read: bool = False,
        of: Iterable[_CoercibleElement] | None = None,
        skip_locked: bool = False,
        key_share: bool = False,
    ) -> None: ...

class Values(Generative, FromClause):
    named_with_column: bool
    __visit_name__: str
    name: Any
    literal_binds: Any
    def __init__(self, *columns, **kw) -> None: ...
    def alias(self, name: Incomplete | None, **kw: Unused) -> Self: ...  # type: ignore[override]
    def lateral(self, name: Incomplete | None = None) -> Self: ...  # type: ignore[override]
    def data(self, values) -> Self: ...

class SelectBase(
    roles.SelectStatementRole,
    roles.DMLSelectRole,
    roles.CompoundElementRole,
    roles.InElementRole,
    HasCTE,
    Executable,
    SupportsCloneAnnotations,
    Selectable,
):
    is_select: bool
    @property
    def selected_columns(self) -> None: ...
    @property
    def exported_columns(self): ...
    @property
    def c(self): ...
    @property
    def columns(self): ...
    def select(self, *arg, **kw): ...
    def as_scalar(self) -> ScalarSelect: ...
    def exists(self): ...
    def scalar_subquery(self): ...
    def label(self, name: str) -> Label: ...
    def lateral(self, name: Incomplete | None = None) -> Lateral: ...
    def subquery(self, name: Incomplete | None = None) -> Subquery: ...
    def alias(self, name: Incomplete | None = None, flat: Unused = False) -> Subquery: ...

class SelectStatementGrouping(GroupedElement, SelectBase):
    __visit_name__: str
    element: Any
    def __init__(self, element) -> None: ...
    def get_label_style(self): ...
    def set_label_style(self, label_style): ...
    @property
    def select_statement(self): ...
    def self_group(self, against: Unused = None) -> Self: ...
    @property
    def selected_columns(self): ...

class DeprecatedSelectBaseGenerations:
    def append_order_by(self, *clauses) -> None: ...
    def append_group_by(self, *clauses) -> None: ...

class GenerativeSelect(DeprecatedSelectBaseGenerations, SelectBase):
    def __init__(
        self,
        _label_style=...,
        use_labels: bool = False,
        limit: int | None = None,
        offset: int | None = None,
        order_by: int | str | visitors.Traversible | Iterable[int | str | visitors.Traversible] | None = None,
        group_by: int | str | visitors.Traversible | Iterable[int | str | visitors.Traversible] | None = None,
        bind: Engine | Connection | None = None,
    ) -> None: ...
    def with_for_update(
        self,
        nowait: bool = False,
        read: bool = False,
        of: _CoercibleElement | None = None,
        skip_locked: bool = False,
        key_share: bool = False,
    ) -> Self: ...
    def get_label_style(self): ...
    def set_label_style(self, style) -> Self: ...
    def apply_labels(self) -> Self: ...
    def limit(self, limit: int | str | visitors.Traversible | None) -> Self: ...
    def fetch(self, count: int | str | visitors.Traversible | None, with_ties: bool = False, percent: bool = False) -> Self: ...
    def offset(self, offset: int | str | visitors.Traversible | None) -> Self: ...
    def slice(self, start: Incomplete | None, stop: Incomplete | None) -> Self: ...
    def order_by(self, *clauses: _CoercibleElement | None) -> Self: ...
    def group_by(self, *clauses: _CoercibleElement | None) -> Self: ...

class CompoundSelectState(CompileState): ...

class CompoundSelect(HasCompileState, GenerativeSelect):
    __visit_name__: str
    UNION: Any
    UNION_ALL: Any
    EXCEPT: Any
    EXCEPT_ALL: Any
    INTERSECT: Any
    INTERSECT_ALL: Any
    keyword: Any
    selects: list[SelectStatementGrouping]
    def __init__(self, keyword, *selects: _CoercibleElement, **kwargs) -> None: ...
    def self_group(self, against: Unused = None) -> SelectStatementGrouping: ...  # type: ignore[override]  # Actual return type
    def is_derived_from(self, fromclause: FromClause) -> bool: ...
    @property
    def selected_columns(self): ...
    @property
    def bind(self) -> Engine | Connection | None: ...
    @bind.setter
    def bind(self, bind: Engine | Connection | None) -> None: ...

class DeprecatedSelectGenerations:
    def append_correlation(self, fromclause: FromClause) -> None: ...
    def append_column(self, column: ColumnElement[Incomplete]) -> None: ...
    def append_prefix(self, clause) -> None: ...
    def append_whereclause(self, whereclause: str | bool | visitors.Traversible) -> None: ...
    def append_having(self, having: str | bool | visitors.Traversible) -> None: ...
    def append_from(self, fromclause: FromClause) -> None: ...

class SelectState(util.MemoizedSlots, CompileState):
    class default_select_compile_options(CacheableOptions): ...
    statement: Any
    from_clauses: Any
    froms: Any
    columns_plus_names: Any
    def __init__(self, statement, compiler, **kw) -> None: ...
    @classmethod
    def get_column_descriptions(cls, statement) -> None: ...
    @classmethod
    def from_statement(cls, statement, from_statement) -> None: ...
    @classmethod
    def get_columns_clause_froms(cls, statement): ...
    @classmethod
    def determine_last_joined_entity(cls, stmt): ...
    @classmethod
    def all_selected_columns(cls, statement): ...

class _SelectFromElements: ...

class _MemoizedSelectEntities(traversals.HasCacheKey, traversals.HasCopyInternals, visitors.Traversible):
    __visit_name__: str

class Select(
    HasPrefixes, HasSuffixes, HasHints, HasCompileState, DeprecatedSelectGenerations, _SelectFromElements, GenerativeSelect
):
    __visit_name__: str
    @classmethod
    def create_legacy_select(
        cls,
        columns: Incomplete | None = None,
        whereclause: bool | str | visitors.Traversible | None = None,
        from_obj: Incomplete | None = None,
        distinct: bool = False,
        having: Incomplete | None = None,
        correlate: bool = True,
        prefixes: Incomplete | None = None,
        suffixes: Incomplete | None = None,
        **kwargs,
    ): ...
    @abstractmethod
    def __init__(self) -> None: ...
    def filter(self, *criteria) -> Self: ...
    def filter_by(self, **kwargs) -> Self: ...
    @property
    def column_descriptions(self): ...
    def from_statement(self, statement): ...
    def join(self, target, onclause: Incomplete | None = None, isouter: bool = False, full: bool = False) -> Self: ...
    def outerjoin_from(self, from_, target, onclause: Incomplete | None = None, full: bool = False): ...
    def join_from(self, from_, target, onclause: Incomplete | None = None, isouter: bool = False, full: bool = False) -> Self: ...
    def outerjoin(self, target, onclause: Incomplete | None = None, full: bool = False): ...
    def get_final_froms(self): ...
    @property
    def froms(self) -> list[FromClause]: ...
    @property
    def columns_clause_froms(self): ...
    @property
    def inner_columns(self) -> Iterator[ColumnElement[Incomplete]]: ...
    def is_derived_from(self, fromclause: FromClause) -> bool: ...
    def get_children(self, **kwargs: Unused) -> chain[ClauseElement]: ...  # type: ignore[override]
    def add_columns(self, *columns) -> Self: ...
    def column(self, column: ColumnElement[Incomplete]) -> Self: ...
    def reduce_columns(self, only_synonyms: bool = True) -> Self: ...
    def with_only_columns(self, *columns: ColumnElement[Incomplete], **kw) -> Self: ...
    @property
    def whereclause(self) -> BooleanClauseList | ColumnElement[Incomplete] | None: ...
    def where(self, *whereclause: str | bool | visitors.Traversible) -> Self: ...
    def having(self, having: str | bool | visitors.Traversible) -> Self: ...
    def distinct(self, *expr: _CoercibleElement) -> Self: ...
    def select_from(self, *froms: _CoercibleElement) -> Self: ...
    def correlate(self, *fromclauses: _CoercibleElement) -> Self: ...
    def correlate_except(self, *fromclauses: _CoercibleElement) -> Self: ...
    @HasMemoized.memoized_attribute
    def selected_columns(self): ...
    @overload  # type: ignore[override]  # Actual return type
    def self_group(  # type: ignore[misc]  # supertype has more overloads
        self, against: CompoundSelect
    ) -> Self | SelectStatementGrouping: ...
    @overload
    def self_group(self, against: object = None) -> SelectStatementGrouping: ...
    def union(self, *other: Selectable, **kwargs) -> CompoundSelect: ...
    def union_all(self, *other: Selectable, **kwargs) -> CompoundSelect: ...
    def except_(self, *other: Selectable, **kwargs) -> CompoundSelect: ...
    def except_all(self, *other: Selectable, **kwargs) -> CompoundSelect: ...
    def intersect(self, *other: Selectable, **kwargs) -> CompoundSelect: ...
    def intersect_all(self, *other: Selectable, **kwargs) -> CompoundSelect: ...
    @property
    def bind(self) -> Engine | Connection | None: ...
    @bind.setter
    def bind(self, bind: Engine | Connection | None) -> None: ...

class ScalarSelect(roles.InElementRole, Generative, Grouping):
    inherit_cache: bool
    element: ClauseElement
    @memoized_property
    def type(self) -> TypeEngine: ...  # type: ignore[override]  # @memoized_property causes override issue
    def __init__(self, element: ClauseElement) -> None: ...
    @property
    def columns(self) -> NoReturn: ...
    @property
    def c(self): ...
    def where(self, crit: ClauseElement) -> Self: ...
    def self_group(self, **kwargs: Unused) -> Self: ...  # type: ignore[override]  # supertype has overloads
    def correlate(self, *fromclauses) -> Self: ...
    def correlate_except(self, *fromclauses) -> Self: ...

class Exists(UnaryExpression):
    inherit_cache: bool
    def __init__(self, *args, **kwargs) -> None: ...
    def select(self, whereclause: bool | str | visitors.Traversible | None = None, **kwargs): ...
    def correlate(self, *fromclause: FromClause): ...
    def correlate_except(self, *fromclause: FromClause): ...
    def select_from(self, *froms: FromClause): ...
    def where(self, *clause: ClauseElement): ...

class TextualSelect(SelectBase):
    __visit_name__: str
    is_text: bool
    is_select: bool
    element: TextClause
    column_args: Any
    positional: Any
    def __init__(self, text: TextClause, columns: Iterable[_CoercibleElement], positional: bool = False) -> None: ...
    @HasMemoized.memoized_attribute
    def selected_columns(self): ...
    def bindparams(self, *binds: BindParameter[Incomplete], **bind_as_values) -> Self: ...

TextAsFrom = TextualSelect

class AnnotatedFromClause(Annotated):  # pyright: ignore[reportMissingTypeArgument]  # pytype issue
    def __init__(self, element: FromClause, values) -> None: ...
