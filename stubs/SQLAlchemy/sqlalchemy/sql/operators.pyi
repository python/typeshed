from _operator import _SupportsComparison
from _typeshed import Incomplete, SupportsGetItem
from abc import abstractmethod
from collections.abc import Callable, Container, Iterable, Sequence
from operator import (
    add as add,
    and_ as and_,
    contains as contains,
    eq as eq,
    ge as ge,
    getitem as getitem,
    gt as gt,
    inv as inv,
    le as le,
    lshift as lshift,
    lt as lt,
    mod as mod,
    mul as mul,
    ne as ne,
    neg as neg,
    or_ as or_,
    rshift as rshift,
    sub as sub,
    truediv,
)
from typing import Any, Generic, NoReturn, TypeVar, overload
from typing_extensions import Literal, ParamSpec, TypeAlias

from ..sql.coercions import _CoercibleElement
from ..sql.elements import BinaryExpression, BooleanClauseList, CollectionAggregate, ColumnElement, UnaryExpression
from ..util.langhelpers import _symbol, symbol

_T = TypeVar("_T")
_P = ParamSpec("_P")
_AnyOperator: TypeAlias = Callable[[], Any] | Callable[[Any], Any] | Callable[[Any, Any], Any] | _symbol | symbol

div = truediv

class Operators:
    def op(
        self, opstring, precedence: int = 0, is_comparison: bool = False, return_type: Incomplete | None = None
    ) -> Callable[[Incomplete], Incomplete]: ...
    def bool_op(self, opstring, precedence: int = 0) -> Callable[[Incomplete], Incomplete]: ...
    @abstractmethod
    def operate(self, op: Callable[_P, _T], *other: _P.args, **kwargs: _P.kwargs) -> _T: ...
    @abstractmethod
    def reverse_operate(self, op: Callable[..., _T], other, **kwargs) -> _T: ...
    # ALL of the methods below use self.operate. This means if a subtype overrides self.operate,
    # we must redefine ALL of the methods below for that subtype.
    # Same as stdlib._operators (but Any is replaced with same as all subtypes)
    def __invert__(self) -> NoReturn | UnaryExpression: ...
    def __and__(self, other: _CoercibleElement) -> BooleanClauseList | ColumnElement[Incomplete]: ...
    def __or__(self, other: _CoercibleElement) -> BooleanClauseList | ColumnElement[Incomplete]: ...

class custom_op:
    __name__: str
    opstring: str
    precedence: int
    is_comparison: bool
    natural_self_precedent: bool
    eager_grouping: bool
    return_type: Incomplete | None
    def __init__(
        self,
        opstring: str,
        precedence: int = 0,
        is_comparison: bool = False,
        return_type: Incomplete | None = None,
        natural_self_precedent: bool = False,
        eager_grouping: bool = False,
    ) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __call__(self, left, right, **kw): ...

class ColumnOperators(Operators, Generic[_T]):
    # "Hack, allows datetime objects to be compared on the LHS."
    timetuple: None
    # Same as base class. Defining so it's not abstract, wich causes issues with subtypes' metaclasses
    def operate(self, op: Callable[_P, _T], *other: _P.args, **kwargs: _P.kwargs) -> NoReturn | _T: ...  # type: ignore[override]  # _T doesn't match
    def reverse_operate(self, op: Callable[..., _T], other, **kwargs) -> NoReturn | _T: ...  # type: ignore[override]  # _T doesn't match
    # ALL of the methods below marked with NoReturn use self.operate. This means when a subtype overrides self.operate
    # with a different signature, we must redefine ALL of those methods for that subtype.
    #
    # The return type of these fully depends on the subtype's implementation of these methods or the operate method.
    # If neither is implemented, they throw NotImplementedError.
    # They are effectively abstract methods so we define their return types to match all subtypes.
    def is_distinct_from(self, other) -> NoReturn | BinaryExpression: ...
    def is_not_distinct_from(self, other) -> NoReturn | BinaryExpression: ...
    def concat(self, other: _T | ColumnOperators[_T] | None) -> NoReturn | BinaryExpression: ...
    def like(self, other: _T, escape: str | None = None) -> NoReturn | BinaryExpression: ...
    def ilike(self, other: _T, escape: str | None = None) -> NoReturn | BinaryExpression: ...
    def in_(self, other: Container[_T] | Iterable[_T]) -> NoReturn | BinaryExpression: ...
    def not_in(self, other: Container[_T] | Iterable[_T]) -> NoReturn | BinaryExpression: ...
    def not_like(self, other: _T, escape: str | None = None) -> NoReturn | BinaryExpression: ...
    def not_ilike(self, other: _T, escape: str | None = None) -> NoReturn | BinaryExpression: ...
    def is_(self, other: _T) -> NoReturn | BinaryExpression: ...
    def is_not(self, other: _T) -> NoReturn | BinaryExpression: ...
    def startswith(self, other: str, **kwargs) -> NoReturn | BinaryExpression: ...
    def endswith(self, other: str, **kwargs) -> NoReturn | BinaryExpression: ...
    def contains(self, other: str, **kwargs) -> NoReturn | BinaryExpression: ...  # noqa: F811  # False-positive
    def match(self, other: str, **kwargs) -> NoReturn | BinaryExpression: ...
    def regexp_match(self, pattern, flags: Incomplete | None = None) -> NoReturn | BinaryExpression: ...
    def regexp_replace(self, pattern, replacement, flags: Incomplete | None = None) -> NoReturn | BinaryExpression: ...
    def collate(self, collation) -> NoReturn | Incomplete: ...
    def between(self, cleft, cright, symmetric: bool = False) -> NoReturn | Incomplete: ...
    def desc(self) -> NoReturn | UnaryExpression: ...
    def asc(self) -> NoReturn | UnaryExpression: ...
    def nulls_first(self) -> NoReturn | UnaryExpression: ...
    def nulls_last(self) -> NoReturn | UnaryExpression: ...
    def distinct(self) -> NoReturn | UnaryExpression: ...
    def any_(self) -> NoReturn | CollectionAggregate: ...
    def all_(self) -> NoReturn | CollectionAggregate: ...
    isnot_distinct_from = is_not_distinct_from
    isnot = is_not
    notin_ = not_in
    notlike = not_like
    notilike = not_ilike
    nullsfirst = nulls_first
    nullslast = nulls_last
    # Same as stdlib._operators (but Any is replaced with "Unknown" or same as all subtypes)
    def __eq__(self, other: object) -> NoReturn | BinaryExpression | bool: ...  # type: ignore[override]
    def __ne__(self, other: object) -> NoReturn | BinaryExpression | bool: ...  # type: ignore[override]
    def __ge__(self, other: _SupportsComparison) -> NoReturn | BinaryExpression | bool: ...
    def __gt__(self, other: _SupportsComparison) -> NoReturn | BinaryExpression | bool: ...
    def __le__(self, other: _SupportsComparison) -> NoReturn | BinaryExpression | bool: ...
    def __lt__(self, other: _SupportsComparison) -> NoReturn | BinaryExpression | bool: ...
    def __contains__(self, other: object) -> NoReturn | bool: ...
    def __lshift__(self, other) -> NoReturn | BinaryExpression: ...
    def __rshift__(self, other) -> NoReturn | BinaryExpression: ...
    def __add__(self, other) -> NoReturn | BinaryExpression: ...
    def __radd__(self, other) -> NoReturn | BinaryExpression: ...
    def __mod__(self, other) -> NoReturn | BinaryExpression: ...
    def __rmod__(self, other) -> NoReturn | BinaryExpression: ...
    def __mul__(self, other) -> NoReturn | BinaryExpression: ...
    def __rmul__(self, other) -> NoReturn | BinaryExpression: ...
    def __sub__(self, other) -> NoReturn | BinaryExpression: ...
    def __rsub__(self, other) -> NoReturn | BinaryExpression: ...
    def __div__(self, other) -> NoReturn | BinaryExpression: ...
    def __rdiv__(self, other) -> NoReturn | BinaryExpression: ...
    def __truediv__(self, other) -> NoReturn | BinaryExpression: ...
    def __rtruediv__(self, other) -> NoReturn | BinaryExpression: ...
    def __neg__(self) -> NoReturn | UnaryExpression: ...
    @overload
    def __getitem__(self, index: Sequence[_T]) -> NoReturn | Sequence[_T] | BinaryExpression: ...  # type: ignore[misc]
    @overload
    def __getitem__(
        self, index: SupportsGetItem[Any, _T]  # no __b means Any key type is viable
    ) -> NoReturn | _T | BinaryExpression: ...

def commutative_op(fn): ...
def comparison_op(fn): ...
def from_() -> None: ...
def function_as_comparison_op() -> None: ...
def as_() -> None: ...
def exists() -> None: ...
def is_true(a) -> None: ...

istrue = is_true

def is_false(a) -> None: ...

isfalse = is_false

def is_distinct_from(a, b): ...
def is_not_distinct_from(a, b): ...

isnot_distinct_from = is_not_distinct_from

def is_(a, b): ...
def is_not(a, b): ...

isnot = is_not

def collate(a, b): ...
def op(a, opstring, b): ...
def like_op(a, b, escape: Incomplete | None = None): ...
def not_like_op(a, b, escape: Incomplete | None = None): ...

notlike_op = not_like_op

def ilike_op(a, b, escape: Incomplete | None = None): ...
def not_ilike_op(a, b, escape: Incomplete | None = None): ...

notilike_op = not_ilike_op

def between_op(a, b, c, symmetric: bool = False): ...
def not_between_op(a, b, c, symmetric: bool = False): ...

notbetween_op = not_between_op

def in_op(a, b): ...
def not_in_op(a, b): ...

notin_op = not_in_op

def distinct_op(a): ...
def any_op(a): ...
def all_op(a): ...
def startswith_op(a, b, escape: Incomplete | None = None, autoescape: bool = False): ...
def not_startswith_op(a, b, escape: Incomplete | None = None, autoescape: bool = False): ...

notstartswith_op = not_startswith_op

def endswith_op(a, b, escape: Incomplete | None = None, autoescape: bool = False): ...
def not_endswith_op(a, b, escape: Incomplete | None = None, autoescape: bool = False): ...

notendswith_op = not_endswith_op

def contains_op(a, b, escape: Incomplete | None = None, autoescape: bool = False): ...
def not_contains_op(a, b, escape: Incomplete | None = None, autoescape: bool = False): ...

notcontains_op = not_contains_op

def match_op(a, b, **kw): ...
def regexp_match_op(a, b, flags: Incomplete | None = None): ...
def not_regexp_match_op(a, b, flags: Incomplete | None = None): ...
def regexp_replace_op(a, b, replacement, flags: Incomplete | None = None): ...
def not_match_op(a, b, **kw): ...

notmatch_op = not_match_op

def comma_op(a, b) -> None: ...
def filter_op(a, b) -> None: ...
def concat_op(a, b): ...
def desc_op(a): ...
def asc_op(a): ...
def nulls_first_op(a): ...

nullsfirst_op = nulls_first_op

def nulls_last_op(a): ...

nullslast_op = nulls_last_op

def json_getitem_op(a, b) -> None: ...
def json_path_getitem_op(a, b) -> None: ...
def is_comparison(op) -> bool: ...
def is_commutative(op) -> bool: ...
def is_ordering_modifier(op) -> bool: ...
def is_natural_self_precedent(op) -> bool: ...
def is_boolean(op) -> bool: ...
def mirror(op): ...
def is_associative(op) -> bool: ...
@overload
def is_precedent(operator: _AnyOperator, against: _AnyOperator) -> bool: ...  # type: ignore[misc]
@overload
def is_precedent(operator: object, against: object) -> Literal[True]: ...
