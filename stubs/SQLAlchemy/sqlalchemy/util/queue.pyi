from _typeshed import Incomplete
from collections import deque
from threading import Condition, RLock
from typing import Any

class Empty(Exception): ...
class Full(Exception): ...

class Queue:
    mutex: RLock
    not_empty: Condition
    not_full: Condition
    use_lifo: Any
    maxsize: int
    queue: deque[Incomplete]
    def __init__(self, maxsize: int = 0, use_lifo: bool = False) -> None: ...
    def qsize(self): ...
    def empty(self): ...
    def full(self): ...
    def put(self, item, block: bool = True, timeout: Incomplete | None = None) -> None: ...
    def put_nowait(self, item): ...
    def get(self, block: bool = True, timeout: Incomplete | None = None): ...
    def get_nowait(self): ...

class AsyncAdaptedQueue:
    await_: Any
    use_lifo: Any
    maxsize: Any
    def __init__(self, maxsize: int = 0, use_lifo: bool = False) -> None: ...
    def empty(self): ...
    def full(self): ...
    def qsize(self): ...
    def put_nowait(self, item): ...
    def put(self, item, block: bool = True, timeout: Incomplete | None = None): ...
    def get_nowait(self): ...
    def get(self, block: bool = True, timeout: Incomplete | None = None): ...

class FallbackAsyncAdaptedQueue(AsyncAdaptedQueue):
    await_: Any
