from collections.abc import Iterable, Iterator
from typing import Any, TypeVar, overload

from mypy.nodes import CallExpr, Context, Expression, JsonDict, NameExpr, Statement, TypeInfo
from mypy.plugin import ClassDefContext, DynamicClassDefContext, SemanticAnalyzerPluginInterface
from mypy.types import Type

_TArgType = TypeVar("_TArgType", bound=CallExpr | NameExpr)

class SQLAlchemyAttribute:
    name: Any
    line: Any
    column: Any
    type: Any
    info: Any
    def __init__(self, name: str, line: int, column: int, typ: Type | None, info: TypeInfo) -> None: ...
    def serialize(self) -> JsonDict: ...
    def expandtypevar_from_subtype(self, subtype: TypeInfo) -> None: ...
    @classmethod
    def deserialize(cls, info: TypeInfo, data: JsonDict, api: SemanticAnalyzerPluginInterface) -> SQLAlchemyAttribute: ...

def name_is_dunder(name): ...
def establish_as_sqlalchemy(info: TypeInfo) -> None: ...
def set_is_base(info: TypeInfo) -> None: ...
def get_is_base(info: TypeInfo) -> bool: ...
def has_declarative_base(info: TypeInfo) -> bool: ...
def set_has_table(info: TypeInfo) -> None: ...
def get_has_table(info: TypeInfo) -> bool: ...
def get_mapped_attributes(info: TypeInfo, api: SemanticAnalyzerPluginInterface) -> list[SQLAlchemyAttribute] | None: ...
def set_mapped_attributes(info: TypeInfo, attributes: list[SQLAlchemyAttribute]) -> None: ...
def fail(api: SemanticAnalyzerPluginInterface, msg: str, ctx: Context) -> None: ...
def add_global(ctx: ClassDefContext | DynamicClassDefContext, module: str, symbol_name: str, asname: str) -> None: ...
@overload
def getcallexpr_kwarg(callexpr: CallExpr, name: str, *, exprtypes: None = ...) -> CallExpr | NameExpr | None: ...
@overload
def getcallexpr_kwarg(callexpr: CallExpr, name: str, *, exprtypes: tuple[type[_TArgType], ...]) -> _TArgType | None: ...
def flattentypechecking(stmts: Iterable[Statement]) -> Iterator[Statement]: ...
def unbound_to_instance(api: SemanticAnalyzerPluginInterface, typ: Type) -> Type: ...
def info_for_cls(cls, api: SemanticAnalyzerPluginInterface) -> TypeInfo | None: ...
def expr_to_mapped_constructor(expr: Expression) -> CallExpr: ...
