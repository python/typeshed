import re
from collections.abc import Callable, Iterable, Sequence
from io import TextIOWrapper
from typing import Any, TypeVar

split_path_re: re.Pattern[str]
doctype_lookup_re: re.Pattern[str]
tag_re: re.Pattern[str]
xml_decl_re: re.Pattern[str]

class ClassNotFound(ValueError): ...
class OptionError(Exception): ...

def get_choice_opt(
    options: dict[str, Any], optname: str, allowed: Sequence[str], default: Any = None, normcase: bool = False
) -> str: ...
def get_bool_opt(options: dict[str, Any], optname: str, default: Any = None) -> bool: ...
def get_int_opt(options: dict[str, Any], optname: str, default: Any = None) -> int: ...
def get_list_opt(options: dict[str, Any], optname: str, default: Any = None) -> list[str]: ...
def docstring_headline(obj: Callable[..., Any]) -> str: ...
def make_analysator(f: Callable[[str], float]) -> Callable[[str], float]: ...
def shebang_matches(text: str, regex: str) -> bool: ...
def doctype_matches(text: str, regex: str) -> bool: ...
def html_doctype_matches(text: str) -> bool: ...
def looks_like_xml(text: str) -> bool: ...
def surrogatepair(c: int) -> tuple[int, int]: ...
def format_lines(var_name: str, seq: Sequence[str], raw: bool = False, indent_level: int = 0) -> str: ...

_T = TypeVar("_T")

def duplicates_removed(it: Iterable[_T], already_seen: tuple[_T, ...] = ()) -> list[_T]: ...

class Future:
    def get(self) -> str: ...

def guess_decode(text: bytes) -> tuple[bytes, str]: ...

# In the following two methods, `term` are file-like objects that optionally have an
# `encoding` attribute.
def guess_decode_from_terminal(text: bytes, term: Any) -> tuple[bytes, str]: ...
def terminal_encoding(term: Any) -> str: ...

class UnclosingTextIOWrapper(TextIOWrapper):
    def close(self) -> None: ...
