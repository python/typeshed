from _typeshed import Incomplete
from collections.abc import Callable, Iterable, Mapping, Sequence
from re import Match, Pattern
from types import ModuleType
from typing import Any, Literal, TypeVar
from typing_extensions import TypeAlias

from docutils import ApplicationError, DataError, nodes
from docutils.parsers.rst import Directive
from docutils.parsers.rst.tableparser import TableParser
from docutils.statemachine import StateMachine, StateMachineWS, StateWS, StringList
from docutils.utils import Reporter

_Context = TypeVar("_Context")
_TransitionResult: TypeAlias = tuple[_Context, str | None, list[str]]

class MarkupError(DataError): ...
class UnknownInterpretedRoleError(DataError): ...
class InterpretedRoleNotImplementedError(DataError): ...
class ParserError(ApplicationError): ...
class MarkupMismatch(Exception): ...

class Struct:
    def __init__(self, **keywordargs) -> None: ...

class RSTStateMachine(StateMachineWS[Incomplete]):
    def run(
        self,
        input_lines: Sequence[str] | StringList,
        document: nodes.document,
        input_offset: int = 0,
        match_titles: bool = True,
        inliner: Inliner | None = None,
    ) -> None: ...

class NestedStateMachine(StateMachineWS[Incomplete]):
    def run(
        self, input_lines: Sequence[str] | StringList, input_offset: int, memo, node: nodes.Node, match_titles: bool = True
    ) -> list[str]: ...

class RSTState(StateWS[list[str]]):
    nested_sm: type[NestedStateMachine]
    nested_sm_cache: list[StateMachine[Incomplete]]
    def __init__(self, state_machine, debug: bool = False) -> None: ...
    memo: Incomplete
    reporter: Reporter
    inliner: Inliner
    document: nodes.document
    parent: Incomplete
    def runtime_init(self) -> None: ...
    def goto_line(self, abs_line_offset: int) -> None: ...
    def no_match(self, context: list[str], transitions): ...
    def bof(self, context: list[str]): ...
    def nested_parse(
        self,
        block,
        input_offset: int,
        node,
        match_titles: bool = False,
        state_machine_class: type[StateMachine[list[str]]] | None = None,
        state_machine_kwargs=None,
    ): ...
    def nested_list_parse(
        self,
        block,
        input_offset: int,
        node,
        initial_state,
        blank_finish,
        blank_finish_state=None,
        extra_settings={},
        match_titles: bool = False,
        state_machine_class=None,
        state_machine_kwargs=None,
    ): ...
    def section(self, title: str, source, style, lineno: int, messages) -> None: ...
    def check_subsection(self, source, style, lineno: int): ...
    def title_inconsistent(self, sourcetext: str, lineno: int): ...
    def new_subsection(self, title: str, lineno: int, messages) -> None: ...
    def paragraph(self, lines: Iterable[str], lineno: int): ...
    def inline_text(self, text: str, lineno: int): ...
    def unindent_warning(self, node_name: str): ...

def build_regexp(definition: _BasicDefinition, compile: bool = True): ...

_BasicDefinition: TypeAlias = tuple[str, str, str, list[Pattern[str]]]
_DefinitionParts: TypeAlias = tuple[str, str, str, list[Pattern[str] | _BasicDefinition]]
_DefinitionType: TypeAlias = tuple[str, str, str, list[Pattern[str] | _DefinitionParts]]

class Inliner:
    implicit_dispatch: list[tuple[Pattern[str], Callable[[Match[str], int], Sequence[nodes.Node]]]]
    def __init__(self) -> None: ...
    start_string_prefix: str
    end_string_suffix: str
    parts: _DefinitionType
    patterns: Struct
    def init_customizations(self, settings: Any) -> None: ...
    reporter: Reporter
    document: nodes.document
    language: ModuleType
    parent: nodes.Element
    def parse(
        self, text: str, lineno: int, memo: Struct, parent: nodes.Element
    ) -> tuple[list[nodes.Node], list[nodes.system_message]]: ...
    non_whitespace_before: str
    non_whitespace_escape_before: str
    non_unescaped_whitespace_escape_before: str
    non_whitespace_after: str
    simplename: str
    uric: str
    uri_end_delim: str
    urilast: str
    uri_end: str
    emailc: str
    email_pattern: str
    def quoted_start(self, match: Match[str]) -> bool: ...
    def inline_obj(
        self,
        match: Match[str],
        lineno: int,
        end_pattern: Pattern[str],
        nodeclass: nodes.TextElement,
        restore_backslashes: bool = False,
    ) -> tuple[str, list[nodes.problematic], str, list[nodes.system_message], str]: ...
    def problematic(self, text: str, rawsource: str, message: nodes.system_message) -> nodes.problematic: ...
    def emphasis(
        self, match: Match[str], lineno: int
    ) -> tuple[str, list[nodes.problematic], str, list[nodes.system_message]]: ...
    def strong(self, match: Match[str], lineno: int) -> tuple[str, list[nodes.problematic], str, list[nodes.system_message]]: ...
    def interpreted_or_phrase_ref(
        self, match: Match[str], lineno: int
    ) -> tuple[str, list[nodes.problematic], str, list[nodes.system_message]]: ...
    def phrase_ref(
        self, before: str, after: str, rawsource: str, escaped: str, text: str | None = None
    ) -> tuple[str, list[nodes.Node], str, list[nodes.Node]]: ...
    def adjust_uri(self, uri: str) -> str: ...
    def interpreted(
        self, rawsource: str, text: str, role: str, lineno: int
    ) -> tuple[list[nodes.Node], list[nodes.system_message]]: ...
    def literal(self, match: Match[str], lineno: int) -> tuple[str, list[nodes.problematic], str, list[nodes.system_message]]: ...
    def inline_internal_target(
        self, match: Match[str], lineno: int
    ) -> tuple[str, list[nodes.problematic], str, list[nodes.system_message]]: ...
    def substitution_reference(
        self, match: Match[str], lineno: int
    ) -> tuple[str, list[nodes.problematic], str, list[nodes.system_message]]: ...
    def footnote_reference(
        self, match: Match[str], lineno: int
    ) -> tuple[str, list[nodes.problematic], str, list[nodes.system_message]]: ...
    def reference(
        self, match: Match[str], lineno: int, anonymous: bool = False
    ) -> tuple[str, list[nodes.problematic], str, list[nodes.system_message]]: ...
    def anonymous_reference(
        self, match: Match[str], lineno: int
    ) -> tuple[str, list[nodes.problematic], str, list[nodes.system_message]]: ...
    def standalone_uri(
        self, match: Match[str], lineno: int
    ) -> list[tuple[str, list[nodes.problematic], str, list[nodes.system_message]]]: ...
    def pep_reference(
        self, match: Match[str], lineno: int
    ) -> list[tuple[str, list[nodes.problematic], str, list[nodes.system_message]]]: ...
    rfc_url: str = ...
    def rfc_reference(
        self, match: Match[str], lineno: int
    ) -> list[tuple[str, list[nodes.problematic], str, list[nodes.system_message]]]: ...
    def implicit_inline(self, text: str, lineno: int) -> list[nodes.Text]: ...
    dispatch: dict[str, Callable[[Match[str], int], tuple[str, list[nodes.problematic], str, list[nodes.system_message]]]] = ...

class Body(RSTState):
    double_width_pad_char: TableParser
    enum: Struct
    grid_table_top_pat: Pattern[str]
    simple_table_top_pat: Pattern[str]
    pats: dict[str, str]
    patterns: dict[str, str | Pattern[str]]
    initial_transitions: tuple[str, ...]
    attribution_pattern: Pattern[str]
    explicit = Struct()

    def indent(self, match: Match[str], context: _Context, next_state: str) -> _TransitionResult[_Context]: ...
    def block_quote(self, indented: StringList, line_offset: int) -> list[nodes.block_quote | nodes.system_message]: ...
    def split_attribution(
        self, indented: StringList, line_offset: int
    ) -> tuple[StringList, None, None, None, None] | tuple[StringList, StringList, int, StringList, int]: ...
    def check_attribution(self, indented: StringList, attribution_start: int) -> tuple[None, None]: ...
    def parse_attribution(self, indented: StringList, line_offset: int) -> tuple[nodes.attribution, nodes.system_message]: ...
    def bullet(self, match: Match[str], context: _Context, next_state: str) -> _TransitionResult[_Context]: ...
    def list_item(self, indent: int) -> tuple[nodes.list_item, bool]: ...
    def enumerator(self, match: Match[str], context: _Context, next_state: str) -> _TransitionResult[_Context]: ...
    def parse_enumerator(
        self, match: Match[str], expected_sequence: str | None = None
    ) -> tuple[Literal["period", "parens", "rparen"], str, str, int | None]: ...
    def is_enumerated_list_item(self, ordinal: int | None, sequence: str, format) -> bool: ...
    def make_enumerator(self, ordinal: int, sequence: str, format) -> tuple[str, str] | None: ...
    def field_marker(self, match: Match[str], context: _Context, next_state: str) -> _TransitionResult[_Context]: ...
    def field(self, match: Match[str]) -> tuple[nodes.field, bool]: ...
    def parse_field_marker(self, match: Match[str]) -> str: ...
    def parse_field_body(self, indented, offset, node) -> None: ...
    def option_marker(self, match: Match[str], context, next_state): ...
    def option_list_item(self, match: Match[str]) -> tuple[nodes.option_list_item, bool]: ...
    def parse_option_marker(self, match: Match[str]) -> list[nodes.option]: ...
    def doctest(self, match: Match[str], context: _Context, next_state: str) -> _TransitionResult[_Context]: ...
    def line_block(self, match: Match[str], context: _Context, next_state: str) -> _TransitionResult[_Context]: ...
    def line_block_line(self, match: Match[str], lineno: int) -> tuple[nodes.line, nodes.system_message, bool]: ...
    def nest_line_block_lines(self, block: nodes.line_block) -> None: ...
    def nest_line_block_segment(self, block: nodes.line_block) -> None: ...
    def grid_table_top(self, match: Match[str], context: _Context, next_state: str) -> _TransitionResult[_Context]: ...
    def simple_table_top(self, match: Match[str], context: _Context, next_state: str) -> _TransitionResult[_Context]: ...
    def table_top(
        self, match: Match[str], context, next_state: str, isolate_function, parser_class
    ) -> tuple[list[Incomplete], str, list[Incomplete]]: ...
    def table(self, isolate_function, parser_class) -> tuple[list[Incomplete], bool]: ...
    def isolate_grid_table(self) -> tuple[StringList | list[Incomplete], list[Incomplete], Literal[1, 0]]: ...
    def isolate_simple_table(self) -> tuple[StringList | list[Incomplete], list[Incomplete], bool]: ...
    def malformed_table(self, block, detail: str = "", offset: int = 0) -> list[Incomplete]: ...
    def build_table(
        self, tabledata: tuple[Incomplete, Incomplete, Incomplete], tableline, stub_columns: int = 0, widths=None
    ) -> nodes.table: ...
    def build_table_row(self, rowdata, tableline) -> nodes.row: ...
    def footnote(self, match: Match[str]) -> tuple[list[nodes.footnote], bool]: ...
    def citation(self, match: Match[str]) -> tuple[list[nodes.citation], bool]: ...
    def hyperlink_target(self, match: Match[str]) -> tuple[list[nodes.target], bool]: ...
    def make_target(self, block: StringList, block_text, lineno: int, target_name: str | None) -> nodes.target | str: ...
    def parse_target(
        self, block: StringList, block_text, lineno: int
    ) -> tuple[Literal["refname"], str] | tuple[Literal["refuri"], str]: ...
    def is_reference(self, reference: str) -> str | None: ...
    def add_target(self, targetname: str | None, refuri: str, target: nodes.Element, lineno: int) -> None: ...
    def substitution_def(self, match: Match[str]) -> tuple[list[Incomplete], bool]: ...
    def disallowed_inside_substitution_definitions(self, node: nodes.Node) -> bool: ...
    def directive(self, match: Match[str], **option_presets) -> tuple[list[nodes.Node], bool]: ...
    def run_directive(self, directive: Directive, match: Match[str], type_name: str, option_presets: dict[str, Any]): ...
    def parse_directive_block(
        self, indented: list[str], line_offset: int, directive: Directive, option_presets: dict[str, Any]
    ): ...
    def parse_directive_options(self, option_presets, option_spec: Mapping[str, Incomplete], arg_block): ...
    def parse_directive_arguments(self, directive: Directive, arg_block): ...
    def parse_extension_options(
        self, option_spec: Mapping[str, Incomplete], datalines: Sequence[str]
    ) -> tuple[Literal[0], str] | tuple[Literal[1], dict[str, Any]]: ...
    def unknown_directive(self, type_name: str) -> tuple[list[Incomplete], bool]: ...
    def comment(self, match: Match[str]) -> tuple[list[nodes.comment], bool]: ...
    def explicit_markup(self, match: Match[str], context, next_state: str) -> tuple[list[Incomplete], str, list[Incomplete]]: ...
    def explicit_construct(self, match: Match[str]) -> tuple[list[Incomplete], bool]: ...
    def explicit_list(self, blank_finish) -> None: ...
    def anonymous(self, match: Match[str], context, next_state: str) -> tuple[list[Incomplete], str, list[Any]]: ...
    def anonymous_target(self, match: Match[str]) -> tuple[list[nodes.target], bool]: ...
    def line(self, match: Match[str], context, next_state: str) -> tuple[list[Incomplete], str, list[Any]]: ...
    def text(self, match: Match[str], context, next_state: str) -> tuple[list[str], Literal["Text"], list[Any]]: ...

class RFC2822Body(Body): ...
class SpecializedBody(Body): ...
class BulletList(SpecializedBody): ...
class DefinitionList(SpecializedBody): ...
class EnumeratedList(SpecializedBody): ...
class FieldList(SpecializedBody): ...
class OptionList(SpecializedBody): ...
class RFC2822List(SpecializedBody, RFC2822Body): ...
class ExtensionOptions(FieldList): ...
class LineBlock(SpecializedBody): ...
class Explicit(SpecializedBody): ...
class SubstitutionDef(Body): ...
class Text(RSTState): ...
class SpecializedText(Text): ...
class Definition(SpecializedText): ...
class Line(SpecializedText): ...
class QuotedLiteralBlock(RSTState): ...

state_classes: tuple[
    Body,
    BulletList,
    DefinitionList,
    EnumeratedList,
    FieldList,
    OptionList,
    LineBlock,
    ExtensionOptions,
    Explicit,
    Text,
    Definition,
    Line,
    SubstitutionDef,
    RFC2822Body,
    RFC2822List,
]
