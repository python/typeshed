from _typeshed import Incomplete, Unused
from collections.abc import Callable, Iterable, Mapping, Sequence
from re import Match, Pattern
from types import ModuleType
from typing import Any, ClassVar, Final, Literal, TypeVar, overload
from typing_extensions import Never, TypeAlias

from docutils import ApplicationError, DataError, nodes
from docutils.parsers.rst import Directive
from docutils.parsers.rst.languages import _RstLanguageModule
from docutils.parsers.rst.tableparser import TableParser
from docutils.statemachine import StateMachine, StateMachineWS, StateWS, StringList
from docutils.utils import Reporter

__docformat__: Final = "reStructuredText"

_Context = TypeVar("_Context")
_NextState = TypeVar("_NextState", str, None)
_EmptyContext = TypeVar("_EmptyContext", Literal[""], None)
_TransitionResult: TypeAlias = tuple[_Context, str | None, list[str]]

EmptyList = list[object]

class MarkupError(DataError): ...
class UnknownInterpretedRoleError(DataError): ...
class InterpretedRoleNotImplementedError(DataError): ...
class ParserError(ApplicationError): ...
class MarkupMismatch(Exception): ...

class Struct:
    def __init__(self, **keywordargs) -> None: ...

class RSTStateMachine(StateMachineWS[list[str]]):
    language: _RstLanguageModule
    match_titles: bool
    memo: Struct | None
    document: nodes.document
    reporter: Reporter
    node: nodes.document | None
    def run(  # type: ignore[override]
        self,
        input_lines: Sequence[str] | StringList,
        document: nodes.document,
        input_offset: int = 0,
        match_titles: bool = True,
        inliner: Inliner | None = None,
    ) -> None: ...

class NestedStateMachine(StateMachineWS[list[str]]):
    match_titles: bool
    memo: Incomplete
    document: nodes.document
    reporter: Reporter
    language: Incomplete
    node: Incomplete
    def run(  # type: ignore[override]
        self, input_lines: Sequence[str] | StringList, input_offset: int, memo, node: nodes.Node, match_titles: bool = True
    ) -> list[str]: ...

class RSTState(StateWS[list[str]]):
    nested_sm: ClassVar[type[NestedStateMachine]]  # type: ignore[misc]
    nested_sm_cache: ClassVar[list[StateMachine[Incomplete]]]
    nested_sm_kwargs: dict[str, Any]
    def __init__(self, state_machine, debug: bool = False) -> None: ...
    memo: Incomplete
    reporter: Reporter
    inliner: Inliner
    document: nodes.document
    parent: Incomplete
    def runtime_init(self) -> None: ...
    def goto_line(self, abs_line_offset: int) -> None: ...
    def no_match(self, context: list[str], transitions): ...
    def bof(self, context: list[str]): ...
    def nested_parse(
        self,
        block,
        input_offset: int,
        node,
        match_titles: bool = False,
        state_machine_class: type[StateMachine[list[str]]] | None = None,
        state_machine_kwargs=None,
    ): ...
    def nested_list_parse(
        self,
        block,
        input_offset: int,
        node,
        initial_state,
        blank_finish,
        blank_finish_state=None,
        extra_settings={},
        match_titles: bool = False,
        state_machine_class=None,
        state_machine_kwargs=None,
    ): ...
    def section(self, title: str, source, style, lineno: int, messages) -> None: ...
    def check_subsection(self, source, style, lineno: int): ...
    def title_inconsistent(self, sourcetext: str, lineno: int): ...
    def new_subsection(self, title: str, lineno: int, messages) -> None: ...
    def paragraph(self, lines: Iterable[str], lineno: int): ...
    def inline_text(self, text: str, lineno: int): ...
    def unindent_warning(self, node_name: str): ...

def build_regexp(definition: _BasicDefinition, compile: bool = True): ...

_BasicDefinition: TypeAlias = tuple[str, str, str, list[Pattern[str]]]
_DefinitionParts: TypeAlias = tuple[str, str, str, list[Pattern[str] | _BasicDefinition]]
_DefinitionType: TypeAlias = tuple[str, str, str, list[Pattern[str] | _DefinitionParts]]

class Inliner:
    implicit_dispatch: list[tuple[Pattern[str], Callable[[Match[str], int], Sequence[nodes.Node]]]]
    def __init__(self) -> None: ...
    start_string_prefix: str
    end_string_suffix: str
    parts: _DefinitionType
    patterns: Struct
    def init_customizations(self, settings: Any) -> None: ...
    reporter: Reporter
    document: nodes.document
    language: ModuleType
    parent: nodes.Element
    def parse(
        self, text: str, lineno: int, memo: Struct, parent: nodes.Element
    ) -> tuple[list[nodes.Node], list[nodes.system_message]]: ...
    non_whitespace_before: str
    non_whitespace_escape_before: str
    non_unescaped_whitespace_escape_before: str
    non_whitespace_after: str
    simplename: str
    uric: str
    uri_end_delim: str
    urilast: str
    uri_end: str
    emailc: str
    email_pattern: str
    def quoted_start(self, match: Match[str]) -> bool: ...
    def inline_obj(
        self,
        match: Match[str],
        lineno: int,
        end_pattern: Pattern[str],
        nodeclass: nodes.TextElement,
        restore_backslashes: bool = False,
    ) -> tuple[str, list[nodes.problematic], str, list[nodes.system_message], str]: ...
    def problematic(self, text: str, rawsource: str, message: nodes.system_message) -> nodes.problematic: ...
    def emphasis(
        self, match: Match[str], lineno: int
    ) -> tuple[str, list[nodes.problematic], str, list[nodes.system_message]]: ...
    def strong(self, match: Match[str], lineno: int) -> tuple[str, list[nodes.problematic], str, list[nodes.system_message]]: ...
    def interpreted_or_phrase_ref(
        self, match: Match[str], lineno: int
    ) -> tuple[str, list[nodes.problematic], str, list[nodes.system_message]]: ...
    def phrase_ref(
        self, before: str, after: str, rawsource: str, escaped: str, text: str | None = None
    ) -> tuple[str, list[nodes.Node], str, list[nodes.Node]]: ...
    def adjust_uri(self, uri: str) -> str: ...
    def interpreted(
        self, rawsource: str, text: str, role: str, lineno: int
    ) -> tuple[list[nodes.Node], list[nodes.system_message]]: ...
    def literal(self, match: Match[str], lineno: int) -> tuple[str, list[nodes.problematic], str, list[nodes.system_message]]: ...
    def inline_internal_target(
        self, match: Match[str], lineno: int
    ) -> tuple[str, list[nodes.problematic], str, list[nodes.system_message]]: ...
    def substitution_reference(
        self, match: Match[str], lineno: int
    ) -> tuple[str, list[nodes.problematic], str, list[nodes.system_message]]: ...
    def footnote_reference(
        self, match: Match[str], lineno: int
    ) -> tuple[str, list[nodes.problematic], str, list[nodes.system_message]]: ...
    def reference(
        self, match: Match[str], lineno: int, anonymous: bool = False
    ) -> tuple[str, list[nodes.problematic], str, list[nodes.system_message]]: ...
    def anonymous_reference(
        self, match: Match[str], lineno: int
    ) -> tuple[str, list[nodes.problematic], str, list[nodes.system_message]]: ...
    def standalone_uri(
        self, match: Match[str], lineno: int
    ) -> list[tuple[str, list[nodes.problematic], str, list[nodes.system_message]]]: ...
    def pep_reference(
        self, match: Match[str], lineno: int
    ) -> list[tuple[str, list[nodes.problematic], str, list[nodes.system_message]]]: ...
    rfc_url: str = ...
    def rfc_reference(
        self, match: Match[str], lineno: int
    ) -> list[tuple[str, list[nodes.problematic], str, list[nodes.system_message]]]: ...
    def implicit_inline(self, text: str, lineno: int) -> list[nodes.Text]: ...
    dispatch: dict[str, Callable[[Match[str], int], tuple[str, list[nodes.problematic], str, list[nodes.system_message]]]] = ...

class Body(RSTState):
    double_width_pad_char: TableParser
    enum: Struct
    grid_table_top_pat: Pattern[str]
    simple_table_top_pat: Pattern[str]
    simple_table_border_pat: Pattern[str]
    pats: dict[str, str]
    patterns: ClassVar[dict[str, str | Pattern[str]]]
    initial_transitions: ClassVar[tuple[str, ...]]
    def indent(self, match: Unused, context: _Context, next_state: str) -> _TransitionResult[_Context]: ...
    def block_quote(self, indented: StringList, line_offset: int) -> list[nodes.block_quote | nodes.system_message]: ...
    attribution_pattern: Pattern[str]
    def split_attribution(
        self, indented: StringList, line_offset: int
    ) -> tuple[StringList, None, None, None, None] | tuple[StringList, StringList, int, StringList, int]: ...
    def check_attribution(self, indented: StringList, attribution_start: int) -> tuple[None, None]: ...
    def parse_attribution(self, indented: StringList, line_offset: int) -> tuple[nodes.attribution, nodes.system_message]: ...
    def bullet(self, match: Match[str], context: Unused, next_state: _NextState) -> tuple[EmptyList, _NextState, EmptyList]: ...
    def list_item(self, indent: int) -> tuple[nodes.list_item, bool]: ...
    def enumerator(self, match: Match[str], context: Unused, next_state: str): ...
    def parse_enumerator(
        self, match: Match[str], expected_sequence: str | None = None
    ) -> tuple[Literal["period", "parens", "rparen"], str, str, int | None]: ...
    def is_enumerated_list_item(self, ordinal: int | None, sequence: str, format) -> bool: ...
    def make_enumerator(self, ordinal: int, sequence: str, format) -> tuple[str, str] | None: ...
    def field_marker(self, match: Match[str], context: _Context, next_state: str) -> _TransitionResult[_Context]: ...
    def field(self, match: Match[str]) -> tuple[nodes.field, bool]: ...
    def parse_field_marker(self, match: Match[str]) -> str: ...
    def parse_field_body(self, indented, offset, node) -> None: ...
    def option_marker(self, match: Match[str], context, next_state): ...
    def option_list_item(self, match: Match[str]) -> tuple[nodes.option_list_item, bool]: ...
    def parse_option_marker(self, match: Match[str]) -> list[nodes.option]: ...
    def doctest(self, match: Match[str], context: _Context, next_state: str) -> _TransitionResult[_Context]: ...
    def line_block(self, match: Match[str], context: _Context, next_state: str) -> _TransitionResult[_Context]: ...
    def line_block_line(self, match: Match[str], lineno: int) -> tuple[nodes.line, nodes.system_message, bool]: ...
    def nest_line_block_lines(self, block: nodes.line_block) -> None: ...
    def nest_line_block_segment(self, block: nodes.line_block) -> None: ...
    def grid_table_top(self, match: Match[str], context: _Context, next_state: str) -> _TransitionResult[_Context]: ...
    def simple_table_top(self, match: Match[str], context: _Context, next_state: str) -> _TransitionResult[_Context]: ...
    def table_top(
        self, match: Match[str], context, next_state: str, isolate_function, parser_class
    ) -> tuple[list[Incomplete], str, list[Incomplete]]: ...
    def table(self, isolate_function, parser_class) -> tuple[list[Incomplete], bool]: ...
    def isolate_grid_table(self) -> tuple[StringList | list[Incomplete], list[Incomplete], Literal[1, 0]]: ...
    def isolate_simple_table(self) -> tuple[StringList | list[Incomplete], list[Incomplete], bool]: ...
    def malformed_table(self, block, detail: str = "", offset: int = 0) -> list[Incomplete]: ...
    def build_table(
        self, tabledata: tuple[Incomplete, Incomplete, Incomplete], tableline, stub_columns: int = 0, widths=None
    ) -> nodes.table: ...
    def build_table_row(self, rowdata, tableline) -> nodes.row: ...
    explicit: Struct
    def footnote(self, match: Match[str]) -> tuple[list[nodes.footnote], bool]: ...
    def citation(self, match: Match[str]) -> tuple[list[nodes.citation], bool]: ...
    def hyperlink_target(self, match: Match[str]) -> tuple[list[nodes.target], bool]: ...
    def make_target(self, block: StringList, block_text, lineno: int, target_name: str | None) -> nodes.target | str: ...
    def parse_target(
        self, block: StringList, block_text, lineno: int
    ) -> tuple[Literal["refname"], str] | tuple[Literal["refuri"], str]: ...
    def is_reference(self, reference: str) -> str | None: ...
    def add_target(self, targetname: str | None, refuri: str, target: nodes.Element, lineno: int) -> None: ...
    def substitution_def(self, match: Match[str]) -> tuple[list[Incomplete], bool]: ...
    def disallowed_inside_substitution_definitions(self, node: nodes.Node) -> bool: ...
    def directive(self, match: Match[str], **option_presets) -> tuple[list[nodes.Node], bool]: ...
    def run_directive(self, directive: Directive, match: Match[str], type_name: str, option_presets: dict[str, Any]): ...
    def parse_directive_block(
        self, indented: list[str], line_offset: int, directive: Directive, option_presets: dict[str, Any]
    ): ...
    def parse_directive_options(self, option_presets, option_spec: Mapping[str, Incomplete], arg_block): ...
    def parse_directive_arguments(self, directive: Directive, arg_block): ...
    def parse_extension_options(
        self, option_spec: Mapping[str, Incomplete], datalines: Sequence[str]
    ) -> tuple[Literal[0], str] | tuple[Literal[1], dict[str, Any]]: ...
    def unknown_directive(self, type_name: str) -> tuple[list[Incomplete], bool]: ...
    def comment(self, match: Match[str]) -> tuple[list[nodes.comment], bool]: ...
    def explicit_markup(self, match: Match[str], context, next_state: str) -> tuple[list[Incomplete], str, list[Incomplete]]: ...
    def explicit_construct(self, match: Match[str]) -> tuple[list[Incomplete], bool]: ...
    def explicit_list(self, blank_finish) -> None: ...
    def anonymous(self, match: Match[str], context, next_state: str) -> tuple[list[Incomplete], str, EmptyList]: ...
    def anonymous_target(self, match: Match[str]) -> tuple[list[nodes.target], bool]: ...
    def line(self, match: Match[str], context, next_state: str) -> tuple[list[Incomplete], str, EmptyList]: ...
    def text(self, match: Match[str], context, next_state: str) -> tuple[list[str], Literal["Text"], EmptyList]: ...

class RFC2822Body(Body):
    patterns: ClassVar[dict[str, str | Pattern[str]]]
    initial_transitions: ClassVar[list[tuple[str | tuple[str, str], str]]]  # type: ignore[assignment]
    def rfc2822(self, match: Match[str], context: Unused, next_state: _NextState) -> tuple[EmptyList, _NextState, list[str]]: ...
    def rfc2822_field(self, match: Match[str]): ...

class SpecializedBody(Body):
    def invalid_input(self, match: Unused = None, context: Unused = None, next_state: Unused = None) -> Never: ...
    indent = invalid_input
    bullet = invalid_input
    enumerator = invalid_input
    field_marker = invalid_input
    option_marker = invalid_input
    doctest = invalid_input
    line_block = invalid_input
    grid_table_top = invalid_input
    simple_table_top = invalid_input
    explicit_markup = invalid_input
    anonymous = invalid_input
    line = invalid_input
    text = invalid_input

class BulletList(SpecializedBody):
    def bullet(self, match: Match[str], context: Unused, next_state: _NextState) -> tuple[EmptyList, _NextState, EmptyList]: ...  # type: ignore[override]

class DefinitionList(SpecializedBody):
    def text(
        self, match: Match[str], context: Unused, next_state: Unused
    ) -> tuple[list[str], Literal["Definition"], EmptyList]: ...  # type: ignore[override]

class EnumeratedList(SpecializedBody):
    auto: int
    blank_finish: Incomplete
    lastordinal: Incomplete
    def enumerator(
        self, match: Match[str], context: Unused, next_state: _NextState
    ) -> tuple[EmptyList, _NextState, EmptyList]: ...  # type: ignore[override]

class FieldList(SpecializedBody):
    blank_finish: Incomplete
    def field_marker(  # type: ignore[override]
        self, match: Match[str], context: Unused, next_state: _NextState
    ) -> tuple[EmptyList, _NextState, EmptyList]: ...

class OptionList(SpecializedBody):
    blank_finish: Incomplete
    def option_marker(  # type: ignore[override]
        self, match: Match[str], context: Unused, next_state: _NextState
    ) -> tuple[EmptyList, _NextState, EmptyList]: ...

class RFC2822List(SpecializedBody, RFC2822Body):
    patterns: ClassVar[dict[str, str | Pattern[str]]]
    initial_transitions: ClassVar[list[tuple[str | tuple[str, str], str]]]
    blank_finish: Incomplete
    def rfc2822(  # type: ignore[override]
        self, match: Match[str], context: Unused, next_state: Unused
    ) -> tuple[EmptyList, Literal["RFC2822List"], EmptyList]: ...
    def blank(self, match: Unused = None, context: Unused = None, next_state: Unused = None) -> Never: ...

class ExtensionOptions(FieldList):
    def parse_field_body(self, indented: StringList, offset, node: nodes.Node) -> None: ...

class LineBlock(SpecializedBody):
    blank_finish: Incomplete
    def blank(self, match: Unused = None, context: Unused = None, next_state: Unused = None) -> Never: ...
    def line_block(
        self, match: Match[str], context: Unused, next_state: _NextState
    ) -> tuple[EmptyList, _NextState, EmptyList]: ...  # type: ignore[override]

class Explicit(SpecializedBody):
    blank_finish: Incomplete
    def explicit_markup(  # type: ignore[override]
        self, match: Match[str], context: Unused, next_state: _NextState
    ) -> tuple[EmptyList, _NextState, EmptyList]: ...
    def anonymous(
        self, match: Match[str], context: Unused, next_state: _NextState
    ) -> tuple[EmptyList, _NextState, EmptyList]: ...  # type: ignore[override]
    def blank(self, match: Unused = None, context: Unused = None, next_state: Unused = None) -> Never: ...

class SubstitutionDef(Body):
    patterns: ClassVar[dict[str, str | Pattern[str]]]
    initial_transitions: ClassVar[list[str]]  # type: ignore[assignment]
    blank_finish: Incomplete
    def embedded_directive(self, match: Match[str], context: Unused, next_state: Unused) -> Never: ...
    def text(self, match: Unused, context: Unused, next_state: Unused) -> Never: ...

class Text(RSTState):
    patterns: ClassVar[dict[str, str | Pattern[str]]]
    initial_transitions: ClassVar[list[tuple[str, str]]]
    def blank(self, match: Unused, context, next_state: Unused) -> tuple[EmptyList, Literal["Body"], EmptyList]: ...
    def eof(self, context): ...
    def indent(self, match: Unused, context, next_state: Unused) -> tuple[EmptyList, Literal["Body"], EmptyList]: ...
    def underline(
        self, match: Match[str], context: Sequence[str], next_state: _NextState
    ) -> tuple[EmptyList, _NextState, EmptyList]: ...
    def text(self, match: Unused, context, next_state: _NextState) -> tuple[EmptyList, _NextState, EmptyList]: ...
    def literal_block(self) -> list[nodes.Node]: ...
    def quoted_literal_block(self) -> list[nodes.Node]: ...
    def definition_list_item(self, termline: StringList) -> tuple[nodes.definition_list_item, bool]: ...
    classifier_delimiter: Pattern[str]
    def term(self, lines: StringList, lineno: int) -> tuple[nodes.Node, nodes.system_message]: ...

class SpecializedText(Text):
    def eof(self, context: Unused): ...
    def invalid_input(self, match: Unused = None, context: Unused = None, next_state: Unused = None) -> Never: ...
    blank = invalid_input
    indent = invalid_input
    underline = invalid_input
    text = invalid_input

class Definition(SpecializedText):
    def eof(self, context: Unused) -> EmptyList: ...
    def indent(  # type: ignore[override]
        self, match: Unused, context: list[str], next_state: Unused
    ) -> tuple[list[str], Literal["DefinitionList"], list[str]]: ...

class Line(SpecializedText):
    eofcheck: Literal[1]
    def eof(self, context: Any) -> EmptyList: ...
    def blank(self, match: Unused, context: Any, next_state: Unused) -> tuple[EmptyList, Literal["Body"], EmptyList]: ...  # type: ignore[override]
    def text(self, match: Match[str], context: list[str], next_state: Unused) -> tuple[EmptyList, Literal["Body"], EmptyList]: ...  # type: ignore[override]
    def indent(
        self, match: Match[str], context: list[str], next_state: Unused
    ) -> tuple[EmptyList, Literal["Body"], EmptyList]: ...  # type: ignore[override]
    def underline(
        self, match: Unused, context: list[str], next_state: Unused
    ) -> tuple[EmptyList, Literal["Body"], EmptyList]: ...  # type: ignore[override]
    def short_overline(self, context, blocktext: Unused, lineno: int | None, lines: int = 1) -> None: ...
    def state_correction(self, context, lines: int = 1) -> Never: ...

class QuotedLiteralBlock(RSTState):
    patterns: ClassVar[dict[str, str | Pattern[str]]]
    messages: list[Incomplete]
    initial_lineno: int | None
    def __init__(self, state_machine: StateMachine[Incomplete], debug: bool = False) -> None: ...
    @overload
    def blank(
        self, match: Unused, context: _EmptyContext, next_state: _NextState
    ) -> tuple[_EmptyContext, _NextState, EmptyList]: ...
    @overload
    def blank(self, match: Unused, context: Any, next_state: _NextState) -> Never: ...
    def eof(self, context: list[str]): ...
    def indent(self, match: Unused, context: list[str], next_state: Unused) -> Never: ...
    def initial_quoted(
        self, match: Match[str], context: Unused, next_state: _NextState
    ) -> tuple[list[str], _NextState, EmptyList]: ...
    def quoted(self, match: Match[str], context: _Context, next_state: _NextState) -> tuple[_Context, _NextState, EmptyList]: ...
    def text(self, match: Unused, context: Any, next_state: Unused) -> Never: ...

state_classes: tuple[type[RSTState], ...]
