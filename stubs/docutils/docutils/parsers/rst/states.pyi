from _typeshed import Incomplete
from collections.abc import Callable, Iterable, Mapping, Sequence
from re import Match, Pattern
from types import ModuleType
from typing import Any, ClassVar, Final, Literal, TypeVar, overload
from typing_extensions import Never, TypeAlias

from docutils import ApplicationError, DataError, nodes
from docutils.parsers.rst import Directive
from docutils.parsers.rst.languages import _RstLanguageModule
from docutils.parsers.rst.tableparser import TableParser
from docutils.statemachine import StateMachine, StateMachineWS, StateWS, StringList
from docutils.utils import Reporter

__docformat__: Final = "reStructuredText"

_Context = TypeVar("_Context")
_NextState = TypeVar("_NextState", str, None)
_EmptyContext = TypeVar("_EmptyContext", Literal[""], None)
_TransitionResult: TypeAlias = tuple[_Context, str | None, list[str]]

class MarkupError(DataError): ...
class UnknownInterpretedRoleError(DataError): ...
class InterpretedRoleNotImplementedError(DataError): ...
class ParserError(ApplicationError): ...
class MarkupMismatch(Exception): ...

class Struct:
    def __init__(self, **keywordargs) -> None: ...

class RSTStateMachine(StateMachineWS[list[str]]):
    language: _RstLanguageModule
    match_titles: bool
    memo: Struct | None
    document: nodes.document
    reporter: Reporter
    node: nodes.document | None
    def run(  # type: ignore[override]
        self,
        input_lines: Sequence[str] | StringList,
        document: nodes.document,
        input_offset: int = 0,
        match_titles: bool = True,
        inliner: Inliner | None = None,
    ) -> None: ...

class NestedStateMachine(StateMachineWS[list[str]]):
    match_titles: bool
    memo: Incomplete
    document: nodes.document
    reporter: Reporter
    language: Incomplete
    node: Incomplete
    def run(  # type: ignore[override]
        self, input_lines: Sequence[str] | StringList, input_offset: int, memo, node: nodes.Node, match_titles: bool = True
    ) -> list[str]: ...

class RSTState(StateWS[list[str]]):
    nested_sm: ClassVar[type[NestedStateMachine]]  # type: ignore[misc]
    nested_sm_cache: ClassVar[list[StateMachine[Incomplete]]]
    nested_sm_kwargs: dict[str, Any]
    def __init__(self, state_machine, debug: bool = False) -> None: ...
    memo: Incomplete
    reporter: Reporter
    inliner: Inliner
    document: nodes.document
    parent: Incomplete
    def runtime_init(self) -> None: ...
    def goto_line(self, abs_line_offset: int) -> None: ...
    def no_match(self, context: list[str], transitions): ...
    def bof(self, context: list[str]): ...
    def nested_parse(
        self,
        block,
        input_offset: int,
        node,
        match_titles: bool = False,
        state_machine_class: type[StateMachine[list[str]]] | None = None,
        state_machine_kwargs=None,
    ): ...
    def nested_list_parse(
        self,
        block,
        input_offset: int,
        node,
        initial_state,
        blank_finish,
        blank_finish_state=None,
        extra_settings={},
        match_titles: bool = False,
        state_machine_class=None,
        state_machine_kwargs=None,
    ): ...
    def section(self, title: str, source, style, lineno: int, messages) -> None: ...
    def check_subsection(self, source, style, lineno: int): ...
    def title_inconsistent(self, sourcetext: str, lineno: int): ...
    def new_subsection(self, title: str, lineno: int, messages) -> None: ...
    def paragraph(self, lines: Iterable[str], lineno: int): ...
    def inline_text(self, text: str, lineno: int): ...
    def unindent_warning(self, node_name: str): ...

def build_regexp(definition: _BasicDefinition, compile: bool = True): ...

_BasicDefinition: TypeAlias = tuple[str, str, str, list[Pattern[str]]]
_DefinitionParts: TypeAlias = tuple[str, str, str, list[Pattern[str] | _BasicDefinition]]
_DefinitionType: TypeAlias = tuple[str, str, str, list[Pattern[str] | _DefinitionParts]]

class Inliner:
    implicit_dispatch: list[tuple[Pattern[str], Callable[[Match[str], int], Sequence[nodes.Node]]]]
    def __init__(self) -> None: ...
    start_string_prefix: str
    end_string_suffix: str
    parts: _DefinitionType
    patterns: Struct
    def init_customizations(self, settings: Any) -> None: ...
    reporter: Reporter
    document: nodes.document
    language: ModuleType
    parent: nodes.Element
    def parse(
        self, text: str, lineno: int, memo: Struct, parent: nodes.Element
    ) -> tuple[list[nodes.Node], list[nodes.system_message]]: ...
    non_whitespace_before: str
    non_whitespace_escape_before: str
    non_unescaped_whitespace_escape_before: str
    non_whitespace_after: str
    simplename: str
    uric: str
    uri_end_delim: str
    urilast: str
    uri_end: str
    emailc: str
    email_pattern: str
    def quoted_start(self, match: Match[str]) -> bool: ...
    def inline_obj(
        self,
        match: Match[str],
        lineno: int,
        end_pattern: Pattern[str],
        nodeclass: nodes.TextElement,
        restore_backslashes: bool = False,
    ) -> tuple[str, list[nodes.problematic], str, list[nodes.system_message], str]: ...
    def problematic(self, text: str, rawsource: str, message: nodes.system_message) -> nodes.problematic: ...
    def emphasis(
        self, match: Match[str], lineno: int
    ) -> tuple[str, list[nodes.problematic], str, list[nodes.system_message]]: ...
    def strong(self, match: Match[str], lineno: int) -> tuple[str, list[nodes.problematic], str, list[nodes.system_message]]: ...
    def interpreted_or_phrase_ref(
        self, match: Match[str], lineno: int
    ) -> tuple[str, list[nodes.problematic], str, list[nodes.system_message]]: ...
    def phrase_ref(
        self, before: str, after: str, rawsource: str, escaped: str, text: str | None = None
    ) -> tuple[str, list[nodes.Node], str, list[nodes.Node]]: ...
    def adjust_uri(self, uri: str) -> str: ...
    def interpreted(
        self, rawsource: str, text: str, role: str, lineno: int
    ) -> tuple[list[nodes.Node], list[nodes.system_message]]: ...
    def literal(self, match: Match[str], lineno: int) -> tuple[str, list[nodes.problematic], str, list[nodes.system_message]]: ...
    def inline_internal_target(
        self, match: Match[str], lineno: int
    ) -> tuple[str, list[nodes.problematic], str, list[nodes.system_message]]: ...
    def substitution_reference(
        self, match: Match[str], lineno: int
    ) -> tuple[str, list[nodes.problematic], str, list[nodes.system_message]]: ...
    def footnote_reference(
        self, match: Match[str], lineno: int
    ) -> tuple[str, list[nodes.problematic], str, list[nodes.system_message]]: ...
    def reference(
        self, match: Match[str], lineno: int, anonymous: bool = False
    ) -> tuple[str, list[nodes.problematic], str, list[nodes.system_message]]: ...
    def anonymous_reference(
        self, match: Match[str], lineno: int
    ) -> tuple[str, list[nodes.problematic], str, list[nodes.system_message]]: ...
    def standalone_uri(
        self, match: Match[str], lineno: int
    ) -> list[tuple[str, list[nodes.problematic], str, list[nodes.system_message]]]: ...
    def pep_reference(
        self, match: Match[str], lineno: int
    ) -> list[tuple[str, list[nodes.problematic], str, list[nodes.system_message]]]: ...
    rfc_url: str = ...
    def rfc_reference(
        self, match: Match[str], lineno: int
    ) -> list[tuple[str, list[nodes.problematic], str, list[nodes.system_message]]]: ...
    def implicit_inline(self, text: str, lineno: int) -> list[nodes.Text]: ...
    dispatch: dict[str, Callable[[Match[str], int], tuple[str, list[nodes.problematic], str, list[nodes.system_message]]]] = ...

class Body(RSTState):
    double_width_pad_char: TableParser
    enum: Struct
    grid_table_top_pat: Pattern[str]
    simple_table_top_pat: Pattern[str]
    pats: dict[str, str]
    patterns: ClassVar[dict[str, str | Pattern[str]]]
    initial_transitions: ClassVar[tuple[str, ...]]
    explicit: Struct
    def indent(self, match: Any, context: _Context, next_state: str) -> _TransitionResult[_Context]: ...
    def block_quote(self, indented: StringList, line_offset: int) -> list[nodes.block_quote | nodes.system_message]: ...
    attribution_pattern: Pattern[str]
    def split_attribution(
        self, indented: StringList, line_offset: int
    ) -> tuple[StringList, None, None, None, None] | tuple[StringList, StringList, int, StringList, int]: ...
    def check_attribution(self, indented: StringList, attribution_start: int) -> tuple[None, None]: ...
    def parse_attribution(self, indented: StringList, line_offset: int) -> tuple[nodes.attribution, nodes.system_message]: ...
    def bullet(self, match: Match[str], context: Any, next_state: _NextState) -> tuple[list[Any], _NextState, list[Any]]: ...
    def list_item(self, indent: int) -> tuple[nodes.list_item, bool]: ...
    def enumerator(self, match: Match[str], context: _Context, next_state: str) -> _TransitionResult[_Context]: ...
    def parse_enumerator(
        self, match: Match[str], expected_sequence: str | None = None
    ) -> tuple[Literal["period", "parens", "rparen"], str, str, int | None]: ...
    def is_enumerated_list_item(self, ordinal: int | None, sequence: str, format) -> bool: ...
    def make_enumerator(self, ordinal: int, sequence: str, format) -> tuple[str, str] | None: ...
    def field_marker(self, match: Match[str], context: _Context, next_state: str) -> _TransitionResult[_Context]: ...
    def field(self, match: Match[str]) -> tuple[nodes.field, bool]: ...
    def parse_field_marker(self, match: Match[str]) -> str: ...
    def parse_field_body(self, indented, offset, node) -> None: ...
    def option_marker(self, match: Match[str], context, next_state): ...
    def option_list_item(self, match: Match[str]) -> tuple[nodes.option_list_item, bool]: ...
    def parse_option_marker(self, match: Match[str]) -> list[nodes.option]: ...
    def doctest(self, match: Match[str], context: _Context, next_state: str) -> _TransitionResult[_Context]: ...
    def line_block(self, match: Match[str], context: _Context, next_state: str) -> _TransitionResult[_Context]: ...
    def line_block_line(self, match: Match[str], lineno: int) -> tuple[nodes.line, nodes.system_message, bool]: ...
    def nest_line_block_lines(self, block: nodes.line_block) -> None: ...
    def nest_line_block_segment(self, block: nodes.line_block) -> None: ...
    def grid_table_top(self, match: Match[str], context: _Context, next_state: str) -> _TransitionResult[_Context]: ...
    def simple_table_top(self, match: Match[str], context: _Context, next_state: str) -> _TransitionResult[_Context]: ...
    def table_top(
        self, match: Match[str], context, next_state: str, isolate_function, parser_class
    ) -> tuple[list[Incomplete], str, list[Incomplete]]: ...
    def table(self, isolate_function, parser_class) -> tuple[list[Incomplete], bool]: ...
    def isolate_grid_table(self) -> tuple[StringList | list[Incomplete], list[Incomplete], Literal[1, 0]]: ...
    def isolate_simple_table(self) -> tuple[StringList | list[Incomplete], list[Incomplete], bool]: ...
    def malformed_table(self, block, detail: str = "", offset: int = 0) -> list[Incomplete]: ...
    def build_table(
        self, tabledata: tuple[Incomplete, Incomplete, Incomplete], tableline, stub_columns: int = 0, widths=None
    ) -> nodes.table: ...
    def build_table_row(self, rowdata, tableline) -> nodes.row: ...
    def footnote(self, match: Match[str]) -> tuple[list[nodes.footnote], bool]: ...
    def citation(self, match: Match[str]) -> tuple[list[nodes.citation], bool]: ...
    def hyperlink_target(self, match: Match[str]) -> tuple[list[nodes.target], bool]: ...
    def make_target(self, block: StringList, block_text, lineno: int, target_name: str | None) -> nodes.target | str: ...
    def parse_target(
        self, block: StringList, block_text, lineno: int
    ) -> tuple[Literal["refname"], str] | tuple[Literal["refuri"], str]: ...
    def is_reference(self, reference: str) -> str | None: ...
    def add_target(self, targetname: str | None, refuri: str, target: nodes.Element, lineno: int) -> None: ...
    def substitution_def(self, match: Match[str]) -> tuple[list[Incomplete], bool]: ...
    def disallowed_inside_substitution_definitions(self, node: nodes.Node) -> bool: ...
    def directive(self, match: Match[str], **option_presets) -> tuple[list[nodes.Node], bool]: ...
    def run_directive(self, directive: Directive, match: Match[str], type_name: str, option_presets: dict[str, Any]): ...
    def parse_directive_block(
        self, indented: list[str], line_offset: int, directive: Directive, option_presets: dict[str, Any]
    ): ...
    def parse_directive_options(self, option_presets, option_spec: Mapping[str, Incomplete], arg_block): ...
    def parse_directive_arguments(self, directive: Directive, arg_block): ...
    def parse_extension_options(
        self, option_spec: Mapping[str, Incomplete], datalines: Sequence[str]
    ) -> tuple[Literal[0], str] | tuple[Literal[1], dict[str, Any]]: ...
    def unknown_directive(self, type_name: str) -> tuple[list[Incomplete], bool]: ...
    def comment(self, match: Match[str]) -> tuple[list[nodes.comment], bool]: ...
    def explicit_markup(self, match: Match[str], context, next_state: str) -> tuple[list[Incomplete], str, list[Incomplete]]: ...
    def explicit_construct(self, match: Match[str]) -> tuple[list[Incomplete], bool]: ...
    def explicit_list(self, blank_finish) -> None: ...
    def anonymous(self, match: Match[str], context, next_state: str) -> tuple[list[Incomplete], str, list[Any]]: ...
    def anonymous_target(self, match: Match[str]) -> tuple[list[nodes.target], bool]: ...
    def line(self, match: Match[str], context, next_state: str) -> tuple[list[Incomplete], str, list[Any]]: ...
    def text(self, match: Match[str], context, next_state: str) -> tuple[list[str], Literal["Text"], list[Any]]: ...

class RFC2822Body(Body):
    patterns: ClassVar[dict[str, str | Pattern[str]]]
    initial_transitions: ClassVar[list[tuple[str | tuple[str, str], str]]]  # type: ignore[assignment]
    def rfc2822(self, match: Match[str], context: Any, next_state: _NextState) -> tuple[list[Any], _NextState, list[str]]: ...
    def rfc2822_field(self, match: Match[str]): ...

class SpecializedBody(Body):
    blank_finish: Incomplete
    def invalid_input(self, match: Any = None, context: Any = None, next_state: Any = None) -> Never: ...
    indent = invalid_input
    bullet = invalid_input
    enumerator = invalid_input
    field_marker = invalid_input
    option_marker = invalid_input
    doctest = invalid_input
    line_block = invalid_input
    grid_table_top = invalid_input
    simple_table_top = invalid_input
    explicit_markup = invalid_input
    anonymous = invalid_input
    line = invalid_input
    text = invalid_input

class BulletList(SpecializedBody):
    def bullet(self, match: Match[str], context: Any, next_state: _NextState) -> tuple[list[Any], _NextState, list[Any]]: ...  # type: ignore[override]

class DefinitionList(SpecializedBody):
    def text(self, match: Match[str], context: Any, next_state: Any) -> tuple[list[str], Literal["Definition"], list[Any]]: ...  # type: ignore[override]

class EnumeratedList(SpecializedBody):
    auto: int
    blank_finish: Incomplete
    lastordinal: Incomplete
    def enumerator(self, match: Match[str], context: Any, next_state: _NextState) -> tuple[list[Any], _NextState, list[Any]]: ...  # type: ignore[override]

class FieldList(SpecializedBody):
    blank_finish: Incomplete
    def field_marker(  # type: ignore[override]
        self, match: Match[str], context: Any, next_state: _NextState
    ) -> tuple[list[Any], _NextState, list[Any]]: ...

class OptionList(SpecializedBody):
    blank_finish: Incomplete
    def option_marker(  # type: ignore[override]
        self, match: Match[str], context: Any, next_state: _NextState
    ) -> tuple[list[Any], _NextState, list[Any]]: ...

class RFC2822List(SpecializedBody, RFC2822Body):
    patterns: ClassVar[dict[str, str | Pattern[str]]]
    initial_transitions: ClassVar[list[tuple[str | tuple[str, str], str]]]
    blank_finish: Incomplete
    def rfc2822(  # type: ignore[override]
        self, match: Match[str], context: Any, next_state: Any
    ) -> tuple[list[Any], Literal["RFC2822List"], list[Any]]: ...
    def blank(self, match: Any = None, context: Any = None, next_state: Any = None) -> Never: ...

class ExtensionOptions(FieldList):
    def parse_field_body(self, indented: StringList, offset: Any, node: nodes.Node) -> None: ...

class LineBlock(SpecializedBody):
    blank_finish: Incomplete
    def blank(self, match: Any = None, context: Any = None, next_state: Any = None) -> Never: ...
    def line_block(self, match: Match[Any], context: Any, next_state: _NextState) -> tuple[list[Any], _NextState, list[Any]]: ...  # type: ignore[override]

class Explicit(SpecializedBody):
    blank_finish: Incomplete
    def explicit_markup(  # type: ignore[override]
        self, match: Match[str], context: Any, next_state: _NextState
    ) -> tuple[list[Any], _NextState, list[Any]]: ...
    def anonymous(self, match: Match[str], context: Any, next_state: _NextState) -> tuple[list[Any], _NextState, list[Any]]: ...  # type: ignore[override]
    def blank(self, match: Any = None, context: Any = None, next_state: Any = None) -> Never: ...

class SubstitutionDef(Body):
    patterns: ClassVar[dict[str, str | Pattern[str]]]
    initial_transitions: ClassVar[list[str]]  # type: ignore[assignment]
    blank_finish: Incomplete

    def embedded_directive(self, match: Match[str], context: Any, next_state: Any) -> Never: ...
    def text(self, match: Any, context: Any, next_state: Any) -> Never: ...

class Text(RSTState):
    patterns: ClassVar[dict[str, str | Pattern[str]]]
    initial_transitions: ClassVar[list[tuple[str, str]]]

    def blank(self, match: Match[str], context: Any, next_state: Any) -> tuple[list[Any], Literal["Body"], list[Any]]: ...
    def eof(self, context: Any) -> list[Any]: ...
    def indent(self, match: Any, context: Any, next_state: Any) -> tuple[list[Any], Literal["Body"], list[Any]]: ...
    def underline(
        self, match: Match[Any], context: Sequence[str], next_state: _NextState
    ) -> tuple[list[Any], _NextState, list[Any]]: ...
    def text(self, match: Any, context: Any, next_state: _NextState) -> tuple[list[Any], _NextState, list[Any]]: ...
    def literal_block(self) -> list[nodes.Node]: ...
    def quoted_literal_block(self) -> list[nodes.Node]: ...
    def definition_list_item(self, termline: StringList) -> tuple[nodes.definition_list_item, bool]: ...
    classifier_delimiter: Pattern[str]
    def term(self, lines: StringList, lineno: int) -> tuple[nodes.Node, nodes.system_message]: ...

class SpecializedText(Text):
    def eof(self, context: Any) -> list[Any]: ...
    def invalid_input(self, match: Any = None, context: Any = None, next_state: Any = None) -> Never: ...

    blank = invalid_input
    indent = invalid_input
    underline = invalid_input
    text = invalid_input

class Definition(SpecializedText):
    def eof(self, context: Any) -> list[Any]: ...
    def indent(  # type: ignore[override]
        self, match: Any, context: list[str], next_state: Any
    ) -> tuple[list[Any], Literal["DefinitionList"], list[Any]]: ...

class Line(SpecializedText):
    eofcheck: Literal[1]
    def eof(self, context: Any) -> list[Any]: ...
    def blank(self, match: Any, context: Any, next_state: Any) -> tuple[list[Any], Literal["Body"], list[Any]]: ...  # type: ignore[override]
    def text(self, match: Match[str], context: list[str], next_state: Any) -> tuple[list[Any], Literal["Body"], list[Any]]: ...  # type: ignore[override]
    def indent(self, match: Match[str], context: list[str], next_state: Any) -> tuple[list[Any], Literal["Body"], list[Any]]: ...  # type: ignore[override]
    def underline(self, match: Any, context: list[str], next_state: Any) -> tuple[list[Any], Literal["Body"], list[Any]]: ...  # type: ignore[override]
    def short_overline(self, context: list[Any], blocktext: Any, lineno: int | None, lines: int = 1) -> None: ...
    def state_correction(self, context: list[Any], lines: int = 1) -> Never: ...

class QuotedLiteralBlock(RSTState):
    patterns: ClassVar[dict[str, str | Pattern[str]]]
    messages: list[Incomplete]
    initial_lineno: int | None
    def __init__(self, state_machine: StateMachine[Incomplete], debug=False) -> None: ...
    @overload
    def blank(
        self, match: Any, context: _EmptyContext, next_state: _NextState
    ) -> tuple[_EmptyContext, _NextState, list[Any]]: ...
    @overload
    def blank(self, match: Any, context: Any, next_state: _NextState) -> Never: ...
    def eof(self, context: list[str]) -> list[Any]: ...
    def indent(self, match: Any, context: list[str], next_state: Any) -> Never: ...
    def initial_quoted(
        self, match: Match[str], context: Any, next_state: _NextState
    ) -> tuple[list[str], _NextState, list[Any]]: ...
    def quoted(self, match: Match[str], context: _Context, next_state: _NextState) -> tuple[_Context, _NextState, list[Any]]: ...
    def text(self, match: Any, context: Any, next_state: Any) -> Never: ...

state_classes: tuple[
    Body,
    BulletList,
    DefinitionList,
    EnumeratedList,
    FieldList,
    OptionList,
    LineBlock,
    ExtensionOptions,
    Explicit,
    Text,
    Definition,
    Line,
    SubstitutionDef,
    RFC2822Body,
    RFC2822List,
]
