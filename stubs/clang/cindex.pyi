from _typeshed import SupportsRead
from collections.abc import Generator, Iterator, Sequence
from ctypes import *
from pathlib import Path
from typing import Any, Callable

__all__ = [
    "AvailabilityKind",
    "Config",
    "CodeCompletionResults",
    "CompilationDatabase",
    "CompileCommands",
    "CompileCommand",
    "CursorKind",
    "Cursor",
    "Diagnostic",
    "File",
    "FixIt",
    "Index",
    "LinkageKind",
    "SourceLocation",
    "SourceRange",
    "TLSKind",
    "TokenKind",
    "Token",
    "TranslationUnitLoadError",
    "TranslationUnit",
    "TypeKind",
    "Type",
]

class c_interop_string(c_char_p):
    def __init__(self, p: str | bytes | None = None) -> None: ...
    @property
    def value(self) -> str: ...
    @classmethod
    def from_param(cls, param: str | bytes): ...
    @staticmethod
    def to_python_string(x, *args) -> str: ...

class TranslationUnitLoadError(Exception): ...

class TranslationUnitSaveError(Exception):
    ERROR_UNKNOWN: int
    ERROR_TRANSLATION_ERRORS: int
    ERROR_INVALID_TU: int
    save_error: int
    def __init__(self, enumeration: int, message: str) -> None: ...

class CachedProperty:
    __doc__: str
    def __init__(self, wrapped: Callable[..., object]) -> None: ...
    def __get__(self, instance: Any, instance_type: type | None = None) -> object: ...

class _CXString(Structure):
    def __del__(self) -> None: ...
    @staticmethod
    def from_result(res: c_interop_string, fn: Any | None = None, args: Any | None = None): ...

class SourceLocation(Structure):
    @staticmethod
    def from_position(tu: TranslationUnit, file: File, line: int, column: int): ...
    @staticmethod
    def from_offset(tu: TranslationUnit, file: File, offset: int): ...
    @property
    def file(self) -> File: ...
    @property
    def line(self) -> int: ...
    @property
    def column(self) -> int: ...
    @property
    def offset(self) -> int: ...
    @property
    def is_in_system_header(self) -> bool: ...
    def __eq__(self, other: SourceLocation) -> bool: ...
    def __ne__(self, other: SourceLocation) -> bool: ...

class SourceRange(Structure):
    @staticmethod
    def from_locations(start: int, end: int): ...
    @property
    def start(self) -> int: ...
    @property
    def end(self) -> int: ...
    def __eq__(self, other: SourceRange) -> bool: ...
    def __ne__(self, other: SourceRange) -> bool: ...
    def __contains__(self, other: SourceRange) -> bool: ...

class Diagnostic:
    Ignored: int
    Note: int
    Warning: int
    Error: int
    Fatal: int
    DisplaySourceLocation: int
    DisplayColumn: int
    DisplaySourceRanges: int
    DisplayOption: int
    DisplayCategoryId: int
    DisplayCategoryName: int
    ptr: c_void_p
    def __init__(self, ptr: c_void_p) -> None: ...
    def __del__(self) -> None: ...
    @property
    def severity(self) -> int: ...
    @property
    def location(self) -> SourceLocation: ...
    @property
    def spelling(self) -> _CXString: ...
    @property
    def ranges(self) -> Sequence[SourceRange]: ...
    @property
    def fixits(self) -> Sequence[FixIt]: ...
    @property
    def children(self) -> Sequence[Diagnostic]: ...
    @property
    def category_number(self) -> int: ...
    @property
    def category_name(self) -> _CXString: ...
    @property
    def option(self) -> _CXString: ...
    @property
    def disable_option(self) -> _CXString: ...
    def format(self, options: str | None = None) -> _CXString: ...

class FixIt:
    range: SourceRange
    value: Any
    def __init__(self, range: SourceRange, value: Any) -> None: ...

class TokenGroup:
    def __init__(self, tu: TranslationUnit, memory, count: int) -> None: ...
    def __del__(self) -> None: ...
    @staticmethod
    def get_tokens(tu: TranslationUnit, extent: SourceRange) -> Generator[Token]: ...

class TokenKind(BaseEnumeration):
    value: int
    name: str
    def __init__(self, value: int, name: str) -> None: ...
    @staticmethod
    def from_value(value: int): ...
    @staticmethod
    def register(value: int, name: str) -> None: ...

class BaseEnumeration:
    value: int
    def __init__(self, value: int) -> None: ...
    def from_param(self) -> int: ...
    @property
    def name(self) -> str: ...
    @classmethod
    def from_id(cls, id: int): ...

class CursorKind(BaseEnumeration):
    @staticmethod
    def get_all_kinds() -> Sequence[CursorKind]: ...
    def is_declaration(self) -> bool: ...
    def is_reference(self) -> bool: ...
    def is_expression(self) -> bool: ...
    def is_statement(self) -> bool: ...
    def is_attribute(self) -> bool: ...
    def is_invalid(self) -> bool: ...
    def is_translation_unit(self) -> bool: ...
    def is_preprocessing(self) -> bool: ...
    def is_unexposed(self) -> bool: ...

    # What inspired this stub in the first place was this entire list of enums.

    UNEXPOSED_DECL: int
    STRUCT_DECL: int
    UNION_DECL: int
    CLASS_DECL: int
    ENUM_DECL: int
    FIELD_DECL: int
    ENUM_CONSTANT_DECL: int
    FUNCTION_DECL: int
    VAR_DECL: int
    PARM_DECL: int
    OBJC_INTERFACE_DECL: int
    OBJC_CATEGORY_DECL: int
    OBJC_PROTOCOL_DECL: int
    OBJC_PROPERTY_DECL: int
    OBJC_IVAR_DECL: int
    OBJC_INSTANCE_METHOD_DECL: int
    OBJC_CLASS_METHOD_DECL: int
    OBJC_IMPLEMENTATION_DECL: int
    OBJC_CATEGORY_IMPL_DECL: int
    TYPEDEF_DECL: int
    CXX_METHOD: int
    NAMESPACE: int
    LINKAGE_SPEC: int
    CONSTRUCTOR: int
    DESTRUCTOR: int
    CONVERSION_FUNCTION: int
    TEMPLATE_TYPE_PARAMETER: int
    TEMPLATE_NON_TYPE_PARAMETER: int
    TEMPLATE_TEMPLATE_PARAMETER: int
    FUNCTION_TEMPLATE: int
    CLASS_TEMPLATE: int
    CLASS_TEMPLATE_PARTIAL_SPECIALIZATION: int
    NAMESPACE_ALIAS: int
    USING_DIRECTIVE: int
    USING_DECLARATION: int
    TYPE_ALIAS_DECL: int
    OBJC_SYNTHESIZE_DECL: int
    OBJC_DYNAMIC_DECL: int
    CXX_ACCESS_SPEC_DECL: int
    OBJC_SUPER_CLASS_REF: int
    OBJC_PROTOCOL_REF: int
    OBJC_CLASS_REF: int
    TYPE_REF: int
    CXX_BASE_SPECIFIER: int
    TEMPLATE_REF: int
    NAMESPACE_REF: int
    MEMBER_REF: int
    LABEL_REF: int
    OVERLOADED_DECL_REF: int
    VARIABLE_REF: int
    INVALID_FILE: int
    NO_DECL_FOUND: int
    NOT_IMPLEMENTED: int
    INVALID_CODE: int
    UNEXPOSED_EXPR: int
    DECL_REF_EXPR: int
    MEMBER_REF_EXPR: int
    CALL_EXPR: int
    OBJC_MESSAGE_EXPR: int
    BLOCK_EXPR: int
    INTEGER_LITERAL: int
    FLOATING_LITERAL: int
    IMAGINARY_LITERAL: int
    STRING_LITERAL: int
    CHARACTER_LITERAL: int
    PAREN_EXPR: int
    UNARY_OPERATOR: int
    ARRAY_SUBSCRIPT_EXPR: int
    BINARY_OPERATOR: int
    COMPOUND_ASSIGNMENT_OPERATOR: int
    CONDITIONAL_OPERATOR: int
    CSTYLE_CAST_EXPR: int
    COMPOUND_LITERAL_EXPR: int
    INIT_LIST_EXPR: int
    ADDR_LABEL_EXPR: int
    StmtExpr: int
    GENERIC_SELECTION_EXPR: int
    GNU_NULL_EXPR: int
    CXX_STATIC_CAST_EXPR: int
    CXX_DYNAMIC_CAST_EXPR: int
    CXX_REINTERPRET_CAST_EXPR: int
    CXX_CONST_CAST_EXPR: int
    CXX_FUNCTIONAL_CAST_EXPR: int
    CXX_TYPEID_EXPR: int
    CXX_BOOL_LITERAL_EXPR: int
    CXX_NULL_PTR_LITERAL_EXPR: int
    CXX_THIS_EXPR: int
    CXX_THROW_EXPR: int
    CXX_NEW_EXPR: int
    CXX_DELETE_EXPR: int
    CXX_UNARY_EXPR: int
    OBJC_STRING_LITERAL: int
    OBJC_ENCODE_EXPR: int
    OBJC_SELECTOR_EXPR: int
    OBJC_PROTOCOL_EXPR: int
    OBJC_BRIDGE_CAST_EXPR: int
    PACK_EXPANSION_EXPR: int
    SIZE_OF_PACK_EXPR: int
    LAMBDA_EXPR: int
    OBJ_BOOL_LITERAL_EXPR: int
    OBJ_SELF_EXPR: int
    OMP_ARRAY_SECTION_EXPR: int
    OBJC_AVAILABILITY_CHECK_EXPR: int
    FIXED_POINT_LITERAL: int
    OMP_ARRAY_SHAPING_EXPR: int
    OMP_ITERATOR_EXPR: int
    CXX_ADDRSPACE_CAST_EXPR: int
    CONCEPT_SPECIALIZATION_EXPR: int
    REQUIRES_EXPR: int
    UNEXPOSED_STMT: int
    LABEL_STMT: int
    COMPOUND_STMT: int
    CASE_STMT: int
    DEFAULT_STMT: int
    IF_STMT: int
    SWITCH_STMT: int
    WHILE_STMT: int
    DO_STMT: int
    FOR_STMT: int
    GOTO_STMT: int
    INDIRECT_GOTO_STMT: int
    CONTINUE_STMT: int
    BREAK_STMT: int
    RETURN_STMT: int
    ASM_STMT: int
    OBJC_AT_TRY_STMT: int
    OBJC_AT_CATCH_STMT: int
    OBJC_AT_FINALLY_STMT: int
    OBJC_AT_THROW_STMT: int
    OBJC_AT_SYNCHRONIZED_STMT: int
    OBJC_AUTORELEASE_POOL_STMT: int
    OBJC_FOR_COLLECTION_STMT: int
    CXX_CATCH_STMT: int
    CXX_TRY_STMT: int
    CXX_FOR_RANGE_STMT: int
    SEH_TRY_STMT: int
    SEH_EXCEPT_STMT: int
    SEH_FINALLY_STMT: int
    MS_ASM_STMT: int
    NULL_STMT: int
    DECL_STMT: int
    OMP_PARALLEL_DIRECTIVE: int
    OMP_SIMD_DIRECTIVE: int
    OMP_FOR_DIRECTIVE: int
    OMP_SECTIONS_DIRECTIVE: int
    OMP_SECTION_DIRECTIVE: int
    OMP_SINGLE_DIRECTIVE: int
    OMP_PARALLEL_FOR_DIRECTIVE: int
    OMP_PARALLEL_SECTIONS_DIRECTIVE: int
    OMP_TASK_DIRECTIVE: int
    OMP_MASTER_DIRECTIVE: int
    OMP_CRITICAL_DIRECTIVE: int
    OMP_TASKYIELD_DIRECTIVE: int
    OMP_BARRIER_DIRECTIVE: int
    OMP_TASKWAIT_DIRECTIVE: int
    OMP_FLUSH_DIRECTIVE: int
    SEH_LEAVE_STMT: int
    OMP_ORDERED_DIRECTIVE: int
    OMP_ATOMIC_DIRECTIVE: int
    OMP_FOR_SIMD_DIRECTIVE: int
    OMP_PARALLELFORSIMD_DIRECTIVE: int
    OMP_TARGET_DIRECTIVE: int
    OMP_TEAMS_DIRECTIVE: int
    OMP_TASKGROUP_DIRECTIVE: int
    OMP_CANCELLATION_POINT_DIRECTIVE: int
    OMP_CANCEL_DIRECTIVE: int
    OMP_TARGET_DATA_DIRECTIVE: int
    OMP_TASK_LOOP_DIRECTIVE: int
    OMP_TASK_LOOP_SIMD_DIRECTIVE: int
    OMP_DISTRIBUTE_DIRECTIVE: int
    OMP_TARGET_ENTER_DATA_DIRECTIVE: int
    OMP_TARGET_EXIT_DATA_DIRECTIVE: int
    OMP_TARGET_PARALLEL_DIRECTIVE: int
    OMP_TARGET_PARALLELFOR_DIRECTIVE: int
    OMP_TARGET_UPDATE_DIRECTIVE: int
    OMP_DISTRIBUTE_PARALLELFOR_DIRECTIVE: int
    OMP_DISTRIBUTE_PARALLEL_FOR_SIMD_DIRECTIVE: int
    OMP_DISTRIBUTE_SIMD_DIRECTIVE: int
    OMP_TARGET_PARALLEL_FOR_SIMD_DIRECTIVE: int
    OMP_TARGET_SIMD_DIRECTIVE: int
    OMP_TEAMS_DISTRIBUTE_DIRECTIVE: int
    OMP_TEAMS_DISTRIBUTE_SIMD_DIRECTIVE: int
    OMP_TEAMS_DISTRIBUTE_PARALLEL_FOR_SIMD_DIRECTIVE: int
    OMP_TEAMS_DISTRIBUTE_PARALLEL_FOR_DIRECTIVE: int
    OMP_TARGET_TEAMS_DIRECTIVE: int
    OMP_TARGET_TEAMS_DISTRIBUTE_DIRECTIVE: int
    OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_FOR_DIRECTIVE: int
    OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_FOR_SIMD_DIRECTIVE: int
    OMP_TARGET_TEAMS_DISTRIBUTE_SIMD_DIRECTIVE: int
    BUILTIN_BIT_CAST_EXPR: int
    OMP_MASTER_TASK_LOOP_DIRECTIVE: int
    OMP_PARALLEL_MASTER_TASK_LOOP_DIRECTIVE: int
    OMP_MASTER_TASK_LOOP_SIMD_DIRECTIVE: int
    OMP_PARALLEL_MASTER_TASK_LOOP_SIMD_DIRECTIVE: int
    OMP_PARALLEL_MASTER_DIRECTIVE: int
    OMP_DEPOBJ_DIRECTIVE: int
    OMP_SCAN_DIRECTIVE: int
    OMP_TILE_DIRECTIVE: int
    OMP_CANONICAL_LOOP: int
    OMP_INTEROP_DIRECTIVE: int
    OMP_DISPATCH_DIRECTIVE: int
    OMP_MASKED_DIRECTIVE: int
    OMP_UNROLL_DIRECTIVE: int
    OMP_META_DIRECTIVE: int
    OMP_GENERIC_LOOP_DIRECTIVE: int
    OMP_TEAMS_GENERIC_LOOP_DIRECTIVE: int
    OMP_TARGET_TEAMS_GENERIC_LOOP_DIRECTIVE: int
    OMP_PARALLEL_GENERIC_LOOP_DIRECTIVE: int
    OMP_TARGET_PARALLEL_GENERIC_LOOP_DIRECTIVE: int
    OMP_PARALLEL_MASKED_DIRECTIVE: int
    OMP_MASKED_TASK_LOOP_DIRECTIVE: int
    OMP_MASKED_TASK_LOOP_SIMD_DIRECTIVE: int
    OMP_PARALLEL_MASKED_TASK_LOOP_DIRECTIVE: int
    OMP_PARALLEL_MASKED_TASK_LOOP_SIMD_DIRECTIVE: int
    TRANSLATION_UNIT: int
    UNEXPOSED_ATTR: int
    IB_ACTION_ATTR: int
    IB_OUTLET_ATTR: int
    IB_OUTLET_COLLECTION_ATTR: int
    CXX_FINAL_ATTR: int
    CXX_OVERRIDE_ATTR: int
    ANNOTATE_ATTR: int
    ASM_LABEL_ATTR: int
    PACKED_ATTR: int
    PURE_ATTR: int
    CONST_ATTR: int
    NODUPLICATE_ATTR: int
    CUDACONSTANT_ATTR: int
    CUDADEVICE_ATTR: int
    CUDAGLOBAL_ATTR: int
    CUDAHOST_ATTR: int
    CUDASHARED_ATTR: int
    VISIBILITY_ATTR: int
    DLLEXPORT_ATTR: int
    DLLIMPORT_ATTR: int
    CONVERGENT_ATTR: int
    WARN_UNUSED_ATTR: int
    WARN_UNUSED_RESULT_ATTR: int
    ALIGNED_ATTR: int
    PREPROCESSING_DIRECTIVE: int
    MACRO_DEFINITION: int
    MACRO_INSTANTIATION: int
    INCLUSION_DIRECTIVE: int
    MODULE_IMPORT_DECL: int
    TYPE_ALIAS_TEMPLATE_DECL: int
    STATIC_ASSERT: int
    FRIEND_DECL: int
    CONCEPT_DECL: int
    OVERLOAD_CANDIDATE: int

class TemplateArgumentKind(BaseEnumeration): ...
class ExceptionSpecificationKind(BaseEnumeration): ...

class Cursor(Structure):
    @staticmethod
    def from_location(tu: TranslationUnit, location: SourceLocation): ...
    def __hash__(self): ...
    def __eq__(self, other: Cursor): ...
    def __ne__(self, other: Cursor): ...
    def is_definition(self) -> bool: ...
    def is_const_method(self) -> bool: ...
    def is_converting_constructor(self) -> bool: ...
    def is_copy_constructor(self) -> bool: ...
    def is_default_constructor(self) -> bool: ...
    def is_move_constructor(self) -> bool: ...
    def is_default_method(self) -> bool: ...
    def is_deleted_method(self) -> bool: ...
    def is_copy_assignment_operator_method(self) -> bool: ...
    def is_move_assignment_operator_method(self) -> bool: ...
    def is_explicit_method(self) -> bool: ...
    def is_mutable_field(self) -> bool: ...
    def is_pure_virtual_method(self) -> bool: ...
    def is_static_method(self) -> bool: ...
    def is_virtual_method(self) -> bool: ...
    def is_abstract_record(self) -> bool: ...
    def is_scoped_enum(self) -> bool: ...
    def get_definition(self) -> Cursor: ...
    def get_usr(self) -> _CXString: ...
    def get_included_file(self) -> File: ...
    @property
    def kind(self) -> CursorKind: ...
    @property
    def spelling(self) -> _CXString: ...
    @property
    def displayname(self) -> str: ...
    @property
    def mangled_name(self) -> str: ...
    @property
    def location(self) -> SourceLocation: ...
    @property
    def linkage(self) -> LinkageKind: ...
    @property
    def tls_kind(self) -> TLSKind: ...
    @property
    def extent(self) -> SourceRange: ...
    @property
    def storage_class(self) -> StorageClass: ...
    @property
    def availability(self) -> AvailabilityKind: ...
    @property
    def access_specifier(self) -> AccessSpecifier: ...
    @property
    def type(self) -> Type: ...
    @property
    def canonical(self) -> Cursor: ...
    @property
    def result_type(self) -> Type: ...
    @property
    def exception_specification_kind(self) -> ExceptionSpecificationKind: ...
    @property
    def underlying_typedef_type(self) -> Type: ...
    @property
    def enum_type(self) -> Type: ...
    @property
    def enum_value(self) -> int: ...
    @property
    def objc_type_encoding(self) -> _CXString: ...
    @property
    def hash(self) -> int: ...
    @property
    def semantic_parent(self) -> Cursor: ...
    @property
    def lexical_parent(self) -> Cursor: ...
    @property
    def translation_unit(self) -> TranslationUnit: ...
    @property
    def referenced(self) -> Cursor: ...
    @property
    def brief_comment(self) -> _CXString: ...
    @property
    def raw_comment(self) -> _CXString: ...
    def get_arguments(self) -> Iterator[Cursor]: ...
    def get_num_template_arguments(self) -> int: ...
    def get_template_argument_kind(self, num: int) -> TemplateArgumentKind: ...
    def get_template_argument_type(self, num: int) -> Type: ...
    def get_template_argument_value(self, num: int) -> int: ...
    def get_template_argument_unsigned_value(self, num: int) -> int: ...
    def get_children(self) -> Iterator[Cursor]: ...
    def walk_preorder(self) -> Iterator[Cursor]: ...
    def get_tokens(self) -> Token: ...
    def get_field_offsetof(self) -> int: ...
    def is_anonymous(self) -> bool: ...
    def is_bitfield(self) -> bool: ...
    def get_bitfield_width(self) -> int: ...
    @staticmethod
    def from_result(res, fn, args) -> Cursor: ...
    @staticmethod
    def from_cursor_result(res, fn, args) -> Cursor: ...

class StorageClass(BaseEnumeration):
    value: int
    def __init__(self, value: int) -> None: ...
    @property
    def name(self) -> str: ...
    @staticmethod
    def from_id(id: int) -> StorageClass: ...

class AvailabilityKind(BaseEnumeration): ...
class AccessSpecifier(BaseEnumeration): ...

class TypeKind(BaseEnumeration):
    @property
    def spelling(self) -> _CXString: ...

class RefQualifierKind(BaseEnumeration): ...
class LinkageKind(BaseEnumeration): ...
class TLSKind(BaseEnumeration): ...

class Type(Structure):
    @property
    def kind(self) -> TypeKind: ...
    parent: Type
    length: int
    def argument_types(self) -> Sequence[Type]: ...
    @property
    def element_type(self) -> Type: ...
    @property
    def element_count(self) -> int: ...
    @property
    def translation_unit(self) -> TranslationUnit: ...
    @staticmethod
    def from_result(res, fn, args) -> Type: ...
    def get_num_template_arguments(self) -> int: ...
    def get_template_argument_type(self, num: int) -> Type: ...
    def get_canonical(self) -> Type: ...
    def is_const_qualified(self) -> bool: ...
    def is_volatile_qualified(self) -> bool: ...
    def is_restrict_qualified(self) -> bool: ...
    def is_function_variadic(self) -> bool: ...
    def get_address_space(self): ...
    def get_typedef_name(self) -> _CXString: ...
    def is_pod(self) -> bool: ...
    def get_pointee(self) -> Type: ...
    def get_declaration(self) -> Cursor: ...
    def get_result(self) -> Type: ...
    def get_array_element_type(self) -> Type: ...
    def get_array_size(self) -> int: ...
    def get_class_type(self) -> Type: ...
    def get_named_type(self) -> Type: ...
    def get_align(self) -> c_longlong: ...
    def get_size(self) -> c_longlong: ...
    def get_offset(self, fieldname: c_interop_string) -> c_longlong: ...
    def get_ref_qualifier(self) -> RefQualifierKind: ...
    def get_fields(self) -> Iterator[Cursor]: ...
    def get_exception_specification_kind(self) -> ExceptionSpecificationKind: ...
    @property
    def spelling(self) -> _CXString: ...
    def __eq__(self, other: Type) -> bool: ...
    def __ne__(self, other: Type) -> bool: ...

class ClangObject:
    # XXX: Couldn't type in that it's a void pointer
    obj: Any
    def __init__(self, obj: Any) -> None: ...

class _CXUnsavedFile(Structure): ...

class CompletionChunk:
    class Kind:
        name: str
        def __init__(self, name: str) -> None: ...

    cs: CompletionString
    key: int
    def __init__(self, completionString: CompletionString, key: int) -> None: ...
    def spelling(self) -> _CXString: ...
    def kind(self) -> Kind: ...
    def string(self) -> CompletionString | None: ...
    def isKindOptional(self) -> bool: ...
    def isKindTypedText(self) -> bool: ...
    def isKindPlaceHolder(self) -> bool: ...
    def isKindInformative(self) -> bool: ...
    def isKindResultType(self) -> bool: ...

class CompletionString(ClangObject):
    class Availability:
        name: str | _CXString
        def __init__(self, name: str | _CXString) -> None: ...

    def __len__(self) -> int: ...
    def num_chunks(self) -> int: ...
    def __getitem__(self, key: int): ...
    @property
    def priority(self) -> int: ...
    @property
    def availability(self) -> AvailabilityKind: ...
    @property
    def briefComment(self) -> _CXString: ...

class CodeCompletionResult(Structure):
    cusorKind: int
    @property
    def kind(self) -> CursorKind: ...
    @property
    def string(self) -> CompletionString: ...

class CCRStructure(Structure):
    def __len__(self) -> int: ...
    def __getitem__(self, ke: int) -> CodeCompletionResult: ...

class CodeCompletionResults(ClangObject):
    def __init__(self, ptr: Any) -> None: ...
    def from_param(self) -> CodeCompletionResults: ...
    def __del__(self) -> None: ...
    @property
    def results(self): ...
    @property
    def diagnostics(self) -> Sequence[Diagnostic]: ...

class Index(ClangObject):
    @staticmethod
    def create(excludeDecls: bool = False): ...
    def __del__(self) -> None: ...
    def read(self, path: bytes | str | Path) -> TranslationUnit: ...
    def parse(
        self,
        path: bytes | str | Path,
        args: Sequence[str] | None = None,
        unsaved_files: Sequence[tuple[str | Path,]] | None = None,
        options: int = 0,
    ) -> TranslationUnit: ...

class TranslationUnit(ClangObject):
    PARSE_NONE: int
    PARSE_DETAILED_PROCESSING_RECORD: int
    PARSE_INCOMPLETE: int
    PARSE_PRECOMPILED_PREAMBLE: int
    PARSE_CACHE_COMPLETION_RESULTS: int
    PARSE_SKIP_FUNCTION_BODIES: int
    PARSE_INCLUDE_BRIEF_COMMENTS_IN_CODE_COMPLETION: int

    @classmethod
    def from_source(
        cls,
        filename: str | bytes | Path,
        args: Sequence[str] | None = None,
        unsaved_files: Sequence[tuple[str | Path, SupportsRead[str | bytes]]] | None = None,
        options: int = 0,
        index: Index | None = None,
    ) -> TranslationUnit: ...
    @classmethod
    def from_ast_file(cls, filename: str | bytes | Path, index: Index | None = None): ...

    index: Index

    def __init__(self, ptr: Any, index: Index) -> None: ...
    def __del__(self) -> None: ...
    @property
    def cursor(self) -> Cursor: ...
    @property
    def spelling(self) -> _CXString: ...
    def get_includes(self) -> Iterator[FileInclusion]: ...
    def get_file(self, filename: str | bytes | Path): ...
    def get_location(self, filename: str | bytes | Path, position: int | Sequence[int]): ...
    def get_extent(self, filename: str | bytes | Path, locations: tuple[int, int] | list[int] | Sequence[int]) -> SourceRange: ...
    @property
    def diagnostics(self) -> Sequence[Diagnostic]: ...
    def reparse(self, unsaved_files: Sequence[str | bytes | Path] | None = None, options: int = 0) -> None: ...
    def save(self, filename: str | bytes | Path) -> None: ...
    def codeComplete(
        self,
        path: str | bytes | Path,
        line: int,
        column: int,
        unsaved_files: Sequence[tuple[str | Path, SupportsRead[str | bytes]]] | None = None,
        include_macros: bool = False,
        include_code_patterns: bool = False,
        include_brief_comments: bool = False,
    ) -> CodeCompletionResults | None: ...
    def get_tokens(self, locations: tuple[int, int] | None = None, extent: SourceRange | None = None): ...

class File(ClangObject):
    @staticmethod
    def from_name(translation_unit: TranslationUnit, file_name: str | bytes | Path) -> File: ...
    @property
    def name(self) -> str: ...
    @property
    def time(self): ...
    @staticmethod
    def from_result(res, fn, args) -> File: ...

class FileInclusion:
    source: File
    include: File
    location: SourceLocation
    depth: int
    def __init__(self, src: File, tgt: File, loc: SourceLocation, depth: int) -> None: ...
    @property
    def is_input_file(self) -> bool: ...

class CompilationDatabaseError(Exception):
    ERROR_UNKNOWN: int
    ERROR_CANNOTLOADDATABASE: int
    cdb_error: int
    def __init__(self, enumeration: int, message: str) -> None: ...

class CompileCommand:
    # XXX: Both are Void Pointers which Don't currently have helpful definitions
    cmd: Any
    ccmds: Any
    def __init__(self, cmd: Any, ccmds: Any) -> None: ...
    @property
    def directory(self) -> _CXString: ...
    @property
    def filename(self) -> _CXString: ...
    @property
    def arguments(self) -> Generator[_CXString]: ...

class CompileCommands:
    ccmds: c_void_p
    def __init__(self, ccmds: c_void_p) -> None: ...
    def __del__(self) -> None: ...
    def __len__(self) -> int: ...
    def __getitem__(self, i: int) -> CompileCommand: ...
    @staticmethod
    def from_result(res, fn, args) -> CompileCommands | None: ...

class CompilationDatabase(ClangObject):
    def __del__(self) -> None: ...
    @staticmethod
    def from_result(res, fn, args) -> CompilationDatabase: ...
    @staticmethod
    def fromDirectory(buildDir: str | bytes | Path): ...
    def getCompileCommands(self, filename: str | bytes | Path): ...
    def getAllCompileCommands(self) -> CompileCommands: ...

class Token(Structure):
    @property
    def spelling(self) -> _CXString: ...
    @property
    def kind(self) -> TokenKind: ...
    @property
    def location(self) -> SourceLocation: ...
    @property
    def extent(self) -> SourceRange: ...
    @property
    def cursor(self) -> Cursor: ...

class LibclangError(Exception):
    m: str
    def __init__(self, message: str) -> None: ...

class Config:
    library_path: str
    library_file: str
    compatibility_check: bool
    loaded: bool
    @staticmethod
    def set_library_path(path: str | bytes | Path) -> None: ...
    @staticmethod
    def set_library_file(filename: str | bytes | Path) -> None: ...
    @staticmethod
    def set_compatibility_check(check_status: bool) -> None: ...
    @property
    def lib(self) -> CDLL: ...
    def get_filename(self) -> str: ...
    def get_cindex_library(self) -> CDLL: ...
    def function_exists(self, name: str) -> bool: ...
