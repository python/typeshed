import decimal
from collections.abc import Callable, Sequence
from typing import Any, ClassVar, Literal, NamedTuple, TypeAlias, TypeVar, overload, type_check_only
from typing_extensions import Self

from .drawing import Renderable

_CallableT = TypeVar("_CallableT", bound=Callable[..., Any])

__pdoc__: dict[str, bool]

def force_nodocument(item: _CallableT) -> _CallableT: ...
def force_document(item: _CallableT) -> _CallableT: ...

Number: TypeAlias = int | float | decimal.Decimal
NumberClass: tuple[type, ...]

def check_range(value: float, minimum: float = 0.0, maximum: float = 1.0) -> float: ...
def number_to_str(number: Number) -> str: ...
@type_check_only
class _DeviceRGBBase(NamedTuple):
    r: Number
    g: Number
    b: Number
    a: Number | None

class DeviceRGB(_DeviceRGBBase):
    OPERATOR: ClassVar[str]
    def __new__(cls, r: Number, g: Number, b: Number, a: Number | None = None) -> Self: ...
    @property
    def colors(self) -> tuple[Number, Number, Number]: ...
    @property
    def colors255(self) -> tuple[Number, Number, Number]: ...
    def serialize(self) -> str: ...
    def is_achromatic(self) -> bool: ...
    def to_gray(self) -> DeviceGray: ...

@type_check_only
class _DeviceGrayBase(NamedTuple):
    g: Number
    a: Number | None

class DeviceGray(_DeviceGrayBase):
    OPERATOR: ClassVar[str]
    def __new__(cls, g: Number, a: Number | None = None) -> Self: ...
    @property
    def colors(self) -> tuple[Number, Number, Number]: ...
    @property
    def colors255(self) -> tuple[Number, Number, Number]: ...
    def serialize(self) -> str: ...

@type_check_only
class _DeviceCMYKBase(NamedTuple):
    c: Number
    m: Number
    y: Number
    k: Number
    a: Number | None

class DeviceCMYK(_DeviceCMYKBase):
    OPERATOR: ClassVar[str]
    def __new__(cls, c: Number, m: Number, y: Number, k: Number, a: Number | None = None) -> Self: ...
    @property
    def colors(self) -> tuple[Number, Number, Number, Number]: ...
    def serialize(self) -> str: ...

def rgb8(r: Number, g: Number, b: Number, a: Number | None = None) -> DeviceRGB: ...
def gray8(g: Number, a: Number | None = None) -> DeviceGray: ...
@overload
def convert_to_device_color(r: DeviceCMYK) -> DeviceCMYK: ...  # type: ignore[overload-overlap]
@overload
def convert_to_device_color(r: DeviceGray) -> DeviceGray: ...
@overload
def convert_to_device_color(r: DeviceRGB) -> DeviceRGB: ...
@overload
def convert_to_device_color(r: str) -> DeviceRGB: ...
@overload
def convert_to_device_color(r: Sequence[Number]) -> DeviceGray | DeviceRGB: ...
@overload
def convert_to_device_color(r: int, g: Literal[-1] = -1, b: Literal[-1] = -1) -> DeviceGray: ...
@overload
def convert_to_device_color(r: int, g: int, b: int) -> DeviceGray | DeviceRGB: ...
def cmyk8(c: Number, m: Number, y: Number, k: Number, a: Number | None = None) -> DeviceCMYK: ...
def color_from_hex_string(hexstr: str) -> DeviceRGB: ...
def color_from_rgb_string(rgbstr: str) -> DeviceRGB: ...

class Point(NamedTuple):
    x: float
    y: float
    def render(self) -> str: ...
    def dot(self, other: Point) -> float: ...
    def angle(self, other: Point) -> float: ...
    def mag(self) -> float: ...
    def __add__(self, other: Point) -> Point: ...  # type: ignore[override]
    def __sub__(self, other: Point) -> Point: ...
    def __neg__(self) -> Point: ...
    def __mul__(self, other: Point) -> Point: ...  # type: ignore[override]
    # Alias to __rmul__ at runtime, but that confuses type checkers and stubtest
    def __rmul__(self, other: Point) -> Point: ...  # type: ignore[override]
    def __truediv__(self, other: Number) -> Point: ...
    def __floordiv__(self, other: Number) -> Point: ...
    def __matmul__(self, other: Transform) -> Point: ...

class Transform(NamedTuple):
    a: float
    b: float
    c: float
    d: float
    e: float
    f: float
    @classmethod
    def identity(cls) -> Self: ...
    @classmethod
    def translation(cls, x: Number, y: Number) -> Self: ...
    @classmethod
    def scaling(cls, x: Number, y: Number | None = None) -> Self: ...
    @classmethod
    def rotation(cls, theta: Number) -> Self: ...
    @classmethod
    def rotation_d(cls, theta_d: Number) -> Self: ...
    @classmethod
    def shearing(cls, x: Number, y: Number | None = None) -> Self: ...
    @classmethod
    def skewing(cls, ax: Number = 0, ay: Number | None = None) -> Self: ...
    @classmethod
    def skewing_d(cls, ax_d: Number = 0, ay_d: Number | None = None) -> Self: ...
    def translate(self, x: Number, y: Number) -> Self: ...
    def scale(self, x: Number, y: Number | None = None) -> Self: ...
    def rotate(self, theta: Number) -> Self: ...
    def rotate_d(self, theta_d: Number) -> Self: ...
    def shear(self, x: Number, y: Number | None = None) -> Self: ...
    def skew(self, ax: Number = 0, ay: Number | None = None) -> Self: ...
    def skew_d(self, ax_d: Number = 0, ay_d: Number | None = None) -> Self: ...
    def about(self, x: Number, y: Number) -> Self: ...
    def inverse(self) -> Transform: ...
    def __mul__(self, other: Number) -> Transform: ...  # type: ignore[override]
    # Alias to __mul__ at runtime, but that confuses type checkers and stubtest
    def __rmul__(self, other: Number) -> Transform: ...  # type: ignore[override]
    def __matmul__(self, other: Transform) -> Self: ...
    def render(self, last_item: Renderable) -> tuple[str, Renderable]: ...
    def row_norms(self) -> tuple[float, float]: ...
