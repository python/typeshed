import sys
import xml.dom
from _typeshed import ReadableBuffer, SupportsRead, SupportsWrite, Unused
from collections.abc import Iterable, Sequence
from typing import NoReturn, TypeVar, overload
from typing_extensions import Literal, Self
from xml.dom import UserDataHandler
from xml.dom.minicompat import *
from xml.dom.xmlbuilder import DocumentLS, DOMImplementationLS
from xml.sax.xmlreader import XMLReader

_N = TypeVar("_N", bound=Node)

def parse(
    file: str | SupportsRead[ReadableBuffer | str], parser: XMLReader | None = None, bufsize: int | None = None
) -> Document: ...
def parseString(string: str | ReadableBuffer, parser: XMLReader | None = None) -> Document: ...
def getDOMImplementation(features: str | Iterable[tuple[str, str | None]] | None = None) -> DOMImplementation | None: ...

class Node(xml.dom.Node):
    parentNode: Node | None
    childNodes: NodeList
    nextSibling: Node | None
    previousSibling: Node | None
    ownerDocument: Document | None
    namespaceURI: str | None
    prefix: str | None
    # nodeType and attributes are part of the Node _interface_,
    # but are absent from the abstract class xml.dom.minidom.Node

    @property
    def firstChild(self) -> Node | None: ...
    @property
    def lastChild(self) -> Node | None: ...
    @property
    def localName(self) -> str | None: ...
    def __bool__(self) -> Literal[True]: ...
    if sys.version_info >= (3, 9):
        @overload
        def toxml(self, encoding: str, standalone: bool | None = None) -> bytes: ...
        @overload
        def toxml(self, encoding: None = None, standalone: bool | None = None) -> str: ...
        @overload
        def toprettyxml(
            self,
            indent: str = "\t",
            newl: str = "\n",
            # Handle any case where encoding is not provided or where it is passed with None
            encoding: None = None,
            standalone: bool | None = None,
        ) -> str: ...
        @overload
        def toprettyxml(
            self,
            indent: str,
            newl: str,
            # Handle cases where encoding is passed as str *positionally*
            encoding: str,
            standalone: bool | None = None,
        ) -> bytes: ...
        @overload
        def toprettyxml(
            self,
            indent: str = "\t",
            newl: str = "\n",
            # Handle all cases where encoding is passed as a keyword argument; because standalone
            # comes after, it will also have to be a keyword arg if encoding is
            *,
            encoding: str,
            standalone: bool | None = None,
        ) -> bytes: ...
    else:
        @overload
        def toxml(self, encoding: str) -> bytes: ...
        @overload
        def toxml(self, encoding: None = None) -> str: ...
        @overload
        def toprettyxml(
            self,
            indent: str = "\t",
            newl: str = "\n",
            # Handle any case where encoding is not provided or where it is passed with None
            encoding: None = None,
        ) -> str: ...
        @overload
        def toprettyxml(
            self,
            indent: str,
            newl: str,
            # Handle cases where encoding is passed as str *positionally*
            encoding: str,
        ) -> bytes: ...
        @overload
        def toprettyxml(
            self,
            indent: str = "\t",
            newl: str = "\n",
            # Handle all cases where encoding is passed as a keyword argument
            *,
            encoding: str,
        ) -> bytes: ...

    def hasChildNodes(self) -> bool: ...
    def insertBefore(self, newChild: _N, refChild: Node) -> _N: ...
    def appendChild(self, node: _N) -> _N: ...
    def replaceChild(self, newChild: Node, oldChild: _N) -> _N: ...
    def removeChild(self, oldChild: _N) -> _N: ...
    def normalize(self) -> None: ...
    def cloneNode(self, deep: bool) -> Self: ...
    def isSupported(self, feature: str, version: str | None) -> bool: ...
    def isSameNode(self, other: Node) -> bool: ...
    def getInterface(self, feature: str) -> Self | None: ...
    def getUserData(self, key: str) -> object: ...
    def setUserData(self, key: str, data: object, handler: UserDataHandler) -> object | None: ...
    def unlink(self) -> None: ...
    def __enter__(self) -> Self: ...
    def __exit__(self, et: Unused, ev: Unused, tb: Unused) -> None: ...

class DocumentFragment(Node):
    nodeType: int
    nodeName: str
    nodeValue: None
    attributes: None
    parentNode: None
    childNodes: NodeList
    def __init__(self) -> None: ...

class Attr(Node):
    name: str
    nodeType: int
    attributes: None
    specified: bool
    ownerElement: Element | None
    namespaceURI: str | None
    childNodes: NodeList
    nodeName: str
    nodeValue: str | None
    value: str
    prefix: str | None
    def __init__(
        self, qName: str, namespaceURI: str | None = None, localName: str | None = None, prefix: str | None = None
    ) -> None: ...
    def unlink(self) -> None: ...
    @property
    def isId(self) -> bool: ...
    @property
    def schemaType(self) -> TypeInfo: ...

class NamedNodeMap:
    def __init__(self, attrs: dict[str, Attr], attrsNS: dict[tuple[str, str], Attr], ownerElement: Node) -> None: ...
    def item(self, index: int) -> Attr: ...
    def items(self) -> Sequence[tuple[str, str | None]]: ...
    def itemsNS(self) -> Sequence[tuple[tuple[str, str], str | None]]: ...
    def __contains__(self, key: str | tuple[str, str]) -> bool: ...
    def keys(self) -> Iterable[str]: ...
    def keysNS(self) -> Iterable[tuple[str, str]]: ...
    def values(self) -> Iterable[Attr]: ...
    def get(self, name: str, value: str | None = None) -> str | None: ...
    def __len__(self) -> int: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: NamedNodeMap) -> bool: ...
    def __gt__(self, other: NamedNodeMap) -> bool: ...
    def __le__(self, other: NamedNodeMap) -> bool: ...
    def __lt__(self, other: NamedNodeMap) -> bool: ...
    def __getitem__(self, attname_or_tuple: tuple[str, str | None] | str) -> Attr: ...
    def __setitem__(self, attname: str, value: Attr | str) -> None: ...
    def getNamedItem(self, name: str) -> Attr | None: ...
    def getNamedItemNS(self, namespaceURI: str, localName: str | None) -> Attr | None: ...
    def removeNamedItem(self, name: str) -> Attr: ...
    def removeNamedItemNS(self, namespaceURI: str, localName: str | None) -> Attr: ...
    def setNamedItem(self, node: Attr) -> Attr: ...
    def setNamedItemNS(self, node: Attr) -> Attr: ...
    def __delitem__(self, attname_or_tuple: tuple[str, str | None] | str) -> None: ...
    @property
    def length(self) -> int: ...

AttributeList = NamedNodeMap

class TypeInfo:
    namespace: str | None
    name: str
    def __init__(self, namespace: str | None, name: str) -> None: ...

class Element(Node):
    nodeType: int
    nodeValue: None
    schemaType: TypeInfo
    tagName: str
    nodeName: str

    def __init__(
        self, tagName: str, namespaceURI: str | None = None, prefix: str | None = None, localName: str | None = None
    ) -> None: ...
    def unlink(self) -> None: ...
    def getAttribute(self, attname: str) -> str: ...
    def getAttributeNS(self, namespaceURI: str, localName: str) -> str: ...
    def setAttribute(self, attname: str, value: str) -> None: ...
    def setAttributeNS(self, namespaceURI: str, qualifiedName: str, value: str) -> None: ...
    def getAttributeNode(self, attrname: str) -> Attr: ...
    def getAttributeNodeNS(self, namespaceURI: str, localName: str) -> Attr: ...
    def setAttributeNode(self, attr: Attr) -> Attr: ...
    def setAttributeNodeNS(self, attr: Attr) -> Attr: ...
    def removeAttribute(self, name: str) -> None: ...
    def removeAttributeNS(self, namespaceURI: str, localName: str) -> None: ...
    def removeAttributeNode(self, node: Attr) -> Attr: ...
    def removeAttributeNodeNS(self, node: Attr) -> Attr: ...
    def hasAttribute(self, name: str) -> bool: ...
    def hasAttributeNS(self, namespaceURI: str, localName: str) -> bool: ...
    def getElementsByTagName(self, name: str) -> NodeList[Element]: ...
    def getElementsByTagNameNS(self, namespaceURI: str, localName: str) -> NodeList[Element]: ...
    def writexml(self, writer: SupportsWrite[str], indent: str = "", addindent: str = "", newl: str = "") -> None: ...
    def hasAttributes(self) -> bool: ...
    def setIdAttribute(self, name: str) -> None: ...
    def setIdAttributeNS(self, namespaceURI: str, localName: str) -> None: ...
    def setIdAttributeNode(self, idAttr: Attr) -> None: ...
    @property
    def attributes(self) -> NamedNodeMap: ...

class Childless:
    attributes: None
    childNodes: NodeList
    firstChild: None
    lastChild: None
    def appendChild(self, node: Node) -> NoReturn: ...
    def hasChildNodes(self) -> Literal[False]: ...
    def insertBefore(self, newChild: Node, refChild: Node) -> NoReturn: ...
    def removeChild(self, oldChild: Node) -> NoReturn: ...
    def normalize(self) -> None: ...
    def replaceChild(self, newChild: Node, oldChild: Node) -> NoReturn: ...

class ProcessingInstruction(Childless, Node):
    nodeType: int
    target: str
    data: str
    def __init__(self, target: str, data: str) -> None: ...
    nodeValue: str
    nodeName: str
    def writexml(self, writer: SupportsWrite[str], indent: str = "", addindent: str = "", newl: str = "") -> None: ...

class CharacterData(Childless, Node):
    data: str
    nodeValue: str

    def __init__(self) -> None: ...
    def __len__(self) -> int: ...
    def substringData(self, offset: int, count: int) -> str: ...
    def appendData(self, arg: str) -> None: ...
    def insertData(self, offset: int, arg: str) -> None: ...
    def deleteData(self, offset: int, count: int) -> None: ...
    def replaceData(self, offset: int, count: int, arg: str) -> None: ...
    @property
    def length(self) -> int: ...

class Text(CharacterData):
    nodeType: int
    nodeName: str

    def splitText(self, offset: int) -> Self: ...
    def writexml(self, writer: SupportsWrite[str], indent: str = "", addindent: str = "", newl: str = "") -> None: ...
    def replaceWholeText(self, content: str) -> Self: ...
    @property
    def isWhitespaceInElementContent(self) -> bool: ...
    @property
    def wholeText(self) -> str: ...

class Comment(CharacterData):
    nodeType: int
    nodeName: str
    def __init__(self, data: str) -> None: ...
    def writexml(self, writer: SupportsWrite[str], indent: str = "", addindent: str = "", newl: str = "") -> None: ...

class CDATASection(Text):
    nodeType: int
    nodeName: str
    def writexml(self, writer: SupportsWrite[str], indent: str = "", addindent: str = "", newl: str = "") -> None: ...

class ReadOnlySequentialNamedNodeMap:
    def __init__(self, seq: Sequence[Node] = ()) -> None: ...
    def __len__(self) -> int: ...
    def getNamedItem(self, name: str) -> Node: ...
    def getNamedItemNS(self, namespaceURI: str, localName: str) -> Node: ...
    def __getitem__(self, name_or_tuple: tuple[str, str] | str) -> Node: ...
    def item(self, index: int) -> Node: ...
    def removeNamedItem(self, name: str) -> NoReturn: ...
    def removeNamedItemNS(self, namespaceURI: str, localName: str) -> NoReturn: ...
    def setNamedItem(self, node: Node) -> NoReturn: ...
    def setNamedItemNS(self, node: Node) -> NoReturn: ...
    @property
    def length(self) -> int: ...

class Identified:
    publicId: str | None
    systemId: str | None

class DocumentType(Identified, Childless, Node):
    nodeType: int
    nodeValue: None
    name: str | None
    internalSubset: str | None
    entities: ReadOnlySequentialNamedNodeMap
    notations: ReadOnlySequentialNamedNodeMap
    nodeName: str
    def __init__(self, qualifiedName: str) -> None: ...
    def writexml(self, writer: SupportsWrite[str], indent: str = "", addindent: str = "", newl: str = "") -> None: ...

class Entity(Identified, Node):
    attributes: None
    nodeType: int
    nodeValue: None
    actualEncoding: str | None
    encoding: str | None
    version: str | None
    nodeName: str
    notationName: str

    def __init__(self, name: str, publicId: str, systemId: str, notation: str) -> None: ...
    def appendChild(self, newChild: Node) -> NoReturn: ...
    def insertBefore(self, newChild: Node, refChild: Node) -> NoReturn: ...
    def removeChild(self, oldChild: Node) -> NoReturn: ...
    def replaceChild(self, newChild: Node, oldChild: Node) -> NoReturn: ...

class Notation(Identified, Childless, Node):
    nodeType: int
    nodeValue: None
    nodeName: str
    def __init__(self, name: str, publicId: str, systemId: str) -> None: ...

class DOMImplementation(DOMImplementationLS):
    def hasFeature(self, feature: str, version: str | None) -> bool: ...
    def createDocument(self, namespaceURI: str | None, qualifiedName: str | None, doctype: DocumentType | None) -> Document: ...
    def createDocumentType(self, qualifiedName: str | None, publicId: str, systemId: str) -> DocumentType: ...
    def getInterface(self, feature: str) -> Self | None: ...

class ElementInfo:
    tagName: str
    def __init__(self, name: str) -> None: ...
    def getAttributeType(self, aname: str) -> TypeInfo: ...
    def getAttributeTypeNS(self, namespaceURI: str, localName: str) -> TypeInfo: ...
    def isElementContent(self) -> bool: ...
    def isEmpty(self) -> bool: ...
    def isId(self, aname: str) -> bool: ...
    def isIdNS(self, namespaceURI: str, localName: str) -> bool: ...

class Document(Node, DocumentLS):
    implementation: DOMImplementation
    nodeType: int
    nodeName: str
    nodeValue: None
    attributes: None
    parentNode: None
    previousSibling: None
    nextSibling: None
    actualEncoding: str | None
    encoding: str | None
    standalone: bool | None
    version: str | None
    strictErrorChecking: bool
    errorHandler: None
    documentURI: str | None
    doctype: DocumentType | None
    childNodes: NodeList
    documentElement: Element

    def __init__(self) -> None: ...
    def unlink(self) -> None: ...
    def cloneNode(self, deep: bool) -> Self: ...
    def createDocumentFragment(self) -> DocumentFragment: ...
    def createElement(self, tagName: str) -> Element: ...
    def createTextNode(self, data: str) -> Text: ...
    def createCDATASection(self, data: str) -> CDATASection: ...
    def createComment(self, data: str) -> Comment: ...
    def createProcessingInstruction(self, target: str, data: str) -> ProcessingInstruction: ...
    def createAttribute(self, qName: str) -> Attr: ...
    def createElementNS(self, namespaceURI: str, qualifiedName: str) -> Element: ...
    def createAttributeNS(self, namespaceURI: str, qualifiedName: str) -> Attr: ...
    def getElementById(self, id: str) -> Element | None: ...
    def getElementsByTagName(self, name: str) -> NodeList[Element]: ...
    def getElementsByTagNameNS(self, namespaceURI: str, localName: str) -> NodeList[Element]: ...
    def isSupported(self, feature: str, version: str | None) -> bool: ...
    def importNode(self, node: _N, deep: bool) -> _N: ...
    if sys.version_info >= (3, 9):
        def writexml(
            self,
            writer: SupportsWrite[str],
            indent: str = "",
            addindent: str = "",
            newl: str = "",
            encoding: str | None = None,
            standalone: bool | None = None,
        ) -> None: ...
    else:
        def writexml(
            self, writer: SupportsWrite[str], indent: str = "", addindent: str = "", newl: str = "", encoding: str | None = None
        ) -> None: ...

    def renameNode(self, n: _N, namespaceURI: str, name: str) -> _N: ...
