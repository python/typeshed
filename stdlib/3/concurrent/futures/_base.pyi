# Stubs for concurrent.futures._base (Python 3.5)
#
# NOTE: This dynamically typed stub was automatically generated by stubgen.

from typing import Any
from collections import namedtuple

FIRST_COMPLETED = ... # type: Any
FIRST_EXCEPTION = ... # type: Any
ALL_COMPLETED = ... # type: Any
PENDING = ... # type: Any
RUNNING = ... # type: Any
CANCELLED = ... # type: Any
CANCELLED_AND_NOTIFIED = ... # type: Any
FINISHED = ... # type: Any
LOGGER = ... # type: Any

class Error(Exception): ...
class CancelledError(Error): ...
class TimeoutError(Error): ...

class _Waiter:
    event = ... # type: Any
    finished_futures = ... # type: Any
    def __init__(self): ...
    def add_result(self, future): ...
    def add_exception(self, future): ...
    def add_cancelled(self, future): ...

class _AsCompletedWaiter(_Waiter):
    lock = ... # type: Any
    def __init__(self): ...
    def add_result(self, future): ...
    def add_exception(self, future): ...
    def add_cancelled(self, future): ...

class _FirstCompletedWaiter(_Waiter):
    def add_result(self, future): ...
    def add_exception(self, future): ...
    def add_cancelled(self, future): ...

class _AllCompletedWaiter(_Waiter):
    num_pending_calls = ... # type: Any
    stop_on_exception = ... # type: Any
    lock = ... # type: Any
    def __init__(self, num_pending_calls, stop_on_exception): ...
    def add_result(self, future): ...
    def add_exception(self, future): ...
    def add_cancelled(self, future): ...

class _AcquireFutures:
    futures = ... # type: Any
    def __init__(self, futures): ...
    def __enter__(self): ...
    def __exit__(self, *args): ...

def as_completed(fs, timeout=None): ...

DoneAndNotDoneFutures = namedtuple('DoneAndNotDoneFutures', 'done not_done')

def wait(fs, timeout=None, return_when=...): ...

class Future:
    def __init__(self): ...
    def cancel(self): ...
    def cancelled(self): ...
    def running(self): ...
    def done(self): ...
    def add_done_callback(self, fn): ...
    def result(self, timeout=None): ...
    def exception(self, timeout=None): ...
    def set_running_or_notify_cancel(self): ...
    def set_result(self, result): ...
    def set_exception(self, exception): ...

class Executor:
    def submit(self, fn, *args, **kwargs): ...
    def map(self, fn, *iterables, *, timeout=None, chunksize=1): ...
    def shutdown(self, wait=True): ...
    def __enter__(self): ...
    def __exit__(self, exc_type, exc_val, exc_tb): ...
