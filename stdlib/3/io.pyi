# Stubs for io

from typing import (
    List, BinaryIO, TextIO, Iterator, Union, Optional, Callable, no_type_check
)
import builtins
import codecs
from types import TracebackType

DEFAULT_BUFFER_SIZE = ...  # type: int
SEEK_SET = ...  # type: int
SEEK_CUR = ...  # type: int
SEEK_END = ...  # type: int

open = builtins.open

class BlockingIOError(OSError): ...
class UnsupportedOperation(ValueError, OSError): ...


class IOBase:
    @property
    def close(self) -> None: ...
    def closed(self) -> bool: ...
    def fileno(self) -> int: ...
    def flush(self) -> None: ...
    def isatty(self) -> bool: ...
    def readable(self) -> bool: ...
    def readline(self, size: int = ...) -> bytes: ...
    def readlines(self, hint: int = ...) ->List[bytes]: ...
    def seek(self, offset: int, whence: int = ...) -> int: ...
    def seekable(self) -> bool: ...
    def tell(self) -> int: ...
    def truncate(self, size: int = ...) -> int: ...
    def writable(self) -> bool: ...
    def writelines(self, lines: bytes) -> None: ...
    def __del__(self) -> None: ...

    def __enter__(self) -> 'IOBase': ...
    def __exit__(self, exc_type: Optional[type], exc_val: Optional[Exception],
                 exc_tb: Optional[TracebackType]) -> bool: ...
    def __iter__(self) -> Iterator[bytes]: ...
    def __next__(self) -> bytes: ...

class RawIOBase(IOBase):
    def read(self, size: int = ...) -> Optional[bytes]: ...
    def readall(self) -> bytes: ...
    def readinto(self, b: bytearray) -> Optional[int]: ...
    def write(self, b: Union[bytes, bytearray]) -> Optional[int]: ...

class BufferedIOBase(IOBase):
    def detach(self) -> 'RawIOBase': ...
    def read(self, size: Optional[int] = ...) -> bytes: ...
    def read1(self, size: int = ...) -> bytes: ...
    def readinto(self, b: bytearray) -> int: ...
    def write(self, b: Union[bytes, bytearray]) -> int: ...


class FileIO(RawIOBase):
    mode = ...  # type: str
    name = ...  # type: Union[int, str]
    def __init__(self, name: Union[int, str], mode: str = ...,
                 closefd: bool = ...,
                 opener: Optional[Callable[[Union[int, str], int], Union[TextIO, BytesIO]]] = ...) -> None: ...


class BytesIO(BinaryIO):
    def __init__(self, initial_bytes: bytes = ...) -> None: ...
    def getbuffer(self) -> memoryview: ...
    def getvalue(self) -> bytes: ...
    def read1(self, size: int = ...) -> Optional[bytes]: ...
    def readinto1(self, b: bytearray) -> int: ...

class BufferedReader(BufferedIOBase):
    def __init__(self, raw: RawIOBase, buffer_size: int = ...) -> None: ...
    def peek(self, size: int = ...) -> bytes: ...
    def read(self, size: int = ...) -> bytes: ...
    def read1(self, size: int = ...) -> bytes: ...

class BufferedWriter(BufferedIOBase):
    def __init__(self, raw: RawIOBase, buffer_size: int = ...) -> None: ...
    def flush(self) -> None: ...
    def write(self, b: Union[bytes, bytearray]) -> int: ...

class BufferedRandom(BufferedReader, BufferedWriter):
    def __init__(self, raw: RawIOBase, buffer_size: int = ...) -> None: ...
    def seek(self, offset: int, whence: int = ...) -> int: ...
    def tell(self) -> int: ...

class BufferedRWPair(BufferedIOBase):
    def __init__(self, reader: RawIOBase, writer: RawIOBase,
                 buffer_size: int = ...) -> None: ...


class TextIOBase(IOBase):
    encoding = ...  # type: str
    errors = ...  # type: Optional[str]
    def detach(self) -> IOBase: ...
    def read(self, size: Optional[int] = ...) -> str: ...
    @no_type_check  # not same signature as parent
    def readline(self, size: int = ...) -> str: ...
    def seek(self, offset: int, whence: int = ...) -> int: ...
    def tell(self) -> int: ...
    def write(self, s: str) -> int: ...

class TextIOWrapper(TextIOBase):
    line_buffering = ...  # type: bool
    def __init__(self, buffer: BufferedIOBase, encoding: str = ...,
                 errors: str = ..., newline: Optional[str] = ...,
                 line_buffering: bool = ...,
                 write_through: bool = ...) -> None: ...

class StringIO(TextIOBase):
    def __init__(self, initial_value: str = ...,
                 newline: Optional[str] = ...) -> None: ...
    def getvalue(self) -> str: ...

class IncrementalNewlineDecoder(codecs.IncrementalDecoder): ...
