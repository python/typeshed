from typing import Callable, ContextManager, Optional, Union

from multiprocessing.context import BaseContext
import threading

class Barrier(threading.Barrier):
    def __init__(self,
                 parties: int,
                 action: Optional[Callable] = ...,
                 timeout: Optional[float] = ...) -> None: ...

class BoundedSemaphore(Semaphore):
    def __init__(self, value: int = ..., *, ctx: BaseContext) -> None: ...

_LockLike = Union[Lock, RLock]

class Condition(ContextManager[bool]):
    def __init__(self,
                 lock: Optional[_LockLike] = ...,
                 *,
                 ctx: BaseContext) -> None: ...
    def notify(self, n: int = ...) -> None: ...
    def notify_all(self) -> None: ...
    def wait(self, timeout: Optional[float] = ...) -> bool: ...
    def wait_for(self,
                 predicate: Callable[[], bool],
                 timeout: Optional[float] = ...) -> bool: ...

class Event(ContextManager[bool]):
    def __init__(self,
                 lock: Optional[_LockLike] = ...,
                 *,
                 ctx: BaseContext) -> None: ...
    def is_set(self) -> bool: ...
    def set(self) -> None: ...
    def clear(self) -> None: ...
    def wait(self, timeout: Optional[float] = ...) -> bool: ...

class Lock(SemLock):
    def __init__(self, *, ctx: BaseContext) -> None: ...

class RLock(SemLock):
    def __init__(self, *, ctx: BaseContext) -> None: ...

class Semaphore(SemLock):
    def __init__(self, value: int = ..., *, ctx: BaseContext) -> None: ...

# Not part of public API
class SemLock(ContextManager[bool]):
    def acquire(self,
                block: bool = ...,
                timeout: Optional[float] = ...) -> bool: ...
    def release(self) -> None: ...
