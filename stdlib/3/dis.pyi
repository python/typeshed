from typing import Any, List, Union, NamedTuple, Iterator, Tuple, IO, Optional, Dict

from opcode import cmp_op,hasconst ,hasname , hasjrel, hasjabs, haslocal, hascompare, hasfree, opname ,opmap ,HAVE_ARGUMENT, EXTENDED_ARG, hasnargs

import types

_have_code = Union[types.MethodType, types.FunctionType, types.CodeType, type]
_have_code_or_string = Union[str, bytes, types.MethodType, types.FunctionType, types.CodeType, type]

class Instruction(NamedTuple("Instruction", [
        ('opname', str),
        ('opcode', int),
        ('arg', Optional[int]),
        ('argval', Any),
        ('argrepr', str),
        ('offset', int),
        ('starts_line', Optional[int]),
        ('is_jump_target', bool)
    ])):
    # ad-hoc - seems to be an error in the NamedTuple type hint
    def _replace(self, **kwargs:Any) -> Instruction: ...
    def _fields(self) -> List[str]: ...


import sys
if sys.version_info >= (3, 4):
    class Bytecode:
        codeobj = ... # type: types.CodeType
        first_line = ... # type: int
        def __init__(self, x:_have_code_or_string, *, first_line:int=..., current_offset:int=...) -> None: ...
        def __iter__(self) -> Iterator[Instruction]: ...
        def __repr__(self) -> str: ...
        def info(self) -> str: ...
        def dis(self) -> str: ...
    
        @classmethod
        def from_traceback(cls, tb:types.TracebackType) -> Bytecode: ...
 
COMPILER_FLAG_NAMES = ... # type: Dict[int, str]


def pretty_flags(flags:int) -> str: ...
def findlabels(code:_have_code) -> List[int]: ...
def findlinestarts(code:_have_code) -> Iterator[Tuple[int, int]]: ...

if sys.version_info < (3, 4):
    # signature changes are not allowed by mypy
    #def dis(x:_have_code_or_string=...) -> None: ... 
    #def distb(tb:types.TracebackType=...) -> None: ... 
    #def disassemble(co:_have_code, lasti:int=...) -> None: ... 
    def dis(x:_have_code_or_string=..., *, file=...) -> None: ... # type: ignore
    def distb(tb:types.TracebackType=..., *, file:IO[str]=...) -> None: ... # type: ignore
    def disassemble(co:_have_code, lasti:int=..., *, file=None) -> None: ... # type: ignore

if  (3, 2) <= sys.version_info:
    def code_info(x:_have_code_or_string) -> str: ...
    
if  (3, 2) <= sys.version_info < (3, 4):
    #def show_code(co:_have_code, *, file:IO[str]=...) -> None: ... 
    def show_code(co:_have_code, *, file:IO[str]=...) -> None: ... # type: ignore

if sys.version_info >= (3, 4):
    def dis(x:_have_code_or_string=..., *, file=...) -> None: ...
    def distb(tb:types.TracebackType=..., *, file:IO[str]=...) -> None: ...
    def disassemble(co:_have_code, lasti:int=..., *, file=None) -> None: ...
    
    def show_code(co:_have_code, *, file:IO[str]=...) -> None: ...

    def get_instructions(x:_have_code, *, first_line:int=...) -> Iterator[Instruction]: ...
    def stack_effect(opcode: int, oparg:int=...) -> int: ...
