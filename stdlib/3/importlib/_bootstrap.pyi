# Stubs for importlib._bootstrap (Python 3.4)

from importlib.abc import Loader

from typing import (
    Any, Optional, Sequence, Callable, Iterator, Tuple, Iterable, Mapping, Union
)
from types import TracebackType, ModuleType, CodeType
import _thread
from ast import AST

class _ManageReload:
    def __init__(self, name: str) -> None: ...
    def __enter__(self) -> None: ...
    def __exit__(self, exc_type: Optional[type], exc_value:
                 Optional[BaseException], traceback: TracebackType) \
                 -> Optional[bool]: ...

class _DeadlockError(RuntimeError): ...

class _ModuleLock:
    lock = ... # type: _thread.LockType
    wakeup = ... # type: _thread.LockType
    name = ... # type: str
    owner = ... # type: Optional[int]
    count = ... # type: int
    waiters = ... # type: int
    def __init__(self, name: str) -> None: ...
    def has_deadlock(self) -> bool: ...
    def acquire(self) -> None: ...
    def release(self) -> None: ...

class _DummyModuleLock:
    name = ... # type: str
    count = ... # type: int
    def __init__(self, name: str) -> None: ...
    def acquire(self) -> None: ...
    def release(self) -> None: ...

class _ModuleLockManager:
    def __init__(self, name: str) -> None: ...
    def __enter__(self) -> None: ...
    def __exit__(self, exc_type: Optional[type], exc_value:
                 Optional[BaseException], traceback: TracebackType) \
                 -> Optional[bool]: ...

MAGIC_NUMBER = ... # type: bytes
SOURCE_SUFFIXES = ... # type: List[str]
DEBUG_BYTECODE_SUFFIXES = ... # type: List[str]
OPTIMIZED_BYTECODE_SUFFIXES = ... # type: List[str]

def cache_from_source(path: str, debug_override: Optional[bool] = ...) -> str: ...
def source_from_cache(path: str) -> str: ...
def decode_source(source_bytes: bytes) -> str: ...

class _installed_safely:
    def __init__(self, module: ModuleType) -> None: ...
    def __enter__(self) -> None: ...
    def __exit__(self, exc_type: Optional[type], exc_value:
                 Optional[BaseException], traceback: TracebackType) \
                 -> Optional[bool]: ...

# TODO find real type of loader_state
class ModuleSpec:
    name = ... # type: str
    loader = ... # type: Loader
    origin = ... # type: str
    loader_state = ... # type: Optional[Any]
    submodule_search_locations = ... # type: Sequence[str]
    def __init__(self, name: str, loader: Loader, *,
                 origin: Optional[str] = ..., loader_state: Optional[Any] = ...,
                 is_package: Optional[bool] = ...) -> None: ...
    def __eq__(self, other: Any) -> bool: ...
    @property
    def cached(self) -> Optional[str]: ...
    @cached.setter
    def cached(self, cached: Optional[str]) -> None: ...
    @property
    def parent(self) -> str: ...
    @property
    def has_location(self) -> bool: ...
    @has_location.setter
    def has_location(self, value: bool) -> None: ...

def spec_from_loader(name: str, loader: Loader, *, origin: Optional[str] = ...,
                     is_package: Optional[bool] = ...) -> ModuleSpec: ...
def spec_from_file_location(name: str, location: Optional[str] = ..., *,
                            loader: Optional[Loader] = ...,
                            submodule_search_locations: List[str] = ...) \
                            -> ModuleSpec: ...

class _SpecMethods:
    spec = ... # type: ModuleSpec
    def __init__(self, spec: ModuleSpec) -> None: ...
    def module_repr(self) -> str: ...
    def init_module_attrs(self, module: ModuleType, *, _override: bool = ...,
                          _force_name: bool = ...) -> None: ...
    def create(self) -> ModuleType: ...
    def exec(self, module: ModuleType) -> ModuleType: ...
    def load(self) -> ModuleType: ...

# TODO find real type of target
class BuiltinImporter:
    @staticmethod
    def module_repr(module: ModuleType) -> str: ...
    @classmethod
    def find_spec(cls, fullname: str, path: Optional[str] = ...,
                  target: Optional[Any] = ...) -> Optional[ModuleSpec]: ...
    @classmethod
    def find_module(cls, fullname: str, path: Optional[str] = ...) \
                    -> Optional[Loader]: ...
    @classmethod
    def load_module(cls, fullname: str) -> ModuleType: ...
    @classmethod
    def get_code(cls, fullname: str) -> None: ...
    @classmethod
    def get_source(cls, fullname: str) -> None: ...
    @classmethod
    def is_package(cls, fullname: str) -> bool: ...

class FrozenImporter:
    @staticmethod
    def module_repr(module: ModuleType) -> str: ...
    @classmethod
    def find_spec(cls, fullname: str, path: Optional[str] = ...,
                  target: Optional[Any] = ...) -> Optional[ModuleSpec]: ...
    @classmethod
    def find_module(cls, fullname: str, path: Optional[str] = ...) \
                    -> Optional[Loader]: ...
    @staticmethod
    def exec_module(module: ModuleType) -> None: ...
    @classmethod
    def load_module(cls, fullname: str) -> ModuleType: ...
    @classmethod
    def get_code(cls, fullname: str) -> CodeType: ...
    @classmethod
    def get_source(cls, fullname: str) -> None: ...
    @classmethod
    def is_package(cls, fullname: str) -> bool: ...

class WindowsRegistryFinder:
    REGISTRY_KEY = ... # type: str
    REGISTRY_KEY_DEBUG = ... # type: str
    DEBUG_BUILD = ... # type: bool
    @classmethod
    def find_spec(cls, fullname: str, path: Optional[str] = ...,
                  target: Optional[Any] = ...) -> Optional[ModuleSpec]: ...
    @classmethod
    def find_module(cls, fullname: str, path: Optional[str] = ...) \
                    -> Optional[Loader]: ...

class _LoaderBasics:
    def is_package(cls, fullname: str) -> bool: ...
    def exec_module(module: ModuleType) -> bool: ...
    # TODO should be an object
    def load_module(self, fullname: str) -> ModuleType: ...

class SourceLoader(_LoaderBasics):
    def path_mtime(self, path: str) -> int: ...
    def path_stats(self, path: str) -> Dict[str, int]: ...
    def set_data(self, path: str, data: bytes) -> None: ...
    def get_source(self, fullname: str) -> str: ...
    def source_to_code(self, data: Union[str, bytes, AST], path: str, *,
                       _optimize: int = ...) -> CodeType: ...
    def get_code(self, fullname: str) -> CodeType: ...

class FileLoader:
    name = ... # type: str
    path = ... # type: str
    def __init__(self, fullname: str, path: str) -> None: ...
    def __eq__(self, other: Any) -> bool: ...
    def __hash__(self) -> int: ...
    def load_module(self, fullname: str) -> ModuleType: ...
    def get_filename(self, fullname: str) -> str: ...
    def get_data(self, path: str) -> bytes: ...

class SourceFileLoader(FileLoader, SourceLoader):
    def set_data(self, path: str, data: bytes, *, _mode: int = ...) -> None: ...

class SourcelessFileLoader(FileLoader, _LoaderBasics):
    def get_code(self, fullname: str) -> CodeType: ...
    def get_source(self, fullname: str) -> str: ...

EXTENSION_SUFFIXES = ... # type: List[str]

class ExtensionFileLoader:
    name = ... # type: str
    path = ... # type: str
    def __init__(self, name: str, path: List[str]) -> None: ...
    def __eq__(self, other: Any) -> bool: ...
    def __hash__(self) -> int: ...
    def load_module(self, fullname: str) -> ModuleType: ...
    def is_package(cls, fullname: str) -> bool: ...
    def get_code(self, fullname: str) -> None: ...
    def get_source(self, fullname: str) -> None: ...
    def get_filename(self, fullname: str) -> str: ...

class _NamespacePath:
    def __init__(self, name: str, path: str,
                 path_finder: Callable[[str, Tuple[str]], ModuleSpec]) \
                 -> None: ...
    def __iter__(self) -> Iterator[str]: ...
    def __len__(self) -> int: ...
    def __contains__(self, item: str) -> bool: ...
    def append(self, item: str) -> None: ...

class _NamespaceLoader:
    def __init__(self, name: str, path: str,
                 path_finder: Callable[[str, Tuple[str]], ModuleSpec]) \
                 -> None: ...
    @classmethod
    def module_repr(self) -> str: ...
    def is_package(cls, fullname: str) -> bool: ...
    def get_source(self, fullname: str) -> None: ...
    def get_code(self, fullname: str) -> None: ...
    def exec_module(module: ModuleType) -> None: ...
    def load_module(self, fullname: str) -> ModuleType: ...

class PathFinder:
    @classmethod
    def invalidate_caches(cls) -> None: ...
    @classmethod
    def find_spec(cls, fullname: str, path: Optional[str] = ...,
                  target: Optional[Any] = ...) -> Optional[ModuleSpec]: ...
    @classmethod
    def find_module(cls, fullname: str, path: Optional[str] = ...) \
                    -> Optional[Loader]: ...

# TODO find real type of target
class FileFinder:
    path = ... # type: str
    def __init__(self, path: str,
                 *loader_details: Tuple[Loader, Iterable[str]]) -> None: ...
    def invalidate_caches(self) -> None: ...
    # TODO should be an object
    def find_module(cls, fullname: str, path: Optional[str] = ...) \
                    -> Optional[Loader]: ...
    def find_loader(self, fullname: str) -> Tuple[Optional[Loader], List[str]]:
        ...
    def find_spec(self, fullname: str, target: Optional[Any] = ...) \
                  -> Optional[ModuleSpec]: ...
    @classmethod
    def path_hook(cls, *loader_details: Tuple[Loader, Iterable[str]]) \
                  -> Callable[[str], 'FileFinder']: ...

class _ImportLockContext:
    def __enter__(self) -> None: ...
    def __exit__(self, exc_type: Optional[type], exc_value:
                 Optional[BaseException], traceback: TracebackType) \
                 -> Optional[bool]: ...

def _calc___package__(globals: Mapping[str, Optional[str]]) -> str: ...
# TODO find real type of locals
def __import__(name: str, globals: Optional[Mapping[str, Optional[str]]] = ...,
               locals: Optional[Any] = ..., fromlist: List[str] = ...,
               level: int = ...) -> ModuleType: ...

BYTECODE_SUFFIXES = ... # type: str
