import email.message
import io
import types
from typing import (
    Any,
    Generic,
    Iterable,
    List,
    Optional,
    Protocol,
    Tuple,
    Type,
    TypeVar,
    Union,
    overload,
)

_Key = str
_FlagStr = str

_T = TypeVar("_T")

class _Readable(Protocol):
    def read(self, __n: int = ...) -> bytes: ...

class _ReadableBinaryFile(Protocol):
    def read(self, size: int = ...) -> bytes: ...
    def read1(self, size: int = ...) -> bytes: ...
    def readline(self, size: int = ...) -> bytes: ...
    def readlines(self, hint: int = ...) -> List[bytes]: ...
    def __iter__(self) -> Iterable[bytes]: ...
    def tell(self) -> int: ...
    def seek(self, offset: int, whence: int = ...) -> None: ...
    def close(self) -> None: ...
    def __enter__(self) -> _ReadableBinaryFile: ...
    def __exit__(
        self,
        exc_type: Optional[Type[BaseException]],
        exc_val: Optional[BaseException],
        exc_tb: Optional[types.TracebackType],
    ) -> Optional[bool]: ...
    def readable(self) -> bool: ...
    def writable(self) -> bool: ...
    def seekable(self) -> bool: ...
    def flush(self) -> None: ...
    @property
    def closed(self) -> bool: ...

_SrcMsg = Union[email.message.Message, bytes, str, io.TextIOWrapper, _Readable]

class Message(email.message.Message):
    def __init__(self, message: Optional[_SrcMsg] = ...) -> None: ...

_M = TypeVar("_M", bound=Message, covariant=True)

_KT = TypeVar("_KT", covariant=True)
_VT = TypeVar("_VT", covariant=True)

class _HasIteritems(Protocol[_KT, _VT]):
    def iteritems(self) -> Iterable[Tuple[_KT, _VT]]: ...

class _HasItems(Protocol[_KT, _VT]):
    def items(self) -> Iterable[Tuple[_KT, _VT]]: ...

class _Factory(Protocol[_M]):
    def __call__(self, __f: _Readable) -> _M: ...

class Mailbox(Generic[_M]):
    @overload
    def __init__(
        self: Mailbox[Message], path: str, *, create: bool = ...
    ) -> None: ...
    @overload
    def __init__(
        self: Mailbox[_M], path: str, factory: _Factory[_M], create: bool = ...
    ) -> None: ...
    def add(self, message: _SrcMsg) -> _Key: ...
    def remove(self, key: _Key) -> None: ...
    def __delitem__(self, key: _Key) -> None: ...
    def discard(self, key: _Key) -> None: ...
    def __setitem__(self, key: _Key, message: _SrcMsg) -> None: ...
    @overload
    def get(self, key: _Key) -> Optional[_M]: ...
    @overload
    def get(self, key: _Key, default: _T) -> Union[_M, _T]: ...
    def __getitem__(self, key: _Key) -> _M: ...
    def get_message(self, key: _Key) -> _M: ...
    def get_string(self, key: _Key) -> str: ...
    def get_bytes(self, key: _Key) -> bytes: ...
    def get_file(self, key: _Key) -> _ReadableBinaryFile: ...
    def iterkeys(self) -> Iterable[_Key]: ...
    def keys(self) -> List[_Key]: ...
    def itervalues(self) -> Iterable[_M]: ...
    def __iter__(self) -> Iterable[_M]: ...
    def values(self) -> List[_M]: ...
    def iteritems(self) -> Iterable[Tuple[_Key, _M]]: ...
    def items(self) -> List[Tuple[_Key, _M]]: ...
    def __contains__(self, key: _Key) -> bool: ...
    def __len__(self) -> int: ...
    def clear(self) -> None: ...
    @overload
    def pop(self, key: _Key) -> Optional[_M]: ...
    @overload
    def pop(self, key: _Key, default: _T) -> Union[_M, _T]: ...
    def popitem(self) -> Tuple[_Key, _M]: ...
    def update(
        self,
        arg: Union[
            _HasIteritems[_Key, _M],
            _HasItems[_Key, _M],
            Iterable[Tuple[_Key, _M]],
        ],
    ) -> None: ...
    def flush(self) -> None: ...
    def lock(self) -> None: ...
    def unlock(self) -> None: ...
    def close(self) -> None: ...

class MaildirMessage(Message):
    def __init__(self, message: Optional[_SrcMsg] = ...) -> None: ...
    def get_subdir(self) -> str: ...
    def set_subdir(self, subdir: str) -> None: ...
    def get_flags(self) -> _FlagStr: ...
    def set_flags(self, flags: _FlagStr) -> None: ...
    def add_flag(self, flag: _FlagStr) -> None: ...
    def remove_flag(self, flag: _FlagStr) -> None: ...
    def get_date(self) -> float: ...
    def set_date(self, date: float) -> None: ...
    def get_info(self) -> str: ...
    def set_info(self, info: str) -> None: ...

_MM = TypeVar("_MM", bound=MaildirMessage)

class Maildir(Mailbox[_MM]):
    @overload
    def __init__(
        self: Maildir[MaildirMessage], dirname: str, *, create: bool = ...
    ) -> None: ...
    @overload
    def __init__(
        self: Maildir[_MM],
        dirname: str,
        factory: _Factory[_MM],
        create: bool = ...,
    ) -> None: ...
    def list_folders(self) -> List[str]: ...
    def get_folder(self, folder: str) -> Maildir[_MM]: ...
    def add_folder(self, folder: str) -> Maildir[_MM]: ...
    def remove_folder(self, folder: str) -> None: ...
    def clean(self) -> None: ...
    def next(self) -> Optional[_MM]: ...

class _mboxMMDFMessage(Message):
    def __getattr__(self, name: str) -> Any: ...  # incomplete

class mboxMessage(_mboxMMDFMessage):
    def __getattr__(self, name: str) -> Any: ...  # incomplete

_mboxM = TypeVar("_mboxM", bound=mboxMessage)

class _singlefileMailbox(Mailbox[_M]):
    def __getattr__(self, name: str) -> Any: ...  # incomplete

class _mboxMMDF(_singlefileMailbox[_M]):
    def __getattr__(self, name: str) -> Any: ...  # incomplete

class mbox(_mboxMMDF[_mboxM]):
    def __getattr__(self, name: str) -> Any: ...  # incomplete

class MMDFMessage(_mboxMMDFMessage):
    def __getattr__(self, name: str) -> Any: ...  # incomplete

_MmdfM = TypeVar("_MmdfM", bound=MMDFMessage)

class MMDF(_mboxMMDF[_MmdfM]):
    def __getattr__(self, name: str) -> Any: ...  # incomplete

class MHMessage(Message):
    def __getattr__(self, name: str) -> Any: ...  # incomplete

_MhM = TypeVar("_MhM", bound=MHMessage)

class MH(Mailbox[_MhM]):
    def __getattr__(self, name: str) -> Any: ...  # incomplete

class BabylMessage(Message):
    def __getattr__(self, name: str) -> Any: ...  # incomplete

_BM = TypeVar("_BM", bound=BabylMessage)

class Babyl(_singlefileMailbox[_BM]):
    def __getattr__(self, name: str) -> Any: ...  # incomplete

class Error(Exception): ...
class NoSuchMailboxError(Error): ...
class NotEmptyError(Error): ...
class ExternalClashError(Error): ...
class FormatError(Error): ...
