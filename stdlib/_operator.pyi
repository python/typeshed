import sys
from typing import (
    AbstractSet,
    Any,
    AnyStr,
    Callable,
    Container,
    Generic,
    Iterable,
    Mapping,
    MutableMapping,
    MutableSequence,
    NoReturn,
    Protocol,
    Sequence,
    SupportsAbs,
    Tuple,
    TypeVar,
    overload,
)
from typing_extensions import ParamSpec, SupportsIndex, final

_R = TypeVar("_R")
_R_co = TypeVar("_R_co", covariant=True)
_T = TypeVar("_T")
_T_co = TypeVar("_T_co", covariant=True)
_K = TypeVar("_K")
_V = TypeVar("_V")
_P = ParamSpec("_P")
_X = TypeVar("_X", contravariant=True)

class _SupportsLessThanX(Protocol[_X]):
    def __lt__(self, other: _X) -> bool: ...

class _SupportsGreaterThanX(Protocol[_X]):
    def __gt__(self, other: _X) -> bool: ...

class _SupportsLessThanOrEqualToX(Protocol[_X]):
    def __le__(self, other: _X) -> bool: ...

class _SupportsGreaterThanOrEqualToX(Protocol[_X]):
    def __ge__(self, other: _X) -> bool: ...

class _SupportsAddWithX(Protocol[_X]):
    def __add__(self, other: _X) -> Any: ...

class _SupportsRAddWithX(Protocol[_X]):
    def __radd__(self, other: _X) -> Any: ...

class _SupportsAndWithX(Protocol[_X]):
    def __and__(self, other: _X) -> Any: ...

class _SupportsRAndWithX(Protocol[_X]):
    def __rand__(self, other: _X) -> Any: ...

class _SupportsTrueDivWithX(Protocol[_X]):
    def __truediv__(self, other: _X) -> Any: ...

class _SupportsRTrueDivWithX(Protocol[_X]):
    def __rtruediv__(self, other: _X) -> Any: ...

class _SupportsFloorDivWithX(Protocol[_X]):
    def __floordiv__(self, other: _X) -> Any: ...

class _SupportsRFloorDivWithX(Protocol[_X]):
    def __rfloordiv__(self, other: _X) -> Any: ...

class _SupportsLShiftWithX(Protocol[_X]):
    def __lshift__(self, other: _X) -> Any: ...

class _SupportsRLShiftWithX(Protocol[_X]):
    def __rlshift__(self, other: _X) -> Any: ...

class _SupportsModWithX(Protocol[_X]):
    def __mod__(self, other: _X) -> Any: ...

class _SupportsRModWithX(Protocol[_X]):
    def __rmod__(self, other: _X) -> Any: ...

class _SupportsMulWithX(Protocol[_X]):
    def __mul__(self, other: _X) -> Any: ...

class _SupportsRMulWithX(Protocol[_X]):
    def __rmul__(self, other: _X) -> Any: ...

class _SupportsMatMulWithX(Protocol[_X]):
    def __matmul__(self, other: _X) -> Any: ...

class _SupportsRMatMulWithX(Protocol[_X]):
    def __rmatmul__(self, other: _X) -> Any: ...

class _SupportsOrWithX(Protocol[_X]):
    def __or__(self, other: _X) -> Any: ...

class _SupportsROrWithX(Protocol[_X]):
    def __ror__(self, other: _X) -> Any: ...

class _SupportsRShiftWithX(Protocol[_X]):
    def __rshift__(self, other: _X) -> Any: ...

class _SupportsRRShiftWithX(Protocol[_X]):
    def __rrshift__(self, other: _X) -> Any: ...

class _SupportsSubWithX(Protocol[_X]):
    def __sub__(self, other: _X) -> Any: ...

class _SupportsRSubWithX(Protocol[_X]):
    def __rsub__(self, other: _X) -> Any: ...

class _SupportsXOrWithX(Protocol[_X]):
    def __xor__(self, other: _X) -> Any: ...

class _SupportsRXOrWithX(Protocol[_X]):
    def __rxor__(self, other: _X) -> Any: ...

class _SupportsInv(Protocol[_R_co]):
    def __inv__(self) -> _R_co: ...

class _SupportsNeg(Protocol[_R_co]):
    def __neg__(self) -> _R_co: ...

class _SupportsPos(Protocol[_R_co]):
    def __pos__(self) -> _R_co: ...

class _Unhashable(Protocol):
    __hash__: None  # type: ignore[assignment]

@overload
def lt(__a: _SupportsLessThanX[_X], __b: _X) -> bool: ...
@overload
def lt(__a: _X, __b: _SupportsGreaterThanX[_X]) -> bool: ...
@overload
def le(__a: _SupportsLessThanOrEqualToX[_X], __b: _X) -> bool: ...
@overload
def le(__a: _X, __b: _SupportsGreaterThanOrEqualToX[_X]) -> bool: ...
@overload
def ge(__a: _SupportsGreaterThanOrEqualToX[_X], __b: _X) -> bool: ...
@overload
def ge(__a: _X, __b: _SupportsLessThanOrEqualToX[_X]) -> bool: ...
@overload
def gt(__a: _SupportsGreaterThanX[_X], __b: _X) -> bool: ...
@overload
def gt(__a: _X, __b: _SupportsGreaterThanX[_X]) -> bool: ...
def eq(__a: object, __b: object) -> bool: ...
def ne(__a: object, __b: object) -> bool: ...
def not_(__a: object) -> bool: ...
def truth(__a: object) -> bool: ...
def is_(__a: object, __b: object) -> bool: ...
def is_not(__a: object, __b: object) -> bool: ...
def abs(__a: SupportsAbs[_T]) -> _T: ...
@overload
def add(__a: _SupportsAddWithX[_X], __b: _X) -> Any: ...
@overload
def add(__a: _X, __b: _SupportsRAddWithX[_X]) -> Any: ...
@overload
def and_(__a: _SupportsAndWithX[_X], __b: _X) -> Any: ...
@overload
def and_(__a: _X, __b: _SupportsRAndWithX[_X]) -> Any: ...
@overload
def floordiv(__a: _SupportsFloorDivWithX[_X], __b: _X) -> Any: ...
@overload
def floordiv(__a: _X, __b: _SupportsRFloorDivWithX[_X]) -> Any: ...
def index(__a: SupportsIndex) -> int: ...
def inv(__a: _SupportsInv[_R_co]) -> _R_co: ...
def invert(__a: _SupportsInv[_R_co]) -> _R_co: ...
@overload
def lshift(__a: _SupportsLShiftWithX[_X], __b: _X) -> Any: ...
@overload
def lshift(__a: _X, __b: _SupportsRLShiftWithX[_X]) -> Any: ...
@overload
def mod(__a: _SupportsModWithX[_X], __b: _X) -> Any: ...
@overload
def mod(__a: _X, __b: _SupportsRModWithX[_X]) -> Any: ...
@overload
def mul(__a: _SupportsMulWithX[_X], __b: _X) -> Any: ...
@overload
def mul(__a: _X, __b: _SupportsRMulWithX[_X]) -> Any: ...
@overload
def matmul(__a: _SupportsMatMulWithX[_X], __b: _X) -> Any: ...
@overload
def matmul(__a: _X, __b: _SupportsRMatMulWithX[_X]) -> Any: ...
def neg(__a: _SupportsNeg[_R_co]) -> _R_co: ...
@overload
def or_(__a: _SupportsOrWithX[_X], __b: _X) -> Any: ...
@overload
def or_(__a: _X, __b: _SupportsROrWithX[_X]) -> Any: ...
def pos(__a: _SupportsPos[_R_co]) -> _R_co: ...
def pow(__a: Any, __b: Any) -> Any: ...
@overload
def rshift(__a: _SupportsRShiftWithX[_X], __b: _X) -> Any: ...
@overload
def rshift(__a: _X, __b: _SupportsRRShiftWithX[_X]) -> Any: ...
@overload
def sub(__a: _SupportsSubWithX[_X], __b: _X) -> Any: ...
@overload
def sub(__a: _X, __b: _SupportsRSubWithX[_X]) -> Any: ...
@overload
def truediv(__a: _SupportsTrueDivWithX[_X], __b: _X) -> Any: ...
@overload
def truediv(__a: _X, __b: _SupportsRTrueDivWithX[_X]) -> Any: ...
@overload
def xor(__a: _SupportsXOrWithX[_X], __b: _X) -> Any: ...
@overload
def xor(__a: _X, __b: _SupportsRXOrWithX[_X]) -> Any: ...
def concat(__a: Sequence[_T], __b: Sequence[_T]) -> Sequence[_T]: ...
@overload
def contains(__a: AbstractSet[Any] | Mapping[Any, Any], __b: _Unhashable) -> NoReturn: ...
@overload
def contains(__a: Container[Any], __b: object) -> bool: ...
def countOf(__a: Iterable[Any], __b: object) -> int: ...
@overload
def delitem(__a: MutableSequence[Any], __b: SupportsIndex) -> None: ...
@overload
def delitem(__a: MutableSequence[Any], __b: slice) -> None: ...
@overload
def delitem(__a: MutableMapping[_K, Any], __b: _K) -> None: ...
@overload
def getitem(__a: Sequence[_T], __b: SupportsIndex) -> _T: ...
@overload
def getitem(__a: Sequence[_T], __b: slice) -> Sequence[_T]: ...
@overload
def getitem(__a: Mapping[_K, _V], __b: _K) -> _V: ...
def indexOf(__a: Iterable[_T], __b: _T) -> int: ...
@overload
def setitem(__a: MutableSequence[_T], __b: SupportsIndex, __c: _T) -> None: ...
@overload
def setitem(__a: MutableSequence[_T], __b: slice, __c: Sequence[_T]) -> None: ...
@overload
def setitem(__a: MutableMapping[_K, _V], __b: _K, __c: _V) -> None: ...
def length_hint(__obj: Any, __default: int = ...) -> int: ...
@final
class attrgetter(Generic[_T_co]):
    @overload
    def __new__(cls, attr: str) -> attrgetter[Any]: ...
    @overload
    def __new__(cls, attr: str, __attr2: str) -> attrgetter[tuple[Any, Any]]: ...
    @overload
    def __new__(cls, attr: str, __attr2: str, __attr3: str) -> attrgetter[tuple[Any, Any, Any]]: ...
    @overload
    def __new__(cls, attr: str, __attr2: str, __attr3: str, __attr4: str) -> attrgetter[tuple[Any, Any, Any, Any]]: ...
    @overload
    def __new__(cls, attr: str, *attrs: str) -> attrgetter[Tuple[Any, ...]]: ...
    def __call__(self, obj: Any) -> _T_co: ...

@final
class itemgetter(Generic[_T_co]):
    @overload
    def __new__(cls, item: Any) -> itemgetter[Any]: ...
    @overload
    def __new__(cls, item: Any, __item2: Any) -> itemgetter[tuple[Any, Any]]: ...
    @overload
    def __new__(cls, item: Any, __item2: Any, __item3: Any) -> itemgetter[tuple[Any, Any, Any]]: ...
    @overload
    def __new__(cls, item: Any, __item2: Any, __item3: Any, __item4: Any) -> itemgetter[tuple[Any, Any, Any, Any]]: ...
    @overload
    def __new__(cls, item: Any, *items: Any) -> itemgetter[Tuple[Any, ...]]: ...
    def __call__(self, obj: Any) -> _T_co: ...

@final
class methodcaller:
    def __init__(self, __name: str, *args: Any, **kwargs: Any) -> None: ...
    def __call__(self, obj: Any) -> Any: ...

def iadd(__a: Any, __b: Any) -> Any: ...
def iand(__a: Any, __b: Any) -> Any: ...
def iconcat(__a: Any, __b: Any) -> Any: ...
def ifloordiv(__a: Any, __b: Any) -> Any: ...
def ilshift(__a: Any, __b: Any) -> Any: ...
def imod(__a: Any, __b: Any) -> Any: ...
def imul(__a: Any, __b: Any) -> Any: ...
def imatmul(__a: Any, __b: Any) -> Any: ...
def ior(__a: Any, __b: Any) -> Any: ...
def ipow(__a: Any, __b: Any) -> Any: ...
def irshift(__a: Any, __b: Any) -> Any: ...
def isub(__a: Any, __b: Any) -> Any: ...
def itruediv(__a: Any, __b: Any) -> Any: ...
def ixor(__a: Any, __b: Any) -> Any: ...

if sys.version_info >= (3, 11):
    def call(__obj: Callable[_P, _R], *args: _P.args, **kwargs: _P.kwargs) -> _R: ...  # type: ignore

def _compare_digest(__a: AnyStr, __b: AnyStr) -> bool: ...
