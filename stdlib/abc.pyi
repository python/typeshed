from _typeshed import SupportsWrite
from collections.abc import Callable
from typing import Any, Generic, Tuple, Type, TypeVar
from typing_extensions import Literal

_T = TypeVar("_T")
_R_co = TypeVar("_R_co", covariant=True)
_FuncT = TypeVar("_FuncT", bound=Callable[..., Any])

# These definitions have special processing in mypy
class ABCMeta(type):
    __abstractmethods__: frozenset[str]
    def __init__(self, name: str, bases: Tuple[type, ...], namespace: dict[str, Any]) -> None: ...
    def __instancecheck__(cls: ABCMeta, instance: Any) -> Any: ...
    def __subclasscheck__(cls: ABCMeta, subclass: Any) -> Any: ...
    def _dump_registry(cls: ABCMeta, file: SupportsWrite[str] | None = ...) -> None: ...
    def register(cls: ABCMeta, subclass: Type[_T]) -> Type[_T]: ...

def abstractmethod(funcobj: _FuncT) -> _FuncT: ...

class abstractclassmethod(classmethod[_R_co], Generic[_R_co]):
    __isabstractmethod__: Literal[True]
    def __init__(self: abstractclassmethod[_R_co], callable: Callable[..., _R_co]) -> None: ...
    def __get__(self, obj: _T | None, type: Type[_T] | None = ...) -> Callable[..., _R_co]: ...

class abstractstaticmethod(staticmethod[_FuncT], Generic[_FuncT]):
    __isabstractmethod__: Literal[True]
    def __init__(self, callable: _FuncT) -> None: ...
    def __get__(self, obj: _T | None, type: Type[_T] | None = ...) -> _FuncT: ...

class abstractproperty(property): ...
class ABC(metaclass=ABCMeta): ...

def get_cache_token() -> object: ...
