import sys
from _typeshed import Self
from time import struct_time
from typing import ClassVar, NamedTuple, SupportsAbs, Type, TypeVar, overload
from typing_extensions import SupportsIndex, final

_T = TypeVar("_T", bound=time)
_D = TypeVar("_D", bound=date)
_TD = TypeVar("_TD", bound=timedelta)
_DT = TypeVar("_DT", bound=datetime)
MINYEAR: int
MAXYEAR: int

class tzinfo:
    def tzname(self, __dt: datetime | None) -> str | None: ...
    def utcoffset(self, __dt: datetime | None) -> timedelta | None: ...
    def dst(self, __dt: datetime | None) -> timedelta | None: ...
    def fromutc(self, __dt: datetime) -> datetime: ...
    def __reduce__(self: Self) -> tuple[Type[Self], tuple[Self]]: ...

# Alias required to avoid name conflicts with date(time).tzinfo.
_tzinfo = tzinfo

@final
class timezone(tzinfo):
    utc: ClassVar[timezone]
    min: ClassVar[timezone]
    max: ClassVar[timezone]
    def __init__(self, offset: timedelta, name: str = ...) -> None: ...
    def __hash__(self) -> int: ...

if sys.version_info >= (3, 9):
    class _IsoCalendarDate(NamedTuple):
        year: int
        week: int
        weekday: int

class date:
    min: ClassVar[date]
    max: ClassVar[date]
    resolution: ClassVar[timedelta]
    def __new__(cls: Type[_D], year: int, month: int, day: int) -> _D: ...
    @classmethod
    def fromtimestamp(cls: Type[_D], __timestamp: float) -> _D: ...
    @classmethod
    def today(cls: Type[_D]) -> _D: ...
    @classmethod
    def fromordinal(cls: Type[_D], __n: int) -> _D: ...
    if sys.version_info >= (3, 7):
        @classmethod
        def fromisoformat(cls: Type[_D], __date_string: str) -> _D: ...
    if sys.version_info >= (3, 8):
        @classmethod
        def fromisocalendar(cls: Type[_D], year: int, week: int, day: int) -> _D: ...
    @property
    def year(self) -> int: ...
    @property
    def month(self) -> int: ...
    @property
    def day(self) -> int: ...
    def ctime(self) -> str: ...
    def strftime(self, format: str) -> str: ...
    def __format__(self, __fmt: str) -> str: ...
    def isoformat(self) -> str: ...
    def timetuple(self) -> struct_time: ...
    def toordinal(self) -> int: ...
    def replace(self, year: int = ..., month: int = ..., day: int = ...) -> date: ...
    def __le__(self: _D, __other: _D) -> bool: ...
    def __lt__(self: _D, __other: _D) -> bool: ...
    def __ge__(self: _D, __other: _D) -> bool: ...
    def __gt__(self: _D, __other: _D) -> bool: ...
    def __add__(self: _D, __other: timedelta) -> _D: ...
    def __radd__(self: _D, __other: timedelta) -> _D: ...
    @overload
    def __sub__(self: _D, __other: timedelta) -> _D: ...
    @overload
    def __sub__(self: _D, __other: _D) -> timedelta: ...
    def __reduce__(self: Self) -> tuple[Type[Self], tuple[bytes]]: ...
    if sys.version_info >= (3, 8):
        def __reduce_ex__(self: Self, __protocol: SupportsIndex) -> tuple[Type[Self], tuple[bytes]]: ...
    else:
        def __reduce_ex__(self: Self, __protocol: int) -> tuple[Type[Self], tuple[bytes]]: ...
    def __hash__(self) -> int: ...
    def weekday(self) -> int: ...
    def isoweekday(self) -> int: ...
    if sys.version_info >= (3, 9):
        def isocalendar(self) -> _IsoCalendarDate: ...
    else:
        def isocalendar(self) -> tuple[int, int, int]: ...

class time:
    min: ClassVar[time]
    max: ClassVar[time]
    resolution: ClassVar[timedelta]
    def __new__(
        cls: Type[_T],
        hour: int = ...,
        minute: int = ...,
        second: int = ...,
        microsecond: int = ...,
        tzinfo: _tzinfo | None = ...,
        *,
        fold: int = ...,
    ) -> _T: ...
    @property
    def hour(self) -> int: ...
    @property
    def minute(self) -> int: ...
    @property
    def second(self) -> int: ...
    @property
    def microsecond(self) -> int: ...
    @property
    def tzinfo(self) -> _tzinfo | None: ...
    @property
    def fold(self) -> int: ...
    def __le__(self: _T, __other: _T) -> bool: ...
    def __lt__(self: _T, __other: _T) -> bool: ...
    def __ge__(self: _T, __other: _T) -> bool: ...
    def __gt__(self: _T, __other: _T) -> bool: ...
    def __hash__(self) -> int: ...
    def isoformat(self, timespec: str = ...) -> str: ...
    if sys.version_info >= (3, 7):
        @classmethod
        def fromisoformat(cls: Type[_T], __time_string: str) -> _T: ...
    def strftime(self, format: str) -> str: ...
    def __format__(self, __fmt: str) -> str: ...
    def utcoffset(self) -> timedelta | None: ...
    def tzname(self) -> str | None: ...
    def dst(self) -> timedelta | None: ...
    def replace(
        self,
        hour: int = ...,
        minute: int = ...,
        second: int = ...,
        microsecond: int = ...,
        tzinfo: _tzinfo | None = ...,
        *,
        fold: int = ...,
    ) -> time: ...

_date = date
_time = time

class timedelta(SupportsAbs[timedelta]):
    min: ClassVar[timedelta]
    max: ClassVar[timedelta]
    resolution: ClassVar[timedelta]
    def __new__(
        cls: Type[_TD],
        days: float = ...,
        seconds: float = ...,
        microseconds: float = ...,
        milliseconds: float = ...,
        minutes: float = ...,
        hours: float = ...,
        weeks: float = ...,
    ) -> _TD: ...
    @property
    def days(self) -> int: ...
    @property
    def seconds(self) -> int: ...
    @property
    def microseconds(self) -> int: ...
    def total_seconds(self) -> float: ...
    def __add__(self: _TD, __other: _TD) -> _TD: ...
    def __radd__(self: _TD, __other: _TD) -> _TD: ...
    def __sub__(self: _TD, __other: _TD) -> _TD: ...
    def __rsub__(self: _TD, __other: _TD) -> _TD: ...
    def __neg__(self: _TD) -> _TD: ...
    def __pos__(self: _TD) -> _TD: ...
    def __abs__(self: _TD) -> _TD: ...
    def __mul__(self: _TD, __other: float) -> _TD: ...
    def __rmul__(self: _TD, __other: float) -> _TD: ...
    @overload
    def __floordiv__(self: _TD, __other: _TD) -> int: ...
    @overload
    def __floordiv__(self: _TD, __other: int) -> _TD: ...
    @overload
    def __truediv__(self: _TD, __other: _TD) -> float: ...
    @overload
    def __truediv__(self: _TD, __other: float) -> _TD: ...
    def __mod__(self: _TD, __other: _TD) -> _TD: ...
    def __divmod__(self: _TD, __other: _TD) -> tuple[int, _TD]: ...
    def __le__(self: _TD, __other: _TD) -> bool: ...
    def __lt__(self: _TD, __other: _TD) -> bool: ...
    def __ge__(self: _TD, __other: _TD) -> bool: ...
    def __gt__(self: _TD, __other: _TD) -> bool: ...
    def __bool__(self) -> bool: ...
    def __hash__(self) -> int: ...

class datetime(date):
    min: ClassVar[datetime]
    max: ClassVar[datetime]
    def __new__(
        cls: Type[_DT],
        year: int,
        month: int,
        day: int,
        hour: int = ...,
        minute: int = ...,
        second: int = ...,
        microsecond: int = ...,
        tzinfo: _tzinfo | None = ...,
        *,
        fold: int = ...,
    ) -> _DT: ...
    @property
    def hour(self) -> int: ...
    @property
    def minute(self) -> int: ...
    @property
    def second(self) -> int: ...
    @property
    def microsecond(self) -> int: ...
    @property
    def tzinfo(self) -> _tzinfo | None: ...
    @property
    def fold(self) -> int: ...
    @classmethod
    def fromtimestamp(cls: Type[_DT], timestamp: float, tz: _tzinfo | None = ...) -> _DT: ...
    @classmethod
    def utcfromtimestamp(cls: Type[_DT], __t: float) -> _DT: ...
    @classmethod
    def now(cls: Type[_DT], tz: _tzinfo | None = ...) -> _DT: ...
    @classmethod
    def utcnow(cls: Type[_DT]) -> _DT: ...
    @classmethod
    def combine(cls: Type[_DT], date: _date, time: _time, tzinfo: _tzinfo | None = ...) -> _DT: ...
    if sys.version_info >= (3, 7):
        @classmethod
        def fromisoformat(cls: Type[_DT], __date_string: str) -> _DT: ...
    def timestamp(self) -> float: ...
    def utctimetuple(self) -> struct_time: ...
    def date(self) -> _date: ...
    def time(self) -> _time: ...
    def timetz(self) -> _time: ...
    def replace(
        self: _DT,
        year: int = ...,
        month: int = ...,
        day: int = ...,
        hour: int = ...,
        minute: int = ...,
        second: int = ...,
        microsecond: int = ...,
        tzinfo: _tzinfo | None = ...,
        *,
        fold: int = ...,
    ) -> _DT: ...
    def astimezone(self: _DT, tz: _tzinfo | None = ...) -> _DT: ...
    def isoformat(self, sep: str = ..., timespec: str = ...) -> str: ...
    @classmethod
    def strptime(cls: Type[_DT], __date_string: str, __format: str) -> _DT: ...
    def utcoffset(self) -> timedelta | None: ...
    def tzname(self) -> str | None: ...
    def dst(self) -> timedelta | None: ...
    def __le__(self: _DT, __other: _DT) -> bool: ...
    def __lt__(self: _DT, __other: _DT) -> bool: ...
    def __ge__(self: _DT, __other: _DT) -> bool: ...
    def __gt__(self: _DT, __other: _DT) -> bool: ...
    if sys.version_info >= (3, 9):
        def isocalendar(self) -> _IsoCalendarDate: ...
    else:
        def isocalendar(self) -> tuple[int, int, int]: ...
