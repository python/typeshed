from _typeshed import ReadableBuffer
from asyncio import transports

# Keep asyncio.__all__ updated with any changes to __all__ here
__all__ = ("BaseProtocol", "Protocol", "DatagramProtocol", "SubprocessProtocol", "BufferedProtocol")

class BaseProtocol:
    __slots__ = ()
    def connection_made(self, transport: transports.BaseTransport) -> None: ...
    def connection_lost(self, exc: Exception | None) -> None: ...
    def pause_writing(self) -> None: ...
    def resume_writing(self) -> None: ...

class Protocol(BaseProtocol):
    # Need annotation or mypy will complain about 'Cannot determine type of "__slots__" in base class'
    __slots__: tuple[str, ...] = ()
    def data_received(self, data: bytes) -> None: ...
    def eof_received(self) -> bool | None: ...

class BufferedProtocol(BaseProtocol):
    __slots__ = ()
    def get_buffer(self, sizehint: int) -> ReadableBuffer: ...
    def buffer_updated(self, nbytes: int) -> None: ...
    def eof_received(self) -> bool | None: ...

class DatagramProtocol(BaseProtocol):
    __slots__ = ()
    def connection_made(self, transport: transports.DatagramTransport) -> None: ...  # type: ignore[override]
    # Address is a 2-tuple (host, port) for IPv4, 4-tuple (host, port, flowinfo, scope_id) for IPv6,
    # or tuple[int, int] for some unusual protocols like socket.AF_NETLINK.
    def datagram_received(self, data: bytes, addr: tuple[str, int] | tuple[str, int, int, int] | tuple[int, int]) -> None: ...
    def error_received(self, exc: Exception) -> None: ...

class SubprocessProtocol(BaseProtocol):
    __slots__: tuple[str, ...] = ()
    def pipe_data_received(self, fd: int, data: bytes) -> None: ...
    def pipe_connection_lost(self, fd: int, exc: Exception | None) -> None: ...
    def process_exited(self) -> None: ...
