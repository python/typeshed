import sys
from typing import Any, ClassVar
from typing_extensions import Literal, final

# _tkinter is meant to be only used internally by tkinter, but some tkinter
# functions e.g. return _tkinter.Tcl_Obj objects. Tcl_Obj represents a Tcl
# object that hasn't been converted to a string.
#
# There are not many ways to get Tcl_Objs from tkinter, and I'm not sure if the
# only existing ways are supposed to return Tcl_Objs as opposed to returning
# strings. Here's one of these things that return Tcl_Objs:
#
#    >>> import tkinter
#    >>> text = tkinter.Text()
#    >>> text.tag_add('foo', '1.0', 'end')
#    >>> text.tag_ranges('foo')
#    (<textindex object: '1.0'>, <textindex object: '2.0'>)
@final
class Tcl_Obj:
    string: str  # str(tclobj) returns this
    typename: str
    __hash__: None  # type: ignore[assignment]
    def __eq__(self, other): ...
    def __ge__(self, other): ...
    def __gt__(self, other): ...
    def __le__(self, other): ...
    def __lt__(self, other): ...
    def __ne__(self, other): ...

class TclError(Exception): ...

# This class allows running Tcl code. Tkinter uses it internally a lot, and
# it's often handy to drop a piece of Tcl code into a tkinter program. Example:
#
#    >>> import tkinter, _tkinter
#    >>> tkapp = tkinter.Tk().tk
#    >>> isinstance(tkapp, _tkinter.TkappType)
#    True
#    >>> tkapp.call('set', 'foo', (1,2,3))
#    (1, 2, 3)
#    >>> tkapp.eval('return $foo')
#    '1 2 3'
#    >>>
#
# call args can be pretty much anything. Also, call(some_tuple) is same as call(*some_tuple).
#
# eval always returns str because _tkinter_tkapp_eval_impl in _tkinter.c calls
# Tkapp_UnicodeResult, and it returns a string when it succeeds.
@final
class TkappType:
    # Please keep in sync with tkinter.Tk
    def adderrorinfo(self, *args, **kwargs): ...
    def call(self, __command: Any, *args: Any) -> Any: ...
    def createcommand(self, *args, **kwargs): ...
    def createfilehandler(self, *args, **kwargs): ...
    def createtimerhandler(self, *args, **kwargs): ...
    def deletecommand(self, *args, **kwargs): ...
    def deletefilehandler(self, *args, **kwargs): ...
    def dooneevent(self, *args, **kwargs): ...
    def eval(self, __script: str) -> str: ...
    def evalfile(self, *args, **kwargs): ...
    def exprboolean(self, *args, **kwargs): ...
    def exprdouble(self, *args, **kwargs): ...
    def exprlong(self, *args, **kwargs): ...
    def exprstring(self, *args, **kwargs): ...
    def getboolean(self, *args, **kwargs): ...
    def getdouble(self, *args, **kwargs): ...
    def getint(self, *args, **kwargs): ...
    def getvar(self, *args, **kwargs): ...
    def globalgetvar(self, *args, **kwargs): ...
    def globalsetvar(self, *args, **kwargs): ...
    def globalunsetvar(self, *args, **kwargs): ...
    def interpaddr(self, *args, **kwargs): ...
    def loadtk(self, *args, **kwargs): ...
    def mainloop(self, *args, **kwargs): ...
    def quit(self, *args, **kwargs): ...
    def record(self, *args, **kwargs): ...
    def setvar(self, *args, **kwargs): ...
    if sys.version_info < (3, 11):
        def split(self, *args, **kwargs): ...
    def splitlist(self, *args, **kwargs): ...
    def unsetvar(self, *args, **kwargs): ...
    def wantobjects(self, *args, **kwargs): ...
    def willdispatch(self, *args, **kwargs): ...

# These should be kept in sync with tkinter.tix constants, except ALL_EVENTS which doesn't match TCL_ALL_EVENTS
ALL_EVENTS: Literal[-3]
FILE_EVENTS: Literal[8]
IDLE_EVENTS: Literal[32]
TIMER_EVENTS: Literal[16]
WINDOW_EVENTS: Literal[4]

DONT_WAIT: Literal[2]
EXCEPTION: Literal[8]
READABLE: Literal[2]
WRITABLE: Literal[4]

TCL_VERSION: str
TK_VERSION: str

class TkttType:
    def deletetimerhandler(self, *args, **kwargs): ...

def create(*args, **kwargs): ...
def getbusywaitinterval(*args, **kwargs): ...
def setbusywaitinterval(*args, **kwargs): ...
