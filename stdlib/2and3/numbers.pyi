# Stubs for numbers

from typing import (
    Any, Optional,
    SupportsAbs, SupportsComplex, SupportsFloat, SupportsInt, SupportsRound,
)
from abc import abstractmethod
import sys


class Number: ...

class Complex(Number, SupportsComplex, SupportsAbs[float]):
    @property
    @abstractmethod
    def real(self) -> Complex: ...
    @property
    @abstractmethod
    def imag(self) -> Complex: ...
    @abstractmethod
    def __add__(self, other: Complex) -> Complex: ...
    def __neg__(self) -> Complex: ...
    @abstractmethod
    def __mul__(self, other: Complex) -> Complex: ...
    if sys.version_info >= (3,):
        @abstractmethod
        def __truediv__(self, other: Complex) -> Complex: ...
    else:
        @abstractmethod
        def __div__(self, other: Complex) -> Complex: ...
    @abstractmethod
    def conjugate(self) -> Complex: ...

class Real(Complex, SupportsFloat, SupportsRound):
    @abstractmethod
    def __trunc__(self) -> int: ...
    @abstractmethod
    def __floor__(self) -> int: ...
    @abstractmethod
    def __ceil__(self) -> int: ...
    @abstractmethod
    def __divmod__(self, other: Real) -> Real: ...
    @abstractmethod
    def __floordiv__(self, other: Real) -> Real: ...
    @abstractmethod
    def __mod__(self, other: Real) -> Real: ...
    @abstractmethod
    def __lt__(self, other: Real) -> bool: ...
    @abstractmethod
    def __le__(self, other: Real) -> bool: ...
    @abstractmethod
    def __gt__(self, other: Real) -> bool: ...
    @abstractmethod
    def __ge__(self, other: Real) -> bool: ...
    def __complex__(self) -> Complex: ...  # type: ignore
    @property
    def real(self) -> Real: ...
    @property
    def imag(self) -> Real: ...
    def conjugate(self) -> Real: ...

    @abstractmethod
    def __add__(self, other: Real) -> Real: ...
    def __neg__(self) -> Real: ...
    @abstractmethod
    def __mul__(self, other: Real) -> Real: ...
    if sys.version_info >= (3,):
        @abstractmethod
        def __truediv__(self, other: Real) -> Real: ...
    else:
        @abstractmethod
        def __div__(self, other: Real) -> Real: ...

class Rational(Real):
    @property
    @abstractmethod
    def numerator(self) -> int: ...
    @property
    @abstractmethod
    def denominator(self) -> int: ...
    def __float__(self) -> float: ...

    @abstractmethod
    def __divmod__(self, other: Rational) -> Rational: ...
    @abstractmethod
    def __floordiv__(self, other: Rational) -> Rational: ...
    @abstractmethod
    def __mod__(self, other: Rational) -> Rational: ...
    @abstractmethod
    def __lt__(self, other: Rational, float) -> bool: ...
    @abstractmethod
    def __le__(self, other: Rational) -> bool: ...
    @abstractmethod
    def __gt__(self, other: Rational) -> bool: ...
    @abstractmethod
    def __ge__(self, other: Rational) -> bool: ...
    def __complex__(self) -> Complex: ...  # type: ignore
    @property
    def real(self) -> Rational: ...
    @property
    def imag(self) -> Rational: ...
    def conjugate(self) -> Rational: ...

    @abstractmethod
    def __add__(self, other: Rational) -> Rational: ...
    def __neg__(self) -> Rational: ...
    @abstractmethod
    def __mul__(self, other: Rational) -> Rational: ...
    if sys.version_info >= (3,):
        @abstractmethod
        def __truediv__(self, other: Rational) -> Rational: ...
    else:
        @abstractmethod
        def __div__(self, other: Rational) -> Rational: ...

class Integral(Rational, SupportsInt, SupportsAbs[int]):
    @property
    def numerator(self) -> int: ...
    @property
    def denominator(self) -> int: ...
    @abstractmethod
    def __pow__(self, exponent: float,
                modulus: Optional[int] = ...) -> Integral: ...
    @abstractmethod
    def __lshift__(self, other: Integral) -> Integral: ...
    @abstractmethod
    def __rshift__(self, other: Integral) -> Integral: ...
    @abstractmethod
    def __and__(self, other: Integral) -> Integral: ...
    @abstractmethod
    def __xor__(self, other: Integral) -> Integral: ...
    @abstractmethod
    def __or__(self, other: Integral) -> Integral: ...
    @abstractmethod
    def __invert__(self) -> Integral: ...

    @abstractmethod
    def __divmod__(self, other: Integral) -> Integral: ...
    @abstractmethod
    def __floordiv__(self, other: Integral) -> Integral: ...
    @abstractmethod
    def __mod__(self, other: Integral) -> Integral: ...
    @abstractmethod
    def __lt__(self, other: Integral) -> bool: ...
    @abstractmethod
    def __le__(self, other: Integral) -> bool: ...
    @abstractmethod
    def __gt__(self, other: Integral) -> bool: ...
    @abstractmethod
    def __ge__(self, other: Integral) -> bool: ...
    def __complex__(self) -> Complex: ...  # type: ignore
    @property
    def real(self) -> Integral: ...
    @property
    def imag(self) -> Integral: ...
    def conjugate(self) -> Integral: ...

    @abstractmethod
    def __add__(self, other: Integral) -> Integral: ...
    def __neg__(self) -> Integral: ...
    @abstractmethod
    def __mul__(self, other: Integral) -> Integral: ...
    if sys.version_info >= (3,):
        @abstractmethod
        def __truediv__(self, other: Integral) -> Integral: ...
    else:
        @abstractmethod
        def __div__(self, other: Integral) -> Integral: ...
