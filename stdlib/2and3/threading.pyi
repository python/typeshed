## Stubs for threading

#from typing import Any, Optional
#from time import monotonic as _time
#from time import time as _time
#from traceback import format_exc as _format_exc
#from itertools import islice as _islice, count as _count
#from _collections import deque as _deque
#from collections import deque as _deque
#from _thread import stack_size as stack_size
#from _thread import _local as local
#from _threading_local import local as local

#ThreadError = ...  # type: Any

#def setprofile(func): ...
#def settrace(func): ...

#Lock = ...  # type: Any

#def RLock(*args, **kwargs): ...

#class _RLock:
#    def __init__(self) -> None: ...
#    def acquire(self, blocking: bool = ..., timeout: int = ...): ...
#    __enter__ = ...  # type: Any
#    def release(self): ...
#    def __exit__(self, t, v, tb): ...

#class Condition:
#    acquire = ...  # type: Any
#    release = ...  # type: Any
#    def __init__(self, lock: Optional[Any] = ...) -> None: ...
#    def __enter__(self): ...
#    def __exit__(self, *args): ...
#    def wait(self, timeout: Optional[Any] = ...): ...
#    def wait_for(self, predicate, timeout: Optional[Any] = ...): ...
#    def notify(self, n: int = ...): ...
#    def notify_all(self): ...
#    notifyAll = ...  # type: Any

#class Semaphore:
#    def __init__(self, value: int = ...) -> None: ...
#    def acquire(self, blocking: bool = ..., timeout: Optional[Any] = ...): ...
#    __enter__ = ...  # type: Any
#    def release(self): ...
#    def __exit__(self, t, v, tb): ...

#class BoundedSemaphore(Semaphore):
#    def __init__(self, value: int = ...) -> None: ...
#    def release(self): ...

#class Event:
#    def __init__(self) -> None: ...
#    def is_set(self): ...
#    isSet = ...  # type: Any
#    def set(self): ...
#    def clear(self): ...
#    def wait(self, timeout: Optional[Any] = ...): ...

#class Barrier:
#    def __init__(self, parties, action: Optional[Any] = ..., timeout: Optional[Any] = ...) -> None: ...
#    def wait(self, timeout: Optional[Any] = ...): ...
#    def reset(self): ...
#    def abort(self): ...
#    @property
#    def parties(self): ...
#    @property
#    def n_waiting(self): ...
#    @property
#    def broken(self): ...

#class BrokenBarrierError(RuntimeError): ...

#class Thread:
#    def __init__(self, group: Optional[Any] = ..., target: Optional[Any] = ..., name: Optional[Any] = ..., args: Any = ..., kwargs: Optional[Any] = ..., *, daemon: Optional[Any] = ...) -> None: ...
#    def start(self): ...
#    def run(self): ...
#    def join(self, timeout: Optional[Any] = ...): ...
#    @property
#    def name(self): ...
#    @name.setter
#    def name(self, name): ...
#    @property
#    def ident(self): ...
#    def is_alive(self): ...
#    isAlive = ...  # type: Any
#    @property
#    def daemon(self): ...
#    @daemon.setter
#    def daemon(self, daemonic): ...
#    def isDaemon(self): ...
#    daemon = ...  # type: Any
#    def setDaemon(self, daemonic): ...
#    def getName(self): ...
#    name = ...  # type: Any
#    def setName(self, name): ...

#class Timer(Thread):
#    interval = ...  # type: Any
#    function = ...  # type: Any
#    args = ...  # type: Any
#    kwargs = ...  # type: Any
#    finished = ...  # type: Any
#    def __init__(self, interval, function, args: Optional[Any] = ..., kwargs: Optional[Any] = ...) -> None: ...
#    def cancel(self): ...
#    def run(self): ...

#class _MainThread(Thread):
#    def __init__(self) -> None: ...

#class _DummyThread(Thread):
#    def __init__(self) -> None: ...
#    def join(self, timeout: Optional[Any] = ...): ...

#def current_thread(): ...
#def active_count(): ...
#def enumerate(): ...
