# Stubs for ctypes

from typing import (
    Any, Callable, Optional, Tuple, Type, Union,
    Generic, TypeVar, overload,
)
import sys

_DT = TypeVar('_DT', int, bytes, str, float, None)
if sys.platform == 'win32':
    _DLLT = TypeVar('_DLLT', CDLL, OleDLL, WinDLL, PyDLL)
else:
    _DLLT = TypeVar('_DLLT', CDLL, PyDLL)


RTLD_GLOBAL = ...  # type: int
RTLD_LOCAL = ...  # type: int
DEFAULT_MODE = ...  # type: int


class _DLL:
    def __init__(self, name: str, mode: int = ..., handle: Optional[int] = ...,
                 use_errno: bool = ..., use_last_error: bool = ...) -> None: ...
class CDLL(_DLL): ...
if sys.platform == 'win32':
    class OleDLL(_DLL): ...
    class WinDLL(_DLL): ...
class PyDLL(_DLL):
    _handle = ...  # type: int
    _name = ...  # type: str
    def __init__(self, name: str, mode: int = ...,
                 handle: Optional[int] = ...) -> None: ...

class LibraryLoader(Generic[_DLLT]):
    def __init__(self, dlltype: Type[_DLLT]) -> None: ...
    def LoadLibrary(self, name: str) -> _DLLT: ...

cdll = ...  # type: LibraryLoader[CDLL]
if sys.platform == 'win32':
    windll = ...  # type: LibraryLoader[WinDLL]
    oledll = ...  # type: LibraryLoader[OleDLL]
pydll = ...  # type: LibraryLoader[PyDLL]
pythonapi = ...  # type: PyDLL


class _FuncPtr(Generic[_DT]):
    restype = ...  # type: Union[Optional[Type[_SimpleCData[_DT]]], Callable[[int], None]]
    argtypes = ...  # type: Tuple[Type[_SimpleCData[_DT]], ...]
    errcheck = ...  # type: Callable[[Optional[Type[_SimpleCData[_DT]]], _FuncPtr[_DT], Tuple[_SimpleCData[Any], ...]], _SimpleCData[_DT]]
    def __call__(self, *args: Union[_SimpleCData, _cparam],
                 **kwargs: Union[_SimpleCData, _cparam]) -> _DT: ...

class ArgumentError(Exception): ...


def CFUNCTYPE(restype: Type[_SimpleCData[_DT]],
              *argtypes: Type[_SimpleCData[Any]],
              use_errno: bool = ...,
              use_last_error: bool = ...) -> Type[_FuncProto[_DT]]: ...
if sys.platform == 'win32':
    def WINFUNCTYPE(restype: Type[_SimpleCData[_DT]],
                    *argtypes: Type[_SimpleCData[Any]],
                    use_errno: bool = ...,
                    use_last_error: bool = ...) -> Type[_FuncProto[_DT]]: ...
def PYFUNCTYPE(restype: Type[_SimpleCData[_DT]],
               *argtypes: Type[_SimpleCData[Any]],
               use_errno: bool = ...,
               use_last_error: bool = ...) -> Type[_FuncProto[_DT]]: ...

_PF = Tuple[
    Tuple[int],
    Tuple[int, str],
    Tuple[int, str, Any],
]

class _FuncProto(Generic[_DT], _FuncPtr[_DT]):
    @overload
    def __init__(self, address: int) -> None: ...
    @overload
    def __init__(self, callable: Callable[..., _DT]) -> None: ...
    @overload
    def __init__(self, func_spec: Tuple[Union[str, int], _DLL],
                 paramflags: Tuple[_PF, ...] = ...) -> None: ...
    # TODO better type: iid is a pointer to the interface identifier
    @overload
    def __init__(self, vtlb_index: int, name: str,
                 paramflags: Tuple[_PF, ...] = ...,
                 iid: _SimpleCData[Any] = ...) -> None: ...

class _cparam(Generic[_DT]): ...

def addressof(obj: _SimpleCData[Any]) -> int: ...
def alignment(obj_or_type: Union[_SimpleCData[Any], Type[_SimpleCData[Any]]]) -> int: ...
def byref(obj: _SimpleCData[_DT], offset: int = ...) -> _cparam[_DT]: ...


class _SimpleCData(Generic[_DT]):
    value = ...  # type: _DT
    def __init__(self, value: _DT) -> None: ...

#class c_bool(_SimpleCData[int]):
#    def __init__(self, value: bool) -> None: ...

#class c_char(_SimpleCData[bytes]): ...
#class c_wchar(_SimpleCData[str]): ...

#class c_byte(_SimpleCData[int]): ...
#class c_ubyte(_SimpleCData[int]): ...

#class c_short(_SimpleCData[int]): ...
#class c_ushort(_SimpleCData[int]): ...

#class c_int(_SimpleCData[int]): ...
#class c_uint(_SimpleCData[int]): ...

#class c_long(_SimpleCData[int]): ...
#class c_ulong(_SimpleCData[int]): ...
#class c_longlong(_SimpleCData[int]): ...
#class c_ulonglong(_SimpleCData[int]): ...

#class c_size_t(_SimpleCData[int]): ...
#class c_ssize_t(_SimpleCData[int]): ...

#class c_float(_SimpleCData[float]): ...
#class c_double(_SimpleCData[float]): ...
#class c_longdouble(_SimpleCData[float]): ...

#class c_char_p(_SimpleCData[Optional[bytes]]): ...
#class c_wchar_p(_SimpleCData[Optional[str]]): ...
#class c_voidp(_SimpleCData[Optional[int]]): ...


#def create_string_buffer(init, size=None): ...
#def c_buffer(init, size=None): ...

#class py_object(_SimpleCData): ...

#c_int = ...  # type: Any
#c_uint = ...  # type: Any


#c_longdouble = ...  # type: Any
#c_longlong = ...  # type: Any
#c_ulonglong = ...  # type: Any

#class c_char(_SimpleCData): ...
#class c_void_p(_SimpleCData): ...


#class c_wchar(_SimpleCData): ...

#def create_unicode_buffer(init, size=None): ...
#def SetPointerType(pointer, cls): ...
#def ARRAY(typ, len): ...

#class HRESULT(_SimpleCData): ...

#GetLastError = ...  # type: Any

#def WinError(code=None, descr=None): ...

#memmove = ...  # type: Any
#memset = ...  # type: Any

#def cast(obj, typ): ...
#def string_at(ptr, size=-1): ...
#def wstring_at(ptr, size=-1): ...
#def DllGetClassObject(rclsid, riid, ppv): ...
#def DllCanUnloadNow(): ...

#c_int8 = ...  # type: Any
#c_uint8 = ...  # type: Any
#c_int16 = ...  # type: Any
#c_int32 = ...  # type: Any
#c_int64 = ...  # type: Any
#c_uint16 = ...  # type: Any
#c_uint32 = ...  # type: Any
#c_uint64 = ...  # type: Any
