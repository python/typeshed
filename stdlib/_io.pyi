import builtins
import codecs
import sys
from _typeshed import FileDescriptorOrPath, ReadableBuffer, WriteableBuffer
from collections.abc import Callable, Iterable, Iterator
from io import BufferedIOBase, RawIOBase, TextIOBase, UnsupportedOperation as UnsupportedOperation
from os import _Opener
from types import TracebackType
from typing import IO, Any, BinaryIO, TextIO, TypeVar, overload
from typing_extensions import Literal, Self

_T = TypeVar("_T")

DEFAULT_BUFFER_SIZE: Literal[8192]

open = builtins.open
BlockingIOError = builtins.BlockingIOError

if sys.version_info >= (3, 8):
    def open_code(path: str) -> IO[bytes]: ...

if sys.version_info >= (3, 10):
    @overload
    def text_encoding(__encoding: None, __stacklevel: int = 2) -> Literal["locale", "utf-8"]: ...
    @overload
    def text_encoding(__encoding: _T, __stacklevel: int = 2) -> _T: ...

class _IOBase:
    def __del__(self) -> None: ...
    def __enter__(self) -> Self: ...
    def __exit__(
        self, type: type[BaseException] | None, value: BaseException | None, traceback: TracebackType | None
    ) -> None: ...
    def __iter__(self) -> Iterator[bytes]: ...
    def __next__(self) -> bytes: ...
    def close(self) -> None: ...
    @property
    def closed(self) -> bool: ...
    def fileno(self) -> int: ...
    def flush(self) -> None: ...
    def isatty(self) -> bool: ...
    read: Callable[..., Any]
    def readable(self) -> bool: ...
    def readline(self, __size: int | None = -1) -> bytes: ...
    def readlines(self, __hint: int = -1) -> list[bytes]: ...
    def seek(self, __offset: int, __whence: int = ...) -> int: ...
    def seekable(self) -> bool: ...
    def tell(self) -> int: ...
    def truncate(self, __size: int | None = ...) -> int: ...
    def writable(self) -> bool: ...
    write: Callable[..., Any]
    def writelines(self, __lines: Iterable[ReadableBuffer]) -> None: ...
    def _checkClosed(self, msg: str | None = ...) -> None: ...  # undocumented

class _RawIOBase(_IOBase):
    def read(self, __size: int = -1) -> bytes | None: ...
    def readall(self) -> bytes: ...
    def readinto(self, __buffer: WriteableBuffer) -> int | None: ...
    def write(self, __b: ReadableBuffer) -> int | None: ...

class FileIO(RawIOBase, _RawIOBase, BinaryIO):  # type: ignore[misc]  # incompatible definitions of writelines in the base classes
    mode: str
    name: FileDescriptorOrPath
    def __init__(
        self, file: FileDescriptorOrPath, mode: str = ..., closefd: bool = ..., opener: _Opener | None = ...
    ) -> None: ...
    @property
    def closefd(self) -> bool: ...
    def read(self, __size: int = -1) -> bytes: ...
    def write(self, __b: ReadableBuffer) -> int: ...

    # these are only here so stubtest is happy with the argument names
    def seek(self, __pos: int, __whence: int = ...) -> int: ...

class _BufferedIOBase(_IOBase):
    def detach(self) -> RawIOBase: ...
    def read(self, __size: int | None = ...) -> bytes: ...
    def read1(self, __size: int = ...) -> bytes: ...
    def readinto(self, __buffer: WriteableBuffer) -> int: ...
    def readinto1(self, __buffer: WriteableBuffer) -> int: ...
    def write(self, __buffer: ReadableBuffer) -> int: ...

class BytesIO(BufferedIOBase, _BufferedIOBase, BinaryIO):  # type: ignore[misc]  # incompatible definitions of methods in the base classes
    # BytesIO does not contain a "name" field. This workaround is necessary
    # to allow BytesIO sub-classes to add this field, as it is defined
    # as a read-only property on IO[].
    name: Any
    def __init__(self, initial_bytes: ReadableBuffer = ...) -> None: ...
    def getbuffer(self) -> memoryview: ...
    def getvalue(self) -> bytes: ...
    def read1(self, __size: int | None = -1) -> bytes: ...
    def readlines(self, __size: int | None = None) -> list[bytes]: ...

    # these are only here so stubtest is happy with the argument names
    def seek(self, __pos: int, __whence: int = ...) -> int: ...

class BufferedReader(BufferedIOBase, _BufferedIOBase, BinaryIO):  # type: ignore[misc]  # incompatible definitions of methods in the base classes
    # technically has mode and name attributes, but they're just pass-throughs to
    # self.raw.*
    raw: RawIOBase
    def __init__(self, raw: RawIOBase, buffer_size: int = ...) -> None: ...
    def peek(self, __size: int = 0) -> bytes: ...

    # these are only here so stubtest is happy with the argument names
    def truncate(self, __pos: int | None = ...) -> int: ...
    def seek(self, __target: int, __whence: int = ...) -> int: ...

class BufferedWriter(BufferedIOBase, _BufferedIOBase, BinaryIO):  # type: ignore[misc]  # incompatible definitions of writelines in the base classes
    # technically has mode and name attributes, but they're just pass-throughs to
    # self.raw.*
    raw: RawIOBase
    def __init__(self, raw: RawIOBase, buffer_size: int = ...) -> None: ...
    def write(self, __buffer: ReadableBuffer) -> int: ...

    # these are only here so stubtest is happy with the argument names
    def truncate(self, __pos: int | None = ...) -> int: ...
    def seek(self, __target: int, __whence: int = ...) -> int: ...

class BufferedRWPair(BufferedIOBase, _BufferedIOBase):
    def __init__(self, reader: RawIOBase, writer: RawIOBase, buffer_size: int = ...) -> None: ...
    def peek(self, __size: int = ...) -> bytes: ...

class BufferedRandom(BufferedReader, BufferedWriter, _BufferedIOBase): ...  # type: ignore[misc]  # incompatible definitions of methods in the base classes

class _TextIOBase(_IOBase):
    encoding: str
    errors: str | None
    newlines: str | tuple[str, ...] | None
    def __iter__(self) -> Iterator[str]: ...  # type: ignore[override]
    def __next__(self) -> str: ...  # type: ignore[override]
    def detach(self) -> BinaryIO: ...
    def read(self, __size: int | None = ...) -> str: ...
    def readline(self, __size: int = ...) -> str: ...  # type: ignore[override]
    def readlines(self, __hint: int = -1) -> list[str]: ...  # type: ignore[override]
    def write(self, __s: str) -> int: ...
    def writelines(self, __lines: Iterable[str]) -> None: ...  # type: ignore[override]

class TextIOWrapper(TextIOBase, _TextIOBase, TextIO):  # type: ignore[misc]  # incompatible definitions of methods in the base classes
    def __init__(
        self,
        buffer: IO[bytes],
        encoding: str | None = ...,
        errors: str | None = ...,
        newline: str | None = ...,
        line_buffering: bool = ...,
        write_through: bool = ...,
    ) -> None: ...
    @property
    def buffer(self) -> BinaryIO: ...
    @property
    def line_buffering(self) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def write_through(self) -> bool: ...
    def reconfigure(
        self,
        *,
        encoding: str | None = None,
        errors: str | None = None,
        newline: str | None = None,
        line_buffering: bool | None = None,
        write_through: bool | None = None,
    ) -> None: ...

    # these are only here so stubtest is happy with the argument names
    def truncate(self, __pos: int | None = ...) -> int: ...
    def seek(self, __cookie: int, __whence: int = ...) -> int: ...

class StringIO(TextIOWrapper, _TextIOBase):  # type: ignore[misc]  # incompatible definitions of methods in the base classes
    # StringIO does not contain a "name" field. This workaround is necessary
    # to allow StringIO sub-classes to add this field, as it is defined
    # as a read-only property on IO[].
    name: Any
    def __init__(self, initial_value: str | None = ..., newline: str | None = ...) -> None: ...
    @property
    def line_buffering(self) -> bool: ...
    def getvalue(self) -> str: ...

    # these are only here so stubtest is happy with the argument names
    def seek(self, __pos: int, __whence: int = ...) -> int: ...

class IncrementalNewlineDecoder(codecs.IncrementalDecoder):
    def __init__(self, decoder: codecs.IncrementalDecoder | None, translate: bool, errors: str = ...) -> None: ...
    @property
    def newlines(self) -> str | tuple[str, ...] | None: ...
    def decode(self, input: ReadableBuffer | str, final: bool = False) -> str: ...
    def setstate(self, __state: tuple[bytes, int]) -> None: ...
